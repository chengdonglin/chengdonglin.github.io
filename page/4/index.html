<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="厚朴酚">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="厚朴酚">
<meta property="og:description" content="学习笔记">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="厚朴酚">
<meta name="twitter:description" content="学习笔记">






  <link rel="canonical" href="http://yoursite.com/page/4/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>厚朴酚</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">厚朴酚</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">打磨技术!</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/HTML5的Blob对象/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/HTML5的Blob对象/" itemprop="url">
                  HTML5的Blob对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-09 13:31:53" itemprop="dateCreated datePublished" datetime="2018-11-09T13:31:53+08:00">2018-11-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-21 16:23:06" itemprop="dateModified" datetime="2018-11-21T16:23:06+08:00">2018-11-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/HTML5/" itemprop="url" rel="index"><span itemprop="name">HTML5</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HTML的Blob对象"><a href="#HTML的Blob对象" class="headerlink" title="HTML的Blob对象"></a>HTML的Blob对象</h3><p>####前言<br>一直以来，JS都没有比较好的可以直接处理二进制的方法。而Blob的存在，允许我们可以通过JS直接操作二进制数据。</p>
<h4 id="Blob对象"><a href="#Blob对象" class="headerlink" title="Blob对象"></a>Blob对象</h4><p>一个Blob对象就是一个包含有只读原始数据的类文件对象。Blob对象中的数据并不一定得是JavaScript中的原生形式。File接口基于Blob，继承了Blob的功能,并且扩展支持了用户计算机上的本地文件。</p>
<p>Blob对象可以看做是存放二进制数据的容器，此外还可以通过Blob设置二进制数据的MIME类型.</p>
<h4 id="创建Blob"><a href="#创建Blob" class="headerlink" title="创建Blob"></a>创建Blob</h4><pre><code>var blob = new Blob(dataArr:Array&lt;any&gt;, opt:{type:string});
</code></pre><ul>
<li>dataArray：数组，包含了要添加到Blob对象中的数据，数据可以是任意多个ArrayBuffer，ArrayBufferView， Blob，或者 DOMString对象。</li>
<li><p>opt：对象，用于设置Blob对象的属性（如：MIME类型）</p>
</li>
<li><p>创建一个装填DOMString对象的Blog对象</p>
<p>  var s = “ <div>hello world!!</div> “</p>
<p>  var blob = new Blob([s],{type:”text/xml”})</p>
<p>  blob</p>
<p>  Blob(24) {size: 24, type: “text/xml”}</p>
</li>
<li><p>创建一个装填ArrayBuffer对象的Blob对象</p>
<pre><code>var abf = new ArrayBuffer(8)
var blob = new Blob([abf],{type:&quot;text/plain&quot;})
blob
Blob{size:8,type:&quot;text/plain&quot;}
</code></pre></li>
<li><p>创建一个装填ArrayBufferView对象的Blob对象(ArrayBufferView可基于ArrayBuffer创建,返回值是一个类数组),如下:创建一个8字节的ArrayBuffer,在其上创建一个每个数组元素为2字节的视图</p>
<pre><code>var abf = new ArrayBuffer(8)
var abv = new Int16Array(abf)
var blob = new Blob(abv,{type:&quot;text/plain&quot;})
blob
Blob{size:4,type:&quot;text/plain&quot;}
</code></pre></li>
<li><p>通过Blob.slice()</p>
</li>
</ul>
<p>此方法返回一个新的BLob对象,包含了原对象指定范围内的数据</p>
<pre><code>Blob.slice(start:number,end:number,contentType:string)
</code></pre><ul>
<li>start: 开始索引,默认为0</li>
<li>end: 截取结束索引(不包括end)</li>
<li><p>contentType:新的Blob的MIME类型,默认为空字符串</p>
<pre><code>var b = new Blob([&quot;zxxxffggggff&quot;],{type:&quot;text/plain&quot;})
var b2 = b.slice(0,5,&quot;text/plain&quot;)
b2
Blob{size:5,type:&quot;text/plain&quot;}
</code></pre></li>
<li><p>通过canvas.toBlob()</p>
<pre><code>var canvas = document.getElementById(&quot;canvas&quot;);
canvas.toBlob(function(blob){
    console.log(blob);
});
</code></pre></li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>前面提到，File接口基于Blob，继承了Blob的功能并进行了扩展，故我们可以像使用Blob一样使用File对象。</p>
<ul>
<li>分片上传</li>
</ul>
<p>通过Blob.slice方法，可以将大文件分片，轮循向后台提交各文件片段，即可实现文件的分片上传。</p>
<p>分片上传逻辑如下：</p>
<ul>
<li>获取要上传文件的File对象，根据chunk（每片大小）对文件进行分片</li>
<li>通过post方法轮循上传每片文件，其中url中拼接querystring用于描述当前上传的文件信息；</li>
<li>post body中存放本次要上传的二进制数据片段</li>
<li>接口每次返回offset，用于执行下次上传</li>
</ul>
<p>下面是分片上传的简单实现：</p>
<pre><code>initUpload();

//初始化上传
function initUpload() {
    var chunk = 100 * 1024;   //每片大小
    var input = document.getElementById(&quot;file&quot;);    //input file
    input.onchange = function (e) {
        var file = this.files[0];
        var query = {};
        var chunks = [];
        if (!!file) {
            var start = 0;
            //文件分片
            for (var i = 0; i &lt; Math.ceil(file.size / chunk); i++) {
                var end = start + chunk;
                chunks[i] = file.slice(start , end);
                start = end;
            }

            // 采用post方法上传文件
            // url query上拼接以下参数，用于记录上传偏移
            // post body中存放本次要上传的二进制数据
            query = {
                fileSize: file.size,
                dataSize: chunk,
                nextOffset: 0
            }

            upload(chunks, query, successPerUpload);
        }
    }
}

// 执行上传
    function upload(chunks, query, cb) {
        var queryStr = Object.getOwnPropertyNames(query).map(key =&gt; {
            return key + &quot;=&quot; + query[key];
        }).join(&quot;&amp;&quot;);
        var xhr = new XMLHttpRequest();
        xhr.open(&quot;POST&quot;, &quot;http://xxxx/opload?&quot; + queryStr);
        xhr.overrideMimeType(&quot;application/octet-stream&quot;);

        //获取post body中二进制数据
        var index = Math.floor(query.nextOffset / query.dataSize);
        getFileBinary(chunks[index], function (binary) {
            if (xhr.sendAsBinary) {
                xhr.sendAsBinary(binary);
            } else {
                xhr.send(binary);
            }

        });

        xhr.onreadystatechange = function (e) {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    var resp = JSON.parse(xhr.responseText);
                    // 接口返回nextoffset
                    // resp = {
                    //     isFinish:false,
                    //     offset:100*1024
                    // }
                    if (typeof cb === &quot;function&quot;) {
                        cb.call(this, resp, chunks, query)
                    }
                }
            }
        }
    }

    // 每片上传成功后执行
    function successPerUpload(resp, chunks, query) {
        if (resp.isFinish === true) {
            alert(&quot;上传成功&quot;);
        } else {
            //未上传完毕
            query.offset = resp.offset;
            upload(chunks, query, successPerUpload);
        }
    }

    // 获取文件二进制数据
    function getFileBinary(file, cb) {
        var reader = new FileReader();
        reader.readAsArrayBuffer(file);
        reader.onload = function (e) {
            if (typeof cb === &quot;function&quot;) {
                cb.call(this, this.result);
            }
        }
    }
</code></pre><p>以上是文件分片上传前端的简单实现，当然，此功能还可以更加完善，如后台需要对合并后的文件大小进行校验；或者前端加密文件，全部上传完毕后后端解密校验等.</p>
<ul>
<li>通过url下载文件</li>
</ul>
<p>window.URL对象可以为Blob对象生成一个网络地址，结合a标签的download属性，可以实现点击url下载文件.</p>
<pre><code>createDownload(&quot;download.txt&quot;,&quot;download file&quot;);

function createDownload(fileName, content){
    var blob = new Blob([content]);
    var link = document.createElement(&quot;a&quot;);
    link.innerHTML = fileName;
    link.download = fileName;
    link.href = URL.createObjectURL(blob);
    document.getElementsByTagName(&quot;body&quot;)[0].appendChild(link);
}
</code></pre><ul>
<li>通过url显示图片</li>
</ul>
<p>我们知道，img的src属性及background的url属性，都可以通过接收图片的网络地址或base64来显示图片，同样的，我们也可以把图片转化为Blob对象，生成URL（URL.createObjectURL(blob)），来显示图片。</p>
<p>Blob对象作为一个装填二进制数据的基本对象，其作用也仅仅是一个容器，而真正的业务功能则需要通过FileReader、URL、Canvas等对象实现</p>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/html5的FileReader对象/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/html5的FileReader对象/" itemprop="url">
                  html5的FileReader对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-09 13:16:39 / 修改时间：13:31:15" itemprop="dateCreated datePublished" datetime="2018-11-09T13:16:39+08:00">2018-11-09</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/HTML5/" itemprop="url" rel="index"><span itemprop="name">HTML5</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HTML5的FileReader对象"><a href="#HTML5的FileReader对象" class="headerlink" title="HTML5的FileReader对象"></a>HTML5的FileReader对象</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>FileReader主要用于将文件内容读入内存，通过一系列异步接口，可以在主线程中访问本地文件。</p>
<p>使用FileReader对象，web应用程序可以异步的读取存储在用户计算机上的文件(或者原始数据缓冲)内容，可以使用File对象或者Blob对象来指定所要处理的文件或数据。</p>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><pre><code>var reader = new FileReader();
</code></pre><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre><code>方法定义                               描述
abort():void                     终止文件读取操作
readAsArrayBuffer(file):void     异步按字节读取文件内容，结果用ArrayBuffer对象表示
readAsBinaryString(file):void    异步按字节读取文件内容，结果为文件的二进制串
readAsDataURL(file):void         异步读取文件内容，结果用data:url的字符串形式表示
readAsText(file,encoding):void   异步按字符读取文件内容，结果用字符串形式表示
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>事件名称                         描述
onabort               当读取操作被中止时调用
onerror               当读取操作发生错误时调用
onload                当读取操作成功完成时调用
onloadend              当读取操作完成时调用,不管是成功还是失败
onloadstart              当读取操作将要开始之前调用    
onprogress              在读取数据过程中周期性调用
</code></pre><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>FileReader通过异步的方式读取文件内容，结果均是通过事件回调获取，下面是一个读取本地txt文件内容的例子：</p>
<pre><code>var input  = document.getElementById(&quot;file&quot;); //input file
input.onchange = function(){
    var file = this.files[0];
    if(!!file){
        //读取本地文件，以gbk编码方式输出
        var reader = new FileReader();
        reader.readAsText(file,&quot;gbk&quot;);
        reader.onload = function(){
            //读取完毕后输出结果
            console.log(this.result);
        }
    }
}
</code></pre><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>在线预览本地文件</li>
</ul>
<p>img的src属性或background的url属性，可以通过被赋值为图片网络地址或base64的方式显示图片。<br>在文件上传中，我们一般会先将本地文件上传到服务器，上传成功后，由后台返回图片的网络地址再在前端显示。<br>通过FileReader的readAsDataURL方法，我们可以不经过后台，直接将本地图片显示在页面上。这样做可以减少前后端频繁的交互过程，减少服务器端无用的图片资源，代码如下：</p>
<pre><code>var input  = document.getElementById(&quot;file&quot;);   // input file
input.onchange = function(){
    var file = this.files[0];
        if(!!file){
            var reader = new FileReader();
            // 图片文件转换为base64
            reader.readAsDataURL(file);
            reader.onload = function(){
                // 显示图片
                document.getElementById(&quot;file_img&quot;).src = this.result;
        }
    }
}
</code></pre><p>对于图片上传，我们也可以先将图片转换为base64进行传输，此时由于传输的图片内容就是一段字符串，故上传接口可以当做普通post接口处理，当图片传输到后台后，可以在转换为文件实体存储。<br>当然，考虑到base64转换效率及其本身的大小，本方法还是适合于上传内容简单或所占内存较小的文件。</p>
<ul>
<li>二进制数据上传</li>
</ul>
<p>我们可以直接上传或下载二进制内容，无需像以往一样通过form标签由后端拉取二进制内容。<br>简单整理下上传逻辑：<br>1、通过input[type=”file”]标签获取本地文件File对象<br>2、通过FileReader的readAsArrayBuffer方法将File对象转换为ArrayBuffer<br>3、创建xhr对象，配置请求信息<br>4、通过xhr.sendAsBinary直接将文件的ArrayBuffer内容装填至post body后发送</p>
<pre><code>var input  = document.getElementById(&quot;file&quot;);   // input file
input.onchange = function(){
    var file = this.files[0];
        if(!!file){
            var reader = new FileReader();
            reader.readAsArrayBuffer(file);
            reader.onload = function(){
                var binary = this.result;
                upload(binary);
        }
    }
}

//文件上传
function upload(binary){
    var xhr = new XMLHttpRequest();
    xhr.open(&quot;POST&quot;, &quot;http://xxxx/opload&quot;);
    xhr.overrideMimeType(&quot;application/octet-stream&quot;);
    //直接发送二进制数据
    if(xhr.sendAsBinary){
        xhr.sendAsBinary(binary);
    }else{
        xhr.send(binary);
    }

    // 监听变化
    xhr.onreadystatechange = function(e){
        if(xhr.readyState===4){
            if(xhr.status===200){
                // 响应成功       
            }
        }
    }
}
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/vue的一些工具方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/vue的一些工具方法/" itemprop="url">
                  vue的一些工具方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-09 10:17:33 / 修改时间：17:02:47" itemprop="dateCreated datePublished" datetime="2018-11-09T10:17:33+08:00">2018-11-09</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="常常应用的到的一些方法"><a href="#常常应用的到的一些方法" class="headerlink" title="常常应用的到的一些方法"></a>常常应用的到的一些方法</h3><pre><code>  /**
 * 判断两个对象是否相等
 * @param {*} obj1 
 * @param {*} obj2 
 */
export const objEqual = (obj1, obj2) =&gt; {
    const keysArr1 = Object.keys(obj1) //获取属性名
    const keysArr2 = Object.keys(obj2)
    if (keysArr1.length !== keysArr2.length) return false
    else if (keysArr1.length === 0 &amp;&amp; keysArr2.length === 0) return true
    else return !keysArr1.some(key =&gt; obj1[key] !== obj2[key])// some有一条相同返回true,取反为false
  }


/**
 * 根据路由的params生成对象
 * * */
  export const getRouteById = id =&gt; {
    let res = {}
    if (id.includes(&apos;&amp;&apos;)) {
      res.query = getObjBySplitStr(id, &apos;&amp;&apos;)
      id = id.split(&apos;&amp;&apos;)[0]
    }
    if (id.includes(&apos;:&apos;)) {
      res.params = getObjBySplitStr(id, &apos;:&apos;)
      id = id.split(&apos;:&apos;)[0]
    }
    res.name = id
    return res
  }


 export const routeEqual = (route1, route2) =&gt; {
    const params1 = route1.params || {} //逻辑或,route1.params不为空的话就返回他,或者返回{}空对象
    const params2 = route2.params || {}
    const query1 = route1.query || {} //因为路由传参有两种方式,所以要使用两种方式获取参数
    const query2 = route2.query || {}
    return route1.name === route2.name &amp;&amp; objEqual(params1, params2) &amp;&amp; objEqual(query1, query2)
  }
</code></pre><ul>
<li>点击上传Csv文件</li>
</ul>
<pre><code>/**
 * @param {Object} file 从上传组件得到的文件对象
 * @returns {Promise} resolve参数是解析后的二维数组
 * @description 从Csv文件中解析出表格，解析成二维数组
 */
export const getArrayFromFile = (file) =&gt; {
    let nameSplit = file.name.split(&apos;.&apos;) //按照指定符号.切割文件
    let format = nameSplit[nameSplit.length - 1] //[-1]得到文件名
    return new Promise((resolve, reject) =&gt; {//返回promise可以用then来获取
      let reader = new FileReader() //h5创建读取文件
      reader.readAsText(file) // 以文本格式读取
      let arr = []
      reader.onload = function (evt) {//event事件里面有各种属性
        let data = evt.target.result // 读到的数据
        let pasteData = data.trim() 
        //正则:[]指匹配里面任何一个都可以 \n 匹配一个换行符, \u0085匹配下一行 \u2028行分割 \u2029分段符号
        // \r 回车符 \n?匹配换行0此或者一次 /g代表全局匹配  \t匹配水平制表符
        arr = pasteData.split((/[\n\u0085\u2028\u2029]|\r\n?/g)).map(row =&gt; {
          return row.split(&apos;\t&apos;)
        }).map(item =&gt; {
          return item[0].split(&apos;,&apos;)
        })
        if (format === &apos;csv&apos;) resolve(arr)
        else reject(new Error(&apos;[Format Error]:你上传的不是Csv文件&apos;))
      }
    })
  }

/**
 * @param {Array} array 表格数据二维数组
 * @returns {Object} { columns, tableData }
 * @description 从二维数组中获取表头和表格数据，将第一行作为表头，用于在iView的表格中展示数据
 */
export const getTableDataFromArray = (array) =&gt; {
  let columns = []
  let tableData = []
  if (array.length &gt; 1) {
    let titles = array.shift() //删除数组中的第一个元素（red），并返回被删除元素的值
    columns = titles.map(item =&gt; {
      return {
        title: item,
        key: item
      }
    })
    tableData = array.map(item =&gt; {
      let res = {}
      item.forEach((col, i) =&gt; {
        res[titles[i]] = col
      })
      return res
    })
  }
  return {
    columns,
    tableData
  }
}

iview Upload组件的beforeUpload应用

beforeUpload (file) {//beforeUpload得到文件对象
      getArrayFromFile(file).then(data =&gt; {
        let {columns, tableData} = getTableDataFromArray(data)
        this.columns = columns
        this.tableData = tableData
      }).catch(() =&gt; {
        this.$Notice.warning({
          title: &apos;只能上传Csv文件&apos;,
          desc: &apos;只能上传Csv文件，请重新上传&apos;
        })
      })
      return false
    }
</code></pre><ul>
<li><p>数组的交集</p>
<pre><code>/**
 * @param {Array} arr1
 * @param {Array} arr2
 * @description 得到两个数组的交集, 两个数组的元素为数值或字符串
 */
export const getIntersection = (arr1, arr2) =&gt; {
  let len = Math.min(arr1.length, arr2.length)
  let i = -1
  let res = []
  while (++i &lt; len) {
    const item = arr2[i]
    if (arr1.indexOf(item) &gt; -1) res.push(item)
  }
  return res
}
</code></pre></li>
<li><p>数组的并集</p>
<pre><code>/**
 * @param {Array} arr1
 * @param {Array} arr2
 * @description 得到两个数组的并集, 两个数组的元素为数值或字符串
 */
export const getUnion = (arr1, arr2) =&gt; {
  return Array.from(new Set([...arr1, ...arr2]))
}
</code></pre></li>
</ul>
<ul>
<li>判断数组</li>
</ul>
<pre><code>/**
 * @param {Array} target 目标数组
 * @param {Array} arr 需要查询的数组
 * @description 判断要查询的数组是否至少有一个元素包含在目标数组中
 */
export const hasOneOf = (target, arr) =&gt; {
  return target.some(_ =&gt; arr.indexOf(_) &gt; -1)
}
</code></pre><ul>
<li><p>验证</p>
<pre><code>/**
 * @param {String|Number} value 要验证的字符串或数值
 * @param {*} validList 用来验证的列表
 */
export function oneOf (value, validList) {
  for (let i = 0; i &lt; validList.length; i++) {
    if (value === validList[i]) {
      return true
    }
  }
  return false
}
</code></pre></li>
</ul>
<pre><code>/**
 * 判断一个对象是否存在key，如果传入第二个参数key，则是判断这个obj对象是否存在key这个属性
 * 如果没有传入key这个参数，则判断obj对象是否有键值对
 */
export const hasKey = (obj, key) =&gt; {
  if (key) return key in obj
  else {
    let keysArr = Object.keys(obj)
    return keysArr.length
  }
}
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/node-js模块定义模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/node-js模块定义模式/" itemprop="url">
                  node.js模块定义模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-09 08:52:42 / 修改时间：09:42:02" itemprop="dateCreated datePublished" datetime="2018-11-09T08:52:42+08:00">2018-11-09</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/node-js/" itemprop="url" rel="index"><span itemprop="name">node.js</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="模块定义模式"><a href="#模块定义模式" class="headerlink" title="模块定义模式"></a>模块定义模式</h3><p>模块除了用于加载依赖关系的机制之外,还用于定义API工具,最大限度地隐藏信息和API可用性,可扩展性和代码复用.</p>
<h4 id="命名导出"><a href="#命名导出" class="headerlink" title="命名导出"></a>命名导出</h4><p>最基本的方法,把要公开的值赋给由exports(或者module.exports)引用对象的属性.生成导出对象为一组相关功能的容器或命名空间.</p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><ul>
<li>定义模块</li>
</ul>
<pre><code>//file  logger.js
exports.info = (message) =&gt; {
    console.log(&apos;info:&apos;+message)
}

exports.verbose = (message) =&gt; {
    console.log(&apos;verbose&apos; + message)
}
</code></pre><ul>
<li>引用模块</li>
</ul>
<pre><code>const logger = require(&apos;./logger&apos;)

logger.info(&apos;this is info&apos;)

logger.verbose(&apos;this is a verbose&apos;)
</code></pre><h4 id="导出函数-–substack模式"><a href="#导出函数-–substack模式" class="headerlink" title="导出函数 –substack模式"></a>导出函数 –substack模式</h4><p>最流行的一种模块定义模式是将整个module.exports变量重新分配给一个函数,主要优点只暴露一个单一的功能,提供明确的入口点,遵守小接触面的原则,也称为substack模式</p>
<h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><ul>
<li><p>定义导出函数模块</p>
<pre><code>//logger.js
module.exports = (message) =&gt; {//默认导出的
    console.log(`info:${message}`)
}

module.exports.verbose = (message) =&gt; {
    console.log(`verbose:${message}`)
}
</code></pre></li>
<li><p>引用模块</p>
<pre><code>//file main.js

const logger = require(&apos;./module&apos;)

logger(&apos;this is info default function&apos;)

logger.verbose(&apos;this is verbose function&apos;)
</code></pre></li>
</ul>
<p>虽然只输出一个函数看上去是一种限制,实际上它是一种完美的方式,把重心放在一个模块最重要的单一功能,减低内部的可见性同时,导出函数本身的属性,node.js的模块快极大鼓励采用单一责任原则,每个模块应该对单个功能负责,该责任完全由模块封装.</p>
<h4 id="导出构造函数"><a href="#导出构造函数" class="headerlink" title="导出构造函数"></a>导出构造函数</h4><p>导出构造函数的模块是导出函数模块的特别化, 区别在于:使用该模式,允许用户使用构造函数创建新实例,还可以扩展其原型并创建新类</p>
<ul>
<li><p>定义构造函数模块</p>
<pre><code>//logger.js
function Logger(name) {
    this.name = name
}

Logger.prototype.log = function(message){
    console.log(`[${this.name}] ${message}`)
}

Logger.prototype.verbose = function(message) {
    this.log(`info:${message}`)
}

Logger.prototype.info = function(message) {
    this.log(`info:${message}`)
}

module.exports = Logger
</code></pre></li>
<li><p>引用构造函数</p>
</li>
</ul>
<pre><code>const Logger = require(&apos;./module&apos;)
const dblog = new Logger(&apos;db&apos;)

dblog.info(&apos;this info fun&apos;)

const accessLogger = new Logger(&apos;adcb&apos;)
accessLogger.verbose(&apos;this is verbose fun&apos;)
</code></pre><ul>
<li><p>ES6方式</p>
<pre><code>class Logger {
    constructor(name) {
        this.name = name
    }
    log(message) {
        console.log(`[${this.name}] [${message}]`)
    }
    info(message) {
        this.log(`info:${message}`)
    }
    verbose(message) {
        this.log(`verbose:${message}`)
    }
}

module.exports = Logger;
</code></pre></li>
</ul>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/08/javascript闭包/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/08/javascript闭包/" itemprop="url">
                  javascript闭包
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-08 14:48:42 / 修改时间：15:17:06" itemprop="dateCreated datePublished" datetime="2018-11-08T14:48:42+08:00">2018-11-08</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="学习javascript闭包"><a href="#学习javascript闭包" class="headerlink" title="学习javascript闭包"></a>学习javascript闭包</h3><h4 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h4><p>变量的作用域无非就两种:全局变量和局部变量</p>
<ul>
<li><p>函数内部可以直接读取全局变量</p>
<pre><code>var n =1;
function f1(){
    alert(n)
}
f1();//1
</code></pre></li>
<li><p>函数外部无法读取函数内的局部变量</p>
<pre><code>function f1(){
var n =1
}
alert(n) //n is not defined
</code></pre></li>
</ul>
<h4 id="外部如何读取局部变量"><a href="#外部如何读取局部变量" class="headerlink" title="外部如何读取局部变量"></a>外部如何读取局部变量</h4><ul>
<li><p>那就是在函数的内部，再定义一个函数。</p>
<pre><code>function f1(){
　　var n=999;
　　function f2(){
　　alert(n); 
　　}
　　return f2;
　　}
var result=f1();
result();//999
</code></pre></li>
</ul>
<p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，就可以在f1外部读取它的内部变量了吗！</p>
<h3 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h3><p>闭包就是能够读取其他函数内部变量的函数。<br>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。<br>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<h3 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h3><ul>
<li>一个是前面提到的可以读取函数内部的变量</li>
<li><p>另一个就是让这些变量的值始终保持在内存中。</p>
<pre><code>function f1(){

　　　　var n=999;

　　　　nAdd=function(){n+=1}

　　　　function f2(){
　　　　　　alert(n);
　　　　}

　　　　return f2;

　　}

　　var result=f1();

　　result(); // 999

　　nAdd();

　　result(); // 1000
</code></pre></li>
</ul>
<p>result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p>
<p>原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<h3 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h3><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/08/javaScript的异步编程解决方案-Promise/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/08/javaScript的异步编程解决方案-Promise/" itemprop="url">
                  javaScript的异步编程解决方案-Promise
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-08 13:27:18 / 修改时间：14:45:20" itemprop="dateCreated datePublished" datetime="2018-11-08T13:27:18+08:00">2018-11-08</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="javascript异步编程解决方案-promise"><a href="#javascript异步编程解决方案-promise" class="headerlink" title="javascript异步编程解决方案-promise"></a>javascript异步编程解决方案-promise</h2><p>主要内容根据阮一峰的书籍ES6第三版</p>
<h3 id="Promise的含义"><a href="#Promise的含义" class="headerlink" title="Promise的含义"></a>Promise的含义</h3><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6规定: Promise对象是一个构造函数,用来生成Promise示例</p>
<pre><code>const promise = new Promise(function(resolve,reject){
            //...some code
            let a = 3 + 5
            if (a) {//异步操作成功,保存结果值
                resolve(a)
            } else {
                reject(error)
            }
        })
        promise.then() //Promise {&lt;pending&gt;}
        console.log(promise.then((value)=&gt;{
            console.log(value) //8
        }))
</code></pre><p>Promise构造函数接收一个函数为参数,该函数的两个参数分别是resolve和reject.(分别是两个函数)</p>
<ul>
<li><p>resolve函数的作用: 将Promise对象的状态从”未完成”变为”成功”,既从pending变为resolved,在异步操作成功调用,并将异步操作的结果,作为参数传递出去.</p>
</li>
<li><p>reject函数的作用:将Promise对象的状态从”未完成”变为失败,既从pending变为reject,在异步操作失败的时候调用,并将异步操作报出的错误作为参数传递出去.</p>
</li>
</ul>
<p>Promise实例生成以后,可以用then方法分别指定resolved状态和rejected状态的回调函数.</p>
<pre><code>promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
</code></pre><ul>
<li>then方法可以接受两个回调函数作为参数, 第一个回调函数是Promise对象的状态变为resolved时调用, 第二回调函数是promise对象变为reject时候调用,其中,第二个函数是可选的,不一定要提供,这两个函数都接收Promise对象传出的值作为参数.</li>
</ul>
<h4 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h4><pre><code>function timeout(ms) {
            return new Promise((resolve,reject)=&gt;{
                setTimeout(resolve,ms,&apos;done&apos;)
            })
        }

        timeout(100).then((value)=&gt;{
            console.log(value) //输出done
        })
</code></pre><p>解析: timeout方法返回一个Promise实例,表示一段时间以后才会发送的结果,过了指定参数ms以后,Promise实例的状态变为resolved,就会触发then方法绑定的回调函数.</p>
<h4 id="一个promise知识点-Promise新建后会立即执行"><a href="#一个promise知识点-Promise新建后会立即执行" class="headerlink" title="一个promise知识点:Promise新建后会立即执行"></a>一个promise知识点:Promise新建后会立即执行</h4><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><pre><code>let test = new Promise(function(resolve,reject){
        console.log(&apos;Promise&apos;)
        resolve()
    })
    test.then(function(){
        console.log(&apos;resolved&apos;)
    })
    console.log(&apos;hello promise&apos;)
    //输出的顺序
    //  Promise
    //  hello promise
    //  resolved
</code></pre><p>解析: Promise新建之后立即执行,所以首先输出的是Promise,然后then方法指定的回调韩素华,将在当前脚本所有同步任务执行完才会执行,所有resolved最后输出.</p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><pre><code>function loadImageAsync(url){
        return new Promise(function(resolve,reject){
            const image = new Image()
            image.onload = function(){
                resolve(image)
            }
            image.onerror = function(){
                reject(new Error(&apos;could not load image at&apos; + url))
            }
            image.src = url
        })
    }
</code></pre><p>没给参数调用的结果</p>
<pre><code>loadImageAsync().then(function(value){
    console.log(value)
},function(error){
    console.log(error)
})
</code></pre><p>Error: could not load image atundefined<br>    at Image.image.onerror (promise.html:54)</p>
<h5 id="用Promise对象实现的-Ajax-操作的例子。"><a href="#用Promise对象实现的-Ajax-操作的例子。" class="headerlink" title="用Promise对象实现的 Ajax 操作的例子。"></a>用Promise对象实现的 Ajax 操作的例子。</h5><pre><code>const getJSON = function(url){
    const promise = new Promise(function (resolve,reject) {
        const handler = function(){
            if (this.readyState !== 4){
                return
            }
            if (this.status === 200) {
                resolve(this.response)
            } else {
                reject(new Error(this.statusText))
            }
        }
        const client = new XMLHttpRequest()
        client.open(&quot;GET&quot;,url)
        client.onreadystatechange = handler
        client.responseType = &quot;json&quot;
        client.setRequestHeader(&quot;Accept&quot;,&quot;application/json&quot;)
        client.send()
      })
      return promise
}
    getJSON(&quot;/post.json&quot;).then(function(json){
        console.log(&apos;Contents:&apos; + json)
    },function(error){
        console.error(&apos;c出错了&apos;, error)
    })
</code></pre><p>上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。</p>
<p>如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>
<pre><code>const p1 = new Promise(function (resolve, reject) {
  // ...
});

const p2 = new Promise(function (resolve, reject) {
  // ...
  resolve(p1);
})
</code></pre><p>注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。</p>
<pre><code>const p1 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; reject(new Error(&apos;fail&apos;)), 3000)
})

const p2 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; resolve(p1), 1000)
})

p2
  .then(result =&gt; console.log(result))
  .catch(error =&gt; console.log(error))
// Error: fail
</code></pre><p>上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</p>
<p>注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。</p>
<pre><code>new Promise((resolve, reject) =&gt; {
  resolve(1);
  console.log(2);
}).then(r =&gt; {
  console.log(r);
});
// 2
// 1
</code></pre><p>上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>
<p>一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。</p>
<pre><code>new Promise((resolve, reject) =&gt; {
  return resolve(1);
  // 后面的语句不会执行
  console.log(2);
})
</code></pre><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p>
<p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<pre><code>getJSON(&quot;/posts.json&quot;).then(function(json) {
  return json.post;
}).then(function(post) {
  // ...
});
</code></pre><p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>
<pre><code>getJSON(&quot;/post/1.json&quot;).then(function(post) {
  return getJSON(post.commentURL);
}).then(function funcA(comments) {
  console.log(&quot;resolved: &quot;, comments);
}, function funcB(err){
  console.log(&quot;rejected: &quot;, err);
});
</code></pre><p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。</p>
<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>
<pre><code>getJSON(&quot;/post/1.json&quot;).then(
  post =&gt; getJSON(post.commentURL)
).then(
  comments =&gt; console.log(&quot;resolved: &quot;, comments),
  err =&gt; console.log(&quot;rejected: &quot;, err)
);
</code></pre><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<pre><code>getJSON(&apos;/posts.json&apos;).then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log(&apos;发生错误！&apos;, error);
});
</code></pre><p>上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p>
<pre><code>p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))
  .catch((err) =&gt; console.log(&apos;rejected&apos;, err));

// 等同于
p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))
  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));
</code></pre><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</p>
<pre><code>getJSON(&apos;/post/1.json&apos;).then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
});
</code></pre><p>上面代码中，一共有三个 Promise 对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。</p>
<p>一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。</p>
<pre><code>// bad
promise
  .then(function(data) {
    // success
  }, function(err) {
    // error
  });

// good
promise
  .then(function(data) { //cb
    // success
  })
  .catch(function(err) {
    // error
  });
</code></pre><p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。</p>
<pre><code>Promise.resolve()
.catch(function(error) {
  console.log(&apos;oh no&apos;, error);
})
.then(function() {
  console.log(&apos;carry on&apos;);
});
// carry on
</code></pre><p>上面的代码因为没有报错，跳过了catch方法，直接执行后面的then方法。此时，要是then方法里面报错，就与前面的catch无关了。</p>
<p>一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。</p>
<h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<pre><code>promise
.then(result =&gt; {···})
.catch(error =&gt; {···})
.finally(() =&gt; {···});
</code></pre><p>上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p>
<pre><code>server.listen(port)
  .then(function () {
    // ...
  })
  .finally(server.stop);
</code></pre><p>finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<p>finally本质上是then方法的特例。</p>
<pre><code>promise
.finally(() =&gt; {
  // 语句
});

// 等同于
promise
.then(
  result =&gt; {
    // 语句
    return result;
  },
  error =&gt; {
    // 语句
    throw error;
  }
);
</code></pre><p>上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。</p>
<pre><code>Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    value  =&gt; P.resolve(callback()).then(() =&gt; value),
    reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason })
  );
};
</code></pre><p>上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。</p>
<p>从上面的实现还可以看到，finally方法总是会返回原来的值。</p>
<pre><code>// resolve 的值是 undefined
Promise.resolve(2).then(() =&gt; {}, () =&gt; {})

// resolve 的值是 2
Promise.resolve(2).finally(() =&gt; {})

// reject 的值是 undefined
Promise.reject(3).then(() =&gt; {}, () =&gt; {})

// reject 的值是 3
Promise.reject(3).finally(() =&gt; {})
</code></pre><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<pre><code>const p = Promise.all([p1, p2, p3]);
</code></pre><p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p>
<p>p的状态由p1、p2、p3决定，分成两种情况。</p>
<p>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p>
<p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>
<pre><code>// 生成一个Promise对象的数组

const promises = [2, 3, 5, 7, 11, 13].map(function (id) {
  return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;);
});

Promise.all(promises).then(function (posts) {
  // ...
}).catch(function(reason){
  // ...
});
</code></pre><p>上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。</p>
<pre><code>const databasePromise = connectDatabase();

const booksPromise = databasePromise
  .then(findAllBooks);

const userPromise = databasePromise
  .then(getCurrentUser);

Promise.all([
  booksPromise,
  userPromise
])
.then(([books, user]) =&gt; pickTopRecommentations(books, user));
</code></pre><p>上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。</p>
<p>注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</p>
<pre><code>const p1 = new Promise((resolve, reject) =&gt; {
  resolve(&apos;hello&apos;);
})
.then(result =&gt; result)
.catch(e =&gt; e);

const p2 = new Promise((resolve, reject) =&gt; {
  throw new Error(&apos;报错了&apos;);
})
.then(result =&gt; result)
.catch(e =&gt; e);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// [&quot;hello&quot;, Error: 报错了]
</code></pre><p>上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。</p>
<p>如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。</p>
<pre><code>const p1 = new Promise((resolve, reject) =&gt; {
  resolve(&apos;hello&apos;);
})
.then(result =&gt; result);

const p2 = new Promise((resolve, reject) =&gt; {
  throw new Error(&apos;报错了&apos;);
})
.then(result =&gt; result);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// Error: 报错了
</code></pre><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<pre><code>const p = Promise.race([p1, p2, p3]);
</code></pre><p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p>
<p>Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p>
<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。</p>
<pre><code>const p = Promise.race([
  fetch(&apos;/resource-that-may-take-a-while&apos;),
  new Promise(function (resolve, reject) {
    setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000)
  })
]);

p
.then(console.log)
.catch(console.error);
</code></pre><p>上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。</p>
<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p>有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用</p>
<pre><code>const jsPromise = Promise.resolve($.ajax(&apos;/whatever.json&apos;));
</code></pre><p>上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。<br>Promise.resolve等价于下面的写法。</p>
<pre><code>Promise.resolve(&apos;foo&apos;)
// 等价于
new Promise(resolve =&gt; resolve(&apos;foo&apos;))
</code></pre><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h4><p>我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。</p>
<pre><code>const preloadImage = function (path) {
  return new Promise(function (resolve, reject) {
    const image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  });
};
</code></pre><h4 id="Generator与Promise的结合"><a href="#Generator与Promise的结合" class="headerlink" title="Generator与Promise的结合"></a>Generator与Promise的结合</h4><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。</p>
<pre><code>function getFoo () {
  return new Promise(function (resolve, reject){
    resolve(&apos;foo&apos;);
  });
}

const g = function* () {
  try {
    const foo = yield getFoo();
    console.log(foo);
  } catch (e) {
    console.log(e);
  }
};

function run (generator) {
  const it = generator();

  function go(result) {
    if (result.done) return result.value;

    return result.value.then(function (value) {
      return go(it.next(value));
    }, function (error) {
      return go(it.throw(error));
    });
  }

  go(it.next());
}

run(g);
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/06/vue修饰符/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/06/vue修饰符/" itemprop="url">
                  vue修饰符
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-06 18:14:46 / 修改时间：19:07:55" itemprop="dateCreated datePublished" datetime="2018-11-06T18:14:46+08:00">2018-11-06</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="vue修饰符"><a href="#vue修饰符" class="headerlink" title="vue修饰符"></a>vue修饰符</h2><h3 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h3><ul>
<li>.lazy</li>
</ul>
<p>这样只有当我们光标离开输入框的时候，它才会更新视图，相当于在onchange事件触发更新</p>
<ul>
<li>.trim</li>
</ul>
<p>能过滤首尾的空格！首尾，中间的是不会过滤的</p>
<ul>
<li>.number</li>
</ul>
<p>如果你先输入数字，那它就会限制你输入的只能是数字。</p>
<p>如果你先输入字符串，那它就相当于没有加.number</p>
<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ul>
<li>.stop</li>
</ul>
<p>由于事件冒泡的机制,我们给元素绑定点击事件的时候，也会触发父级的点击事件.</p>
<p>一键阻止事件冒泡，简直方便得不行。相当于调用了event.stopPropagation()方法。</p>
<ul>
<li>.prevent</li>
</ul>
<p>用于阻止事件的默认行为，例如，当点击提交按钮时阻止对表单的提交。相当于调用了event.preventDefault()方法。</p>
<p>注意：修饰符可以同时使用多个,但是可能会因为顺序而有所不同。<br>用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。<br>也就是从左往右判断.</p>
<ul>
<li>.self</li>
</ul>
<p>只当事件是从事件绑定的元素本身触发时才触发回调。像下面所示，刚刚我们从.stop时候知道子元素会冒泡到父元素导致触发父元素的点击事件，当我们加了这个.self以后，我们点击button不会触发父元素的点击事件shout，只有当点击到父元素的时候（蓝色背景）才会shout~从这个self的英文翻译过来就是‘自己，本身’可以看出这个修饰符的用法</p>
<ul>
<li>.once</li>
</ul>
<p>这个修饰符的用法也是和名字一样简单粗暴，只能用一次，绑定了事件以后只能触发一次，第二次就不会触发。</p>
<ul>
<li>.capture</li>
</ul>
<p>从上面我们知道了事件的冒泡，其实完整的事件机制是：捕获阶段–目标阶段–冒泡阶段。<br>默认的呢，是事件触发是从目标开始往上冒泡。<br>当我们加了这个.capture以后呢，我们就反过来了，事件触发从包含这个元素的顶层开始往下触发。</p>
<p>从上面这个例子我们点击obj4的时候，就可以清楚地看出区别，obj1，obj2在捕获阶段就触发了事件，因此是先1后2，后面的obj3，obj4是默认的冒泡阶段触发，因此是先4然后冒泡到3~</p>
<ul>
<li>.passive</li>
</ul>
<p>当我们在监听元素滚动事件的时候，会一直触发onscroll事件，在pc端是没啥问题的，但是在移动端，会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给onscroll事件整了一个.lazy修饰符</p>
<ul>
<li>.native</li>
</ul>
<p>必须使用.native来修饰这个click事件（即<my-component @click.native="shout(3)"></my-component>），可以理解为该修饰符的作用就是把一个vue组件转化为一个普通的HTML标签，<br>注意：使用.native修饰符来操作普通HTML标签是会令事件失效的</p>
<h3 id="键值修饰符"><a href="#键值修饰符" class="headerlink" title="键值修饰符"></a>键值修饰符</h3><pre><code>//普通键
.enter 
.tab
.delete //(捕获“删除”和“退格”键)
.space
.esc
.up
.down
.left
.right
//系统修饰键
.ctrl
.alt
.meta
.shift
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/06/js复杂判断的优雅写法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/06/js复杂判断的优雅写法/" itemprop="url">
                  js复杂判断的优雅写法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-06 13:31:47 / 修改时间：13:52:11" itemprop="dateCreated datePublished" datetime="2018-11-06T13:31:47+08:00">2018-11-06</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JS复杂判断的优雅写法"><a href="#JS复杂判断的优雅写法" class="headerlink" title="JS复杂判断的优雅写法"></a>JS复杂判断的优雅写法</h2><p>教程来源链接:</p>
<p><a href="https://juejin.im/post/5bdfef86e51d453bf8051bf8" target="_blank" rel="noopener">https://juejin.im/post/5bdfef86e51d453bf8051bf8</a></p>
<p>作者:Think</p>
<p>来源: 掘金</p>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提:"></a>前提:</h3><p>编写js代码时经常遇到复杂逻辑判的情况，通常大家可以用if/else或者switch来实现多个条件判断，但这样会有个问题，随着逻辑复杂度的增加，代码中的if/else/switch会变得越来越臃肿，越来越看不懂，那么如何更优雅的写判断逻辑。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="if-else实现"><a href="#if-else实现" class="headerlink" title="if/else实现"></a>if/else实现</h4><pre><code>/**
 * 按钮点击事件
 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消
 */
const onButtonClick1 = (status)=&gt;{
  if(status == 1){
    sendLog(&apos;processing&apos;)
    jumpTo(&apos;IndexPage&apos;)
  }else if(status == 2){
    sendLog(&apos;fail&apos;)
    jumpTo(&apos;FailPage&apos;)
  }else if(status == 3){
    sendLog(&apos;fail&apos;)
    jumpTo(&apos;FailPage&apos;)
  }else if(status == 4){
    sendLog(&apos;success&apos;)
    jumpTo(&apos;SuccessPage&apos;)
  }else if(status == 5){
    sendLog(&apos;cancel&apos;)
    jumpTo(&apos;CancelPage&apos;)
  }else {
    sendLog(&apos;other&apos;)
    jumpTo(&apos;Index&apos;)
  }
}
</code></pre><p>通过代码可以看到这个按钮的点击逻辑：根据不同活动状态做两件事情，发送日志埋点和跳转到对应页面，大家可以很轻易的提出这段代码的改写方案，switch出场：</p>
<h4 id="switch改进"><a href="#switch改进" class="headerlink" title="switch改进"></a>switch改进</h4><pre><code>/**
 * 按钮点击事件
 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消
 */
const onButtonClick = (status)=&gt;{
  switch (status){
    case 1:
      sendLog(&apos;processing&apos;)
      jumpTo(&apos;IndexPage&apos;)
      break
    case 2:
    case 3:
      sendLog(&apos;fail&apos;)
      jumpTo(&apos;FailPage&apos;)
      break  
    case 4:
      sendLog(&apos;success&apos;)
      jumpTo(&apos;SuccessPage&apos;)
      break
    case 5:
      sendLog(&apos;cancel&apos;)
      jumpTo(&apos;CancelPage&apos;)
      break
    default:
      sendLog(&apos;other&apos;)
      jumpTo(&apos;Index&apos;)
      break
  }
}
</code></pre><p>这样看起来比if/else清晰多了，细心的同学也发现了小技巧，case 2和case 3逻辑一样的时候，可以省去执行语句和break，则case 2的情况自动执行case 3的逻辑。</p>
<h4 id="条件作为属性名的实现"><a href="#条件作为属性名的实现" class="headerlink" title="条件作为属性名的实现"></a>条件作为属性名的实现</h4><pre><code>const actions = {
  &apos;1&apos;: [&apos;processing&apos;,&apos;IndexPage&apos;],
  &apos;2&apos;: [&apos;fail&apos;,&apos;FailPage&apos;],
  &apos;3&apos;: [&apos;fail&apos;,&apos;FailPage&apos;],
  &apos;4&apos;: [&apos;success&apos;,&apos;SuccessPage&apos;],
  &apos;5&apos;: [&apos;cancel&apos;,&apos;CancelPage&apos;],
  &apos;default&apos;: [&apos;other&apos;,&apos;Index&apos;],
}
/**
 * 按钮点击事件
 * @param {number} status 活动状态：1开团进行中 2开团失败 3 商品售罄 4 开团成功 5 系统取消
 */
const onButtonClick = (status)=&gt;{
  let action = actions[status] || actions[&apos;default&apos;],
      logName = action[0],
      pageName = action[1]
  sendLog(logName)
  jumpTo(pageName)
}
</code></pre><p>这种方法的聪明之处在于：将判断条件作为对象的属性名，将处理逻辑作为对象的属性值，在按钮点击的时候，通过对象属性查找的方式来进行逻辑判断，这种写法特别适合一元条件判断的情况。</p>
<h4 id="再一种方法"><a href="#再一种方法" class="headerlink" title="再一种方法"></a>再一种方法</h4><pre><code>const actions = new Map([
  [1, [&apos;processing&apos;,&apos;IndexPage&apos;]],
  [2, [&apos;fail&apos;,&apos;FailPage&apos;]],
  [3, [&apos;fail&apos;,&apos;FailPage&apos;]],
  [4, [&apos;success&apos;,&apos;SuccessPage&apos;]],
  [5, [&apos;cancel&apos;,&apos;CancelPage&apos;]],
  [&apos;default&apos;, [&apos;other&apos;,&apos;Index&apos;]]
])
/**
 * 按钮点击事件
 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消
 */
const onButtonClick = (status)=&gt;{
  let action = actions.get(status) || actions.get(&apos;default&apos;)
  sendLog(action[0])
  jumpTo(action[1])
}
</code></pre><p>这样写用到了es6里的Map对象，是不是更爽了？Map对象和Object对象有什么区别呢？</p>
<ol>
<li>一个对象通常都有自己的原型，所以一个对象总有一个”prototype”键。</li>
<li>一个对象的键只能是字符串或者Symbols，但一个Map的键可以是任意值。</li>
<li>你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。</li>
</ol>
<p>把问题升级一下，以前按钮点击时候只需要判断status，现在还需要判断用户的身份:</p>
<pre><code>/**
 * 按钮点击事件
 * @param {number} status 活动状态：1开团进行中 2开团失败 3 开团成功 4 商品售罄 5 有库存未开团
 * @param {string} identity 身份标识：guest客态 master主态
 */
const onButtonClick = (status,identity)=&gt;{
  if(identity == &apos;guest&apos;){
    if(status == 1){
      //do sth
    }else if(status == 2){
      //do sth
    }else if(status == 3){
      //do sth
    }else if(status == 4){
      //do sth
    }else if(status == 5){
      //do sth
    }else {
      //do sth
    }
  }else if(identity == &apos;master&apos;) {
    if(status == 1){
      //do sth
    }else if(status == 2){
      //do sth
    }else if(status == 3){
      //do sth
    }else if(status == 4){
      //do sth
    }else if(status == 5){
      //do sth
    }else {
      //do sth
    }
  }
}
</code></pre><p>从上面的例子我们可以看到，当你的逻辑升级为二元判断时，你的判断量会加倍，你的代码量也会加倍，这时怎么写更清爽呢？</p>
<pre><code>const actions = new Map([
  [&apos;guest_1&apos;, ()=&gt;{/*do sth*/}],
  [&apos;guest_2&apos;, ()=&gt;{/*do sth*/}],
  [&apos;guest_3&apos;, ()=&gt;{/*do sth*/}],
  [&apos;guest_4&apos;, ()=&gt;{/*do sth*/}],
  [&apos;guest_5&apos;, ()=&gt;{/*do sth*/}],
  [&apos;master_1&apos;, ()=&gt;{/*do sth*/}],
  [&apos;master_2&apos;, ()=&gt;{/*do sth*/}],
  [&apos;master_3&apos;, ()=&gt;{/*do sth*/}],
  [&apos;master_4&apos;, ()=&gt;{/*do sth*/}],
  [&apos;master_5&apos;, ()=&gt;{/*do sth*/}],
  [&apos;default&apos;, ()=&gt;{/*do sth*/}],
])

/**
 * 按钮点击事件
 * @param {string} identity 身份标识：guest客态 master主态
 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 开团成功 4 商品售罄 5 有库存未开团
 */
const onButtonClick = (identity,status)=&gt;{
  let action = actions.get(`${identity}_${status}`) || actions.get(&apos;default&apos;)
  action.call(this)
}
</code></pre><p>上述代码核心逻辑是：把两个条件拼接成字符串，并通过以条件拼接字符串作为键，以处理函数作为值的Map对象进行查找并执行，这种写法在多元条件判断时候尤其好用。</p>
<p>当然上述代码如果用Object对象来实现也是类似的：</p>
<pre><code>const actions = {
  &apos;guest_1&apos;:()=&gt;{/*do sth*/},
  &apos;guest_2&apos;:()=&gt;{/*do sth*/},
  //....
}

const onButtonClick = (identity,status)=&gt;{
  let action = actions[`${identity}_${status}`] || actions[&apos;default&apos;]
  action.call(this)
}
</code></pre><p>如果觉得把查询条件拼成字符串有点别扭，那还有一种方案，就是用Map对象，以Object对象作为key：</p>
<pre><code>const actions = new Map([
  [{identity:&apos;guest&apos;,status:1},()=&gt;{/*do sth*/}],
  [{identity:&apos;guest&apos;,status:2},()=&gt;{/*do sth*/}],
  //...
])

const onButtonClick = (identity,status)=&gt;{
  let action = [...actions].filter(([key,value])=&gt;(key.identity == identity &amp;&amp; key.status == status))
  action.forEach(([key,value])=&gt;value.call(this))
}
</code></pre><p>这里也看出来Map与Object的区别，Map可以用任何类型的数据作为key。</p>
<p>我们现在再将难度升级一点点，假如guest情况下，status1-4的处理逻辑都一样怎么办，最差的情况是这样：</p>
<pre><code>const actions = new Map([
  [{identity:&apos;guest&apos;,status:1},()=&gt;{/* functionA */}],
  [{identity:&apos;guest&apos;,status:2},()=&gt;{/* functionA */}],
  [{identity:&apos;guest&apos;,status:3},()=&gt;{/* functionA */}],
  [{identity:&apos;guest&apos;,status:4},()=&gt;{/* functionA */}],
  [{identity:&apos;guest&apos;,status:5},()=&gt;{/* functionB */}],
  //...
])
</code></pre><p>好一点的写法是将处理逻辑函数进行缓存：</p>
<pre><code>const actions = ()=&gt;{
  const functionA = ()=&gt;{/*do sth*/}
  const functionB = ()=&gt;{/*do sth*/}
  return new Map([
    [{identity:&apos;guest&apos;,status:1},functionA],
    [{identity:&apos;guest&apos;,status:2},functionA],
    [{identity:&apos;guest&apos;,status:3},functionA],
    [{identity:&apos;guest&apos;,status:4},functionA],
    [{identity:&apos;guest&apos;,status:5},functionB],
    //...
  ])
}

const onButtonClick = (identity,status)=&gt;{
  let action = [...actions()].filter(([key,value])=&gt;(key.identity == identity &amp;&amp; key.status == status))
  action.forEach(([key,value])=&gt;value.call(this))
}
</code></pre><p>这样写已经能满足日常需求了，但认真一点讲，上面重写了4次functionA还是有点不爽，假如判断条件变得特别复杂，比如identity有3种状态，status有10种状态，那你需要定义30条处理逻辑，而往往这些逻辑里面很多都是相同的，那可以这样实现:</p>
<pre><code>const actions = ()=&gt;{
  const functionA = ()=&gt;{/*do sth*/}
  const functionB = ()=&gt;{/*do sth*/}
  return new Map([
    [/^guest_[1-4]$/,functionA],
    [/^guest_5$/,functionB],
    //...
  ])
}

const onButtonClick = (identity,status)=&gt;{
  let action = [...actions()].filter(([key,value])=&gt;(key.test(`${identity}_${status}`)))
  action.forEach(([key,value])=&gt;value.call(this))
}
</code></pre><p>这里Map的优势更加凸显，可以用正则类型作为key了，这样就有了无限可能，假如需求变成，凡是guest情况都要发送一个日志埋点，不同status情况也需要单独的逻辑处理，那我们可以这样写:</p>
<pre><code>const actions = ()=&gt;{
  const functionA = ()=&gt;{/*do sth*/}
  const functionB = ()=&gt;{/*do sth*/}
  const functionC = ()=&gt;{/*send log*/}
  return new Map([
    [/^guest_[1-4]$/,functionA],
    [/^guest_5$/,functionB],
    [/^guest_.*$/,functionC],
    //...
  ])
}

const onButtonClick = (identity,status)=&gt;{
  let action = [...actions()].filter(([key,value])=&gt;(key.test(`${identity}_${status}`)))
  action.forEach(([key,value])=&gt;value.call(this))
}
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>if/else</li>
<li>switch</li>
<li>一元判断时：存到Object里</li>
<li>一元判断时：存到Map里</li>
<li>多元判断时：将condition拼接成字符串存到Object里</li>
<li>多元判断时：将condition拼接成字符串存到Map里</li>
<li>多元判断时：将condition存为Object存到Map里</li>
<li>多元判断时：将condition写作正则存到Map里</li>
</ol>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/05/javasript数组常用方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/05/javasript数组常用方法/" itemprop="url">
                  javasript数组常用方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-05 10:57:40 / 修改时间：11:21:27" itemprop="dateCreated datePublished" datetime="2018-11-05T10:57:40+08:00">2018-11-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="改变原数组"><a href="#改变原数组" class="headerlink" title="改变原数组"></a>改变原数组</h2><h3 id="移除数组末尾最后一项-pop"><a href="#移除数组末尾最后一项-pop" class="headerlink" title="移除数组末尾最后一项.pop()"></a>移除数组末尾最后一项.pop()</h3><ul>
<li>返回删除的元素</li>
<li><p>如果你在一个空数组上调用 pop()，它返回 undefined</p>
<pre><code> let word = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];  
let newArr = word.pop();  
console.log(word);      //[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]  
console.log(newArr);    //d  

let nullArr = [];  
console.log(nullArr.pop()); //undefined  
</code></pre></li>
</ul>
<h3 id="在数组末尾添加一个或多个元素-push"><a href="#在数组末尾添加一个或多个元素-push" class="headerlink" title="在数组末尾添加一个或多个元素.push()"></a>在数组末尾添加一个或多个元素.push()</h3><ul>
<li><p>返回修改后数组长度</p>
<pre><code>let word = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];  
let newArr = word.push(&apos;e&apos;,&apos;f&apos;);  
console.log(word);      //[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;]  
console.log(newArr);    //6
</code></pre></li>
</ul>
<h3 id="移除数组第一项-shift"><a href="#移除数组第一项-shift" class="headerlink" title="移除数组第一项.shift()"></a>移除数组第一项.shift()</h3><ul>
<li><p>返回移除的元素</p>
<pre><code>let word = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];  
let newArr = word.shift();  
console.log(word);      //[&apos;b&apos;, &apos;c&apos;, &apos;d&apos;]  
console.log(newArr);    //a 
</code></pre></li>
</ul>
<h3 id="在数组头部添加一个或多个元素-unshift"><a href="#在数组头部添加一个或多个元素-unshift" class="headerlink" title="在数组头部添加一个或多个元素.unshift()"></a>在数组头部添加一个或多个元素.unshift()</h3><ul>
<li><p>返回修改后数组长度</p>
<pre><code> let word = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];  
let newArr = word.unshift(&apos;11&apos;,&apos;22&apos;);  
console.log(word);      //[&apos;11&apos;, &apos;22&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]  
console.log(newArr);    //6 
</code></pre></li>
</ul>
<h3 id="对数组元素排序-sort"><a href="#对数组元素排序-sort" class="headerlink" title="对数组元素排序.sort()"></a>对数组元素排序.sort()</h3><ul>
<li>返回排序后的数组</li>
<li><p>默认排序顺序是根据字符串Unicode码点</p>
<pre><code>let fruit = [&apos;cherries&apos;, &apos;apples&apos;, &apos;bananas&apos;];  
console.log(fruit.sort());       // [&apos;apples&apos;, &apos;bananas&apos;, &apos;cherries&apos;]  

let scores = [1, 10, 21, 2];   
console.log(scores.sort());  
// [1, 10, 2, 21]  
// 注意10在2之前,  
// 因为在 Unicode 指针顺序中&quot;10&quot;在&quot;2&quot;之前  

let things = [&apos;word&apos;, &apos;Word&apos;, &apos;1 Word&apos;, &apos;2 Words&apos;];  
console.log(things.sort());   
// [&apos;1 Word&apos;, &apos;2 Words&apos;, &apos;Word&apos;, &apos;word&apos;]  
// 在Unicode中, 数字在大写字母之前,  
// 大写字母在小写字母之前.  

function compare(a, b) {  
    if(a &lt; b) {  
        return -1;  
    }else if(a &gt; b) {  
        return 1;  
    }else {  
        return 0;  
    }  
}  
let num = [1, 10, 21, 2];  
console.log(num.sort(compare)); //[1, 2, 10, 21]
</code></pre></li>
</ul>
<h3 id="颠倒数组元素-reverse"><a href="#颠倒数组元素-reverse" class="headerlink" title="颠倒数组元素.reverse()"></a>颠倒数组元素.reverse()</h3><ul>
<li>返回排序后的数组</li>
<li><p>默认排序顺序是根据字符串Unicode码点</p>
<pre><code>let word = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];  
let newArr = word.reverse();  
console.log(word);      //[&quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]  
console.log(newArr);    //[&quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;] 
</code></pre></li>
</ul>
<h3 id="删除或插入元素-splice"><a href="#删除或插入元素-splice" class="headerlink" title="删除或插入元素.splice()"></a>删除或插入元素.splice()</h3><ul>
<li>返回数组删除的项</li>
<li><p>没有删除的项，返回空数组 </p>
<pre><code>var word = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];  
//删除,前闭后开  
var newArr = word.splice(0,2);  
console.log(word);      //[&quot;c&quot;, &quot;d&quot;]  
console.log(newArr);    //[&quot;a&quot;, &quot;b&quot;]  

//插入,当前数组索引1处插入hello  
var newArr = word.splice(1,0,&apos;hello&apos;);  
console.log(word);      //[&quot;c&quot;, &quot;hello&quot;, &quot;d&quot;]  
console.log(newArr);    //[]  

//替换  
var newArr = word.splice(1,1,&apos;world&apos;);  
console.log(word);      //[&quot;c&quot;, &quot;world&quot;, &quot;d&quot;]  
console.log(newArr);    //[&quot;hello&quot;] 
</code></pre></li>
</ul>
<h2 id="不会改变原数组"><a href="#不会改变原数组" class="headerlink" title="不会改变原数组"></a>不会改变原数组</h2><h3 id="合并两个或多个数组-concat"><a href="#合并两个或多个数组-concat" class="headerlink" title="合并两个或多个数组.concat()"></a>合并两个或多个数组.concat()</h3><ul>
<li><p>返回新数组</p>
<pre><code>let word = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];  
let word2 = [&apos;hello&apos;,&apos;world&apos;];  
let newArr = word.concat(word2);  
console.log(word);      //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]  
console.log(newArr);    //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;hello&quot;, &quot;world&quot;] 
</code></pre></li>
</ul>
<h3 id="将数组所有元素连接成一个字符串-join"><a href="#将数组所有元素连接成一个字符串-join" class="headerlink" title="将数组所有元素连接成一个字符串.join()"></a>将数组所有元素连接成一个字符串.join()</h3><ul>
<li><p>返回连接后的字符串</p>
<pre><code> let word = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];  
let newArr = word.join(&apos;---&apos;);  
console.log(word);      //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]  
console.log(newArr);    //a---b---c---d  
</code></pre></li>
</ul>
<h3 id="截取数组元素到新数组中-slice"><a href="#截取数组元素到新数组中-slice" class="headerlink" title="截取数组元素到新数组中.slice()"></a>截取数组元素到新数组中.slice()</h3><ul>
<li><p>返回新数组</p>
<pre><code>let word = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];  
//原数组索引为1开始截取后面所有元素  
let newArr = word.slice(1);  
console.log(word);      //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]  
console.log(newArr);    //[&quot;b&quot;, &quot;c&quot;, &quot;d&quot;]  

//截取原数组索引为1到3之间的元素，前闭后开  
let newArr2 = word.slice(1,3);  
console.log(word);      //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]  
console.log(newArr2);    //[&quot;b&quot;, &quot;c&quot;]  

//截取原数组倒数第三个元素与倒数第一个元素之间的元素，前闭后开  
let newArr3 = word.slice(-3,-1);  
console.log(word);      //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]  
console.log(newArr3);    //[[&quot;b&quot;, &quot;c&quot;]  
</code></pre></li>
</ul>
<h3 id="获取查询元素第一次出现的索引-indexOf"><a href="#获取查询元素第一次出现的索引-indexOf" class="headerlink" title="获取查询元素第一次出现的索引.indexOf()"></a>获取查询元素第一次出现的索引.indexOf()</h3><ul>
<li><p>找不到查询元素,则返回-1</p>
<pre><code>let word = [&apos;a&apos;, &apos;b&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];  
let index = word.indexOf(&apos;b&apos;);      //1,第一次出现b的索引值  
let index2 = word.indexOf(&apos;hello&apos;); //-1  
console.log(index);  
console.log(index2);  
</code></pre></li>
</ul>
<h3 id="获取查询元素最后一次出现的索引-lastIndexOf"><a href="#获取查询元素最后一次出现的索引-lastIndexOf" class="headerlink" title="获取查询元素最后一次出现的索引.lastIndexOf()"></a>获取查询元素最后一次出现的索引.lastIndexOf()</h3><ul>
<li><p>找不到查询元素,则返回-1</p>
<pre><code>let word = [&apos;a&apos;, &apos;b&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];  
let index = word.lastIndexOf(&apos;b&apos;);      //2,最后一个b的索引值为2  
let index2 = word.lastIndexOf(&apos;hello&apos;); //-1  
console.log(index);  
console.log(index2);  
</code></pre></li>
</ul>
<h3 id="toString-返回由数组每个元素的字符串形式拼接而成的以逗号分隔的字符串"><a href="#toString-返回由数组每个元素的字符串形式拼接而成的以逗号分隔的字符串" class="headerlink" title=".toString()返回由数组每个元素的字符串形式拼接而成的以逗号分隔的字符串"></a>.toString()返回由数组每个元素的字符串形式拼接而成的以逗号分隔的字符串</h3><pre><code>let word = [&apos;a&apos;, &apos;b&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];  
let str = word.toString();      //a,b,b,c,d  
console.log(str);  
</code></pre><h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p>每个方法接受含有三个参数的函数，三个参数为：数组中的项，元素索引，数组本身</p>
<pre><code>1.every()，数组所有元素都满足要求则返回true，否则返回false
2.some()，只要有满足要求的就返回true
3.filter()，返回过滤后的结果数组
4.map()，返回在函数中处理过的数组
5.forEach()，遍历整个数组
</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>var number = [1,2,3,4,5,6,7,8];  
var res = number.every(function(item, index, array) {  
    return (item &gt; 2);  
})  
console.log(res);   //false  

var res = number.some(function(item, index, array) {  
    return (item &gt; 2);  
})  
console.log(res);   //true  

var res = number.filter(function(item, index, array) {  
    return (item &gt; 2);  
})  
console.log(res);   //[3, 4, 5, 6, 7, 8]  

var res = number.map(function(item, index, array) {  
    return (item * 2);  
})  
console.log(res);   //[2, 4, 6, 8, 10, 12, 14, 16]  

var res = number.forEach(function(item, index, array) {  
    //执行某些操作 
})  
</code></pre><h2 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h2><p>迭代数组所有项，构建最终返回值，每个方法接受两个参数：调用的函数和作为归并基础的初始值。函数接受4个参数：前一个值，当前值，项索引，数组本身。函数返回的值都会作为第一个参数自动传给下一项，第一次迭代从数组第二项开始，当前值为数组第二项</p>
<pre><code>1.reduce()，从数组第一项开始遍历到最后
2.reduceRight()，从数组最后一项开始遍历到第一项
</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><pre><code> /* 
    开始执行回调函数cur为2，prev为1， 
    第二次执行回调函数，在之前的基础上加1 
    函数返回的值都会作为一个参数传给下一项， 
    最后执行函数时就是28+8 
*/  
var number = [1,2,3,4,5,6,7,8];  
var res = number.reduce(function(prev, cur, index, array) {  
    return prev + cur;  
})  
console.log(res);   //1+2+3+4+5+6+7+8=36  

var res = number.reduceRight(function(prev, cur, index, array) {  
    return prev + cur;  
})  
console.log(res);   //8+7+6+5+4+3+2+1=36 
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>更多数组内容可以访问MDN地址:</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map</a> </p>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/05/ES6数据方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/05/ES6数据方法/" itemprop="url">
                  ES6数据方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-05 10:42:07 / 修改时间：10:55:46" itemprop="dateCreated datePublished" datetime="2018-11-05T10:42:07+08:00">2018-11-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ES6常用数据方法总结"><a href="#ES6常用数据方法总结" class="headerlink" title="ES6常用数据方法总结"></a>ES6常用数据方法总结</h3><p>参数  index, array可以忽略</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><pre><code>map():返回一个新的Array，每个元素为调用func的结果 
filter():返回一个符合func条件的元素数组 
some():返回一个boolean，判断是否有元素是否符合func条件 
every():返回一个boolean，判断每个元素是否符合func条件 
forEach():没有返回值，只是针对每个元素调用func 
reduce():有返回值，重点是计算数组，返回一个值

1、map速度比forEach快 
2、map会返回一个新数组，不对原数组产生影响,foreach不会产生新数组， 
3、map因为返回数组所以可以链式操作，forEach不能
</code></pre><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><pre><code>let array = [1,2,3,4];
array.forEach((item, index, array) =&gt; {
　　console.log(item);
}); //1,2,3,4
</code></pre><p>备注:forEach会遍历数组, 没有返回值, 不允许在循环体内写return, 不会改变原来数组的内容.</p>
<p>备注:map 遍历数组, 会返回一个新数组, 不会改变原来数组里的内容</p>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><pre><code>let array = [1, 2, 3, 4];
let temp = array.map((item, index, array) =&gt; {
    return item * 10;
});
console.log(temp);　　//  [10, 20, 30, 40];
console.log(array);　　// [1, 2, 3, 4]
</code></pre><h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><pre><code>let array = [1, 2, 3, 4];
let temp = array.filter((item, index, array) =&gt; {
　　return item &gt;  3;
});
console.log(temp);　　// [4]
console.log(array);　　// [1, 2, 3, 4]
</code></pre><p>备注: filter 会过滤掉数组中不满足条件的元素, 把满足条件的元素放到一个新数组中, 不改变原数组</p>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><pre><code>let array = [1, 2, 3, 4];
let temp = array.reduce((x, y) =&gt; {
　　console.log(&quot;x&quot;: x);
　　console.log(&quot;y&quot;: y);
　　return x + y;
});
console.log(temp);　　// 10
console.log(array);　　// [1, 2, 3, 4]
</code></pre><p>备注:x 是上一次计算过的值, 第一次循环的时候是数组中的第1个元素<br>y 是数组中的每个元素, 第一次循环的时候是数组的第2个元素</p>
<h4 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h4><pre><code>let array = [1, 2, 3, 4];
let bo = array.every((item, index, array) =&gt; {
　　return item &gt; 2;
});
console.log(bo);　　　　// false;
</code></pre><p>备注: every遍历数组, 每一项都是true, 则返回true,只要有一个是false,就返回false</p>
<h4 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h4><p>let array = [1, 2, 3, 4];<br>let tmep = array.some((item, index, array) =&gt; {<br>　　return item &gt; 1;<br>});<br>console.log(temp);　　// true</p>
<p>备注:遍历数组的每一项, 有一个返回true, 就停止循环</p>
<h4 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h4><pre><code>let arr=[1,2,234,&apos;sdf&apos;,-2];
for(let a of arr.values()){
    console.log(a) //结果：1,2,234,sdf,-2 遍历了数组arr的值
}
</code></pre><p>备注:values，对数组项的遍历</p>
<h4 id="keys"><a href="#keys" class="headerlink" title="keys()"></a>keys()</h4><p>let arr=[1,2,234,’sdf’,-2];<br>for(let a of arr.keys()){<br>    console.log(a) //结果：0,1,2,3,4  遍历了数组arr的索引<br>}</p>
<p>备注: keys，对数组索引的遍历</p>
<h4 id="entries"><a href="#entries" class="headerlink" title="entries()"></a>entries()</h4><pre><code>let arr=[&apos;w&apos;,&apos;b&apos;];
for(let a of arr.entries()){
    console.log(a) //结果：[0,w],[1,b]
}
for(let [i,v] of arr.entries()){
    console.log(i,v) //结果：0 w,1 b
}
</code></pre><p>备注:entries，对数组键值对的遍历。</p>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="厚朴酚">
            
              <p class="site-author-name" itemprop="name">厚朴酚</p>
              <p class="site-description motion-element" itemprop="description">学习笔记</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">49</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">厚朴酚</span>

  

  
</div>



<!--
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.4.2</div>
 -->



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>

<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="厚朴酚">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="厚朴酚">
<meta property="og:description" content="学习笔记">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="厚朴酚">
<meta name="twitter:description" content="学习笔记">






  <link rel="canonical" href="http://yoursite.com/page/4/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>厚朴酚</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">厚朴酚</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">打磨技术!</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/11/async-await的应用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/11/async-await的应用/" itemprop="url">
                  async/await的应用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-11 14:01:55 / 修改时间：15:22:41" itemprop="dateCreated datePublished" datetime="2018-11-11T14:01:55+08:00">2018-11-11</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="异步策略解决方式-async-await"><a href="#异步策略解决方式-async-await" class="headerlink" title="异步策略解决方式-async/await"></a>异步策略解决方式-async/await</h3><p> ES2017 中的 async/await 特性编写出相比于 promise chain 和 callback hell 更容易阅读理解的代码。await 关键字接收一个 promise，终止代码的执行，直到 promise 状态变为 resolved 或者 rejected，这种特性能让我们的异步代码阅读起来更像是同步代码。</p>
<ul>
<li><p>初始代码</p>
<pre><code>const fetch = require(&apos;node-fetch&apos;)

function getZhihuColumn(id) {
    const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
    fetch(url)
        .then(response =&gt; response.json())
        .then(column =&gt; {
            console.log(`NAME:${column.name}`)
            console.log(`INTRO:${column.info}`)
        })
}

getZhihuColumn(&apos;feweekly&apos;)
</code></pre></li>
</ul>
<p>如何把这个代码改的更加扁平呢?</p>
<h4 id="async-await-函数"><a href="#async-await-函数" class="headerlink" title="async/await 函数"></a>async/await 函数</h4><pre><code>const fetch = require(&apos;node-fetch&apos;)

async function getZhihuColumn(id) {
    const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
    const response = await fetch(url)
    const column = await response.json()
    console.log(`NAME:${column.name}`)
    console.log(`INTRO:${column.info}`)
}

getZhihuColumn(&apos;feweekly&apos;)
</code></pre><p>定义函数的时候前缀改为async,在函数体内使用await等待数据完成</p>
<h4 id="将async函数用在promise-Chain"><a href="#将async函数用在promise-Chain" class="headerlink" title="将async函数用在promise Chain***"></a>将async函数用在promise Chain***</h4><pre><code>const fetch = require(&apos;node-fetch&apos;)

async function getZhihuColumn(id) {
    const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
    const response = await fetch(url)
    const column = await response.json()
    return column
    //上面两行可以直接写成
    //return await response.json()
}

getZhihuColumn(&apos;feweekly&apos;)
    .then(column =&gt; {
        console.log(`NAME:${column.name}`)
    console.log(`INTRO:${column.info}`)
    })
</code></pre><h4 id="将任意类型的函数转为async风格"><a href="#将任意类型的函数转为async风格" class="headerlink" title="将任意类型的函数转为async风格"></a>将任意类型的函数转为async风格</h4><pre><code>const fetch = require(&apos;node-fetch&apos;)

const getZhihuColumn= async (id) =&gt; {
    const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
    const response = await fetch(url)
    const column = await response.json()
    return column
}

//立即执行
(async()=&gt;{
    const column = await getZhihuColumn(&apos;feweekly&apos;)
    console.log(`NAME:${column.name}`)
    console.log(`INTRO:${column.info}`)
})()
</code></pre><h4 id="在class类中使用async风格"><a href="#在class类中使用async风格" class="headerlink" title="在class类中使用async风格"></a>在class类中使用async风格</h4><pre><code>class APIClient {
    async getColumn(id) {
        const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
        const response = await fetch(url)
        const column = await response.json()
        return column
    }
}

//立即执行
(async()=&gt;{
    const client = new APIClient()
    const column = await client.getColumn(&apos;feweekly&apos;)
    console.log(`NAME:${column.name}`)
    console.log(`INTRO:${column.info}`)
})()
</code></pre><h4 id="处理-async-函数中的错误"><a href="#处理-async-函数中的错误" class="headerlink" title="处理 async 函数中的错误"></a>处理 async 函数中的错误</h4><pre><code>const fetch = require(&apos;node-fetch&apos;)

async function getZhihuColumn(id) {
    const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
    const response = await fetch(url)
    if (response.status !== 200) {
        throw new Error(response.status)
    }
    return await response.json()
}

//方式一
getZhihuColumn(&apos;feweekly&apos;)
    .then(column =&gt; {
       console.log(`NAME:${column.name}`)
       console.log(`INTRO:${column.info}`)
   }).catch(err=&gt;{
       console.log(err)
   })

   //方式二

   const showColumnsInfo = async(id) =&gt; {
      try {
        const column = await getZhihuColumn(id)
        console.log(`NAME:${column.name}`)
        console.log(`INTRO:${column.info}`)
      } catch (error) {
          console.log(error)
      }
   }
   showColumnsInfo(&apos;feweek123&apos;)
</code></pre><h4 id="正确处理多个await操作的并行串行"><a href="#正确处理多个await操作的并行串行" class="headerlink" title="正确处理多个await操作的并行串行"></a>正确处理多个await操作的并行串行</h4><pre><code>const fetch = require(&apos;node-fetch&apos;)

    async function getZhihuColumn(id) {
        const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
        const response = await fetch(url)
        return await response.json()
    }

//串行
   const showColumnsInfo = async() =&gt; {
        const column = await getZhihuColumn(&apos;feweely&apos;)
        const toolingtips = await getZhihuColumn(&apos;toolingtips&apos;)
        console.log(`NAME:${column.name}`)
        console.log(`INTRO:${column.info}`)
        console.log(`NAME:${toolingtips.name}`)
        console.log(`INTRO:${toolingtips.info}`)
   }
showColumnsInfo()

//并行
const showColumnsInfo = async() =&gt; {
    const columnPromise = getZhihuColumn(&apos;feweely&apos;)
    const toolingtipsPromise = getZhihuColumn(&apos;toolingtips&apos;)
    const feweekly = await columnPromise
    const toolingtips = await toolingtipsPromise
    console.log(`NAME:${feweekly.name}`)
    console.log(`INTRO:${feweekly.info}`)
    console.log(`NAME:${toolingtips.name}`)
    console.log(`INTRO:${toolingtips.info}`)
}
</code></pre><h4 id="使用Promise-all-让多个await-操作并行"><a href="#使用Promise-all-让多个await-操作并行" class="headerlink" title="使用Promise.all()让多个await 操作并行"></a>使用Promise.all()让多个await 操作并行</h4><pre><code>const fetch = require(&apos;node-fetch&apos;)

    async function getZhihuColumn(id) {
        const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
        const response = await fetch(url)
        return await response.json()
    }


const showColumnsInfo = async() =&gt; {
        const [feweekly,toolingtips] = await Promise.all([//展开操作符
            getZhihuColumn(&apos;feweekly&apos;),
            getZhihuColumn(&apos;toolingtips&apos;)
        ])
        console.log(`$name:${feweekly.name}`)
        console.log(`$name:${feweekly.info}`)
        console.log(`$name:${toolingtips.name}`)
        console.log(`$name:${toolingtips.info}`)
   }
showColumnsInfo()
</code></pre><h4 id="在for循环中正确的使用await"><a href="#在for循环中正确的使用await" class="headerlink" title="在for循环中正确的使用await"></a>在for循环中正确的使用await</h4><pre><code>const fetch = require(&apos;node-fetch&apos;)    
    async function getZhihuColumn(id) {
        const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
        const response = await fetch(url)
        return await response.json()
    }
    /**
     * 串行
     */
const showColumnsInfo = async() =&gt; {
    const names = [&apos;feweekly&apos;,&apos;toolingtips&apos;]
    for (const name of names) {
        const column = await getZhihuColumn(name)
        console.log(`NAME:${column.name}`)
        console.log(`NAME:${column.intro}`)
    }
   }
   /*
   * 并行
   **/
  const showColumnsInfo = async() =&gt; {
    const names = [&apos;feweekly&apos;,&apos;toolingtips&apos;]
    const promise = names.map(x =&gt; getZhihuColumn(x))
    for (const name of promise) {
        const column = await getZhihuColumn(name)
        console.log(`NAME:${column.name}`)
        console.log(`NAME:${column.intro}`)
    }
   }  


showColumnsInfo()
</code></pre><h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><p>微信公众号: 前端周刊</p>
<p>作者:王仕军</p>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/10/mongoose操作mongondb数据库入门/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/10/mongoose操作mongondb数据库入门/" itemprop="url">
                  mongoose操作mongondb数据库入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-10 20:34:17" itemprop="dateCreated datePublished" datetime="2018-11-10T20:34:17+08:00">2018-11-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-11 21:38:00" itemprop="dateModified" datetime="2018-11-11T21:38:00+08:00">2018-11-11</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/node-js-mongodb/" itemprop="url" rel="index"><span itemprop="name">node.js mongodb</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="mongoose操作mongodb数据库入门"><a href="#mongoose操作mongodb数据库入门" class="headerlink" title="mongoose操作mongodb数据库入门"></a>mongoose操作mongodb数据库入门</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Mongoose是在node.js异步环境下对mongodb进行的对象模型工具.</p>
<p>特点:</p>
<ul>
<li>通过关系型数据库的思想来设计非关系型数据库</li>
<li>基于mongodb驱动,简化操作</li>
</ul>
<h4 id="mongoose的安装以及使用"><a href="#mongoose的安装以及使用" class="headerlink" title="mongoose的安装以及使用"></a>mongoose的安装以及使用</h4><ol>
<li><p>安装</p>
<pre><code>npm install mongoose --save
</code></pre></li>
<li><p>引入mongoose并连接数据库</p>
<pre><code>const mongoose = require(&apos;&apos;mongoose)

mongoose.connect(&quot;mongodb://127.0.0.1:27017/数据库名&quot;)
</code></pre></li>
<li><p>定义Schema</p>
</li>
</ol>
<p>数据库中的Schema,为数据库对象的集合.schema是mongoose里会用到的一种数据模式,可以理解为表结构的定义;每个schema会映射到mongodb中的一个collection,不具备操作数据库的能力.</p>
<pre><code>var UserSchema = mongoose.Schema({
    name:String,
    age:Number,
    status:&apos;number&apos; //这种方式也可以
})
</code></pre><ol start="4">
<li>创建数据模型</li>
</ol>
<p>定义好了Schema,接下来就是生成Model.model是由schema生成的模型,可以对数据库进行操作</p>
<ul>
<li><p>备注:mongoose.model里面可以传入两个参数,也可以传入三个参数</p>
<pre><code>mongoose.model(参数1:模型名称(首字母大写),参数2:Schema)
mongoose.model(参数1:模型名称(首字母大写),参数2:Schema,参数3:数据库集合名称)
</code></pre></li>
</ul>
<p>如果传入2个参数:这个模型会模型名称相同的复数的数据库建立连接:如通过下面方法创建模型,那么这个模型将会操作users这个集合</p>
<p>如果传入三个参数的话,模型默认操作第三个参数定义的集合名称</p>
<pre><code>var User = mongoose.model(&quot;User&quot;,UserSchema)
</code></pre><ul>
<li><p>. 查找数据</p>
<pre><code>User.find({},function(err,docs){
    if (err) {
    console.log(err)
    return
    }
    console.log(docs)
})
</code></pre></li>
<li><p>. 增加数据</p>
<pre><code>var u = new User({//实例化模型,传入增加的数据
    name:&quot;wt&quot;,
    age:&quot;20&quot;,
    status:true    
})

u.save()
</code></pre></li>
</ul>
<ul>
<li>. 修改数据</li>
</ul>
<p>User.updateOne({name:”wt”},{name:”lcd”},function(err,res){<br>    if (err) {<br>    console.log(err)<br>    return<br>}<br>    console.log(“修改数据成功”)<br>})</p>
<ul>
<li><p>. 删除数据</p>
<pre><code>User.deleteOne({_id:&quot;127f77hjk45&quot;},function(err){
    if(err){//只会删除一条数据
    console.log(err)
    return
}
    console.log(&quot;删除数据成功&quot;)
})
</code></pre></li>
<li><p>.保存成功查找</p>
</li>
</ul>
<pre><code>var u = new User({
    name:&quot;lks&quot;,
    age:20,
    status:true
})  
u.save(function(err,docs){
    if (err){
    console.log(err)
    return
}
    User.find({},function(err,docs){
    if (err) {
      //
    }
    //
})
})
</code></pre><p>通过上述我们可以看到可以和你容易操作mongodb数据库,但是这种方式在应用过程会很麻烦,后面我们会采取模块化进行来管理.</p>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/javascript私有变量/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/javascript私有变量/" itemprop="url">
                  javascript私有变量
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-09 17:26:19 / 修改时间：17:50:44" itemprop="dateCreated datePublished" datetime="2018-11-09T17:26:19+08:00">2018-11-09</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="javascript私有变量"><a href="#javascript私有变量" class="headerlink" title="javascript私有变量"></a>javascript私有变量</h3><p>在javascript中,没有访问级别的修饰符,(比如,无法声明一个私有变量),所以实现封装的唯一方式就是通过函数作用域和闭包,使用一个工厂方法来实现私有变量</p>
<pre><code>function createPerson(name){
    const privateProperties = {};
    const person = {
        setName: name =&gt; {
            if (!name) throw new Error(&apos;A person must have a name&apos;)
            privateProperties.name = name
        },
        getName:() =&gt;{
            return privateProperties.name
        }
    };
    person.setName(name)
    return person
}

let a = new createPerson(&apos;lcd&apos;)
console.log(a.getName()) //出错  Cannot read property &apos;name&apos; of undefined
a.setName(&apos;lcd&apos;) 
console.log(a.getName())
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/js-xlsx的一些操作封装/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/js-xlsx的一些操作封装/" itemprop="url">
                  js-xlsx的一些操作封装
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-09 15:55:13 / 修改时间：16:51:22" itemprop="dateCreated datePublished" datetime="2018-11-09T15:55:13+08:00">2018-11-09</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/node-js/" itemprop="url" rel="index"><span itemprop="name">node.js</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="js-xlsx的一些常用封装"><a href="#js-xlsx的一些常用封装" class="headerlink" title="js-xlsx的一些常用封装"></a>js-xlsx的一些常用封装</h3><ul>
<li><p>从excel文件中获取头，返回数组</p>
<pre><code>// get head from excel file,return array
// 从excel文件中获取头，返回数组
function get_header_row(sheet) {
    const headers = []
        /*
         sheet1[&apos;!ref&apos;]　获取工作薄的有效范围　&apos;A1:C20&apos;
         XLSX.utils.decode_range 将有效范围转为　range对象
         range: {s: {r:0, c:0}, e: {r:10, 3}}
         */
    const range = XLSX.utils.decode_range(sheet[&apos;!ref&apos;]) 
    // worksheet[&apos;!ref&apos;] 是工作表的有效范围
    let C
    /* 获取单元格值 start in the first row */
    const R = range.s.r //行 //C 列
    for (C = range.s.c; C &lt;= range.e.c; ++C) { /* walk every column in the range */
        //{c:C,r:R} 单元格地址
        var cell = sheet[XLSX.utils.encode_cell({ c: C, r: R })] /* 根据地址得到单元格的值find the cell in the first row */
        var hdr = &apos;UNKNOWN &apos; + C // &lt;-- 替换为您想要的默认值replace with your desired default
        //XLSX.utils.format_cell 生成单元格文本值
        if (cell &amp;&amp; cell.t) hdr = XLSX.utils.format_cell(cell)
        headers.push(hdr)
    }
    return headers
}
</code></pre></li>
<li><p>读取excel的表头和表数据</p>
<pre><code>/*
* 读取excel的表头和表数据
 */
export const read = (data, type) =&gt; {
    /* if type == &apos;base64&apos; must fix data first */
    // const fixedData = fixdata(data)
    // const workbook = XLSX.read(btoa(fixedData), { type: &apos;base64&apos; })
    const workbook = XLSX.read(data, { type: type });//解析数据
    const firstSheetName = workbook.SheetNames[0];//获取Sheets中第一个Sheet的名字
    const worksheet = workbook.Sheets[firstSheetName];//获取第一个Sheet的数据
    const header = get_header_row(worksheet);//获取表的第一行为表头
    const results = XLSX.utils.sheet_to_json(worksheet); //表格对象变为json数据
    return {header, results};
}
</code></pre></li>
<li><p>针对base64的数据提前处理</p>
<pre><code>// fix data,return string
function fixdata(data) {
    let o = &apos;&apos;
    let l = 0
    const w = 10240
    for (; l &lt; data.byteLength / w; ++l) o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w, l * w + w)))
    o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w)))
    return o
}
</code></pre></li>
<li><p>表格转excle</p>
<p>  export const export_table_to_excel= (id, filename) =&gt; {</p>
<pre><code>const table = document.getElementById(id);
const wb = XLSX.utils.table_to_book(table);
XLSX.writeFile(wb, filename);

/* the second way */
// const table = document.getElementById(id);
// const wb = XLSX.utils.book_new();
// const ws = XLSX.utils.table_to_sheet(table);
// XLSX.utils.book_append_sheet(wb, ws, filename);
// XLSX.writeFile(wb, filename);
</code></pre><p>  }</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/HTML5的Blob对象/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/HTML5的Blob对象/" itemprop="url">
                  HTML5的Blob对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-09 13:31:53" itemprop="dateCreated datePublished" datetime="2018-11-09T13:31:53+08:00">2018-11-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-21 16:23:06" itemprop="dateModified" datetime="2018-11-21T16:23:06+08:00">2018-11-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/HTML5/" itemprop="url" rel="index"><span itemprop="name">HTML5</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HTML的Blob对象"><a href="#HTML的Blob对象" class="headerlink" title="HTML的Blob对象"></a>HTML的Blob对象</h3><p>####前言<br>一直以来，JS都没有比较好的可以直接处理二进制的方法。而Blob的存在，允许我们可以通过JS直接操作二进制数据。</p>
<h4 id="Blob对象"><a href="#Blob对象" class="headerlink" title="Blob对象"></a>Blob对象</h4><p>一个Blob对象就是一个包含有只读原始数据的类文件对象。Blob对象中的数据并不一定得是JavaScript中的原生形式。File接口基于Blob，继承了Blob的功能,并且扩展支持了用户计算机上的本地文件。</p>
<p>Blob对象可以看做是存放二进制数据的容器，此外还可以通过Blob设置二进制数据的MIME类型.</p>
<h4 id="创建Blob"><a href="#创建Blob" class="headerlink" title="创建Blob"></a>创建Blob</h4><pre><code>var blob = new Blob(dataArr:Array&lt;any&gt;, opt:{type:string});
</code></pre><ul>
<li>dataArray：数组，包含了要添加到Blob对象中的数据，数据可以是任意多个ArrayBuffer，ArrayBufferView， Blob，或者 DOMString对象。</li>
<li><p>opt：对象，用于设置Blob对象的属性（如：MIME类型）</p>
</li>
<li><p>创建一个装填DOMString对象的Blog对象</p>
<p>  var s = “ <div>hello world!!</div> “</p>
<p>  var blob = new Blob([s],{type:”text/xml”})</p>
<p>  blob</p>
<p>  Blob(24) {size: 24, type: “text/xml”}</p>
</li>
<li><p>创建一个装填ArrayBuffer对象的Blob对象</p>
<pre><code>var abf = new ArrayBuffer(8)
var blob = new Blob([abf],{type:&quot;text/plain&quot;})
blob
Blob{size:8,type:&quot;text/plain&quot;}
</code></pre></li>
<li><p>创建一个装填ArrayBufferView对象的Blob对象(ArrayBufferView可基于ArrayBuffer创建,返回值是一个类数组),如下:创建一个8字节的ArrayBuffer,在其上创建一个每个数组元素为2字节的视图</p>
<pre><code>var abf = new ArrayBuffer(8)
var abv = new Int16Array(abf)
var blob = new Blob(abv,{type:&quot;text/plain&quot;})
blob
Blob{size:4,type:&quot;text/plain&quot;}
</code></pre></li>
<li><p>通过Blob.slice()</p>
</li>
</ul>
<p>此方法返回一个新的BLob对象,包含了原对象指定范围内的数据</p>
<pre><code>Blob.slice(start:number,end:number,contentType:string)
</code></pre><ul>
<li>start: 开始索引,默认为0</li>
<li>end: 截取结束索引(不包括end)</li>
<li><p>contentType:新的Blob的MIME类型,默认为空字符串</p>
<pre><code>var b = new Blob([&quot;zxxxffggggff&quot;],{type:&quot;text/plain&quot;})
var b2 = b.slice(0,5,&quot;text/plain&quot;)
b2
Blob{size:5,type:&quot;text/plain&quot;}
</code></pre></li>
<li><p>通过canvas.toBlob()</p>
<pre><code>var canvas = document.getElementById(&quot;canvas&quot;);
canvas.toBlob(function(blob){
    console.log(blob);
});
</code></pre></li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>前面提到，File接口基于Blob，继承了Blob的功能并进行了扩展，故我们可以像使用Blob一样使用File对象。</p>
<ul>
<li>分片上传</li>
</ul>
<p>通过Blob.slice方法，可以将大文件分片，轮循向后台提交各文件片段，即可实现文件的分片上传。</p>
<p>分片上传逻辑如下：</p>
<ul>
<li>获取要上传文件的File对象，根据chunk（每片大小）对文件进行分片</li>
<li>通过post方法轮循上传每片文件，其中url中拼接querystring用于描述当前上传的文件信息；</li>
<li>post body中存放本次要上传的二进制数据片段</li>
<li>接口每次返回offset，用于执行下次上传</li>
</ul>
<p>下面是分片上传的简单实现：</p>
<pre><code>initUpload();

//初始化上传
function initUpload() {
    var chunk = 100 * 1024;   //每片大小
    var input = document.getElementById(&quot;file&quot;);    //input file
    input.onchange = function (e) {
        var file = this.files[0];
        var query = {};
        var chunks = [];
        if (!!file) {
            var start = 0;
            //文件分片
            for (var i = 0; i &lt; Math.ceil(file.size / chunk); i++) {
                var end = start + chunk;
                chunks[i] = file.slice(start , end);
                start = end;
            }

            // 采用post方法上传文件
            // url query上拼接以下参数，用于记录上传偏移
            // post body中存放本次要上传的二进制数据
            query = {
                fileSize: file.size,
                dataSize: chunk,
                nextOffset: 0
            }

            upload(chunks, query, successPerUpload);
        }
    }
}

// 执行上传
    function upload(chunks, query, cb) {
        var queryStr = Object.getOwnPropertyNames(query).map(key =&gt; {
            return key + &quot;=&quot; + query[key];
        }).join(&quot;&amp;&quot;);
        var xhr = new XMLHttpRequest();
        xhr.open(&quot;POST&quot;, &quot;http://xxxx/opload?&quot; + queryStr);
        xhr.overrideMimeType(&quot;application/octet-stream&quot;);

        //获取post body中二进制数据
        var index = Math.floor(query.nextOffset / query.dataSize);
        getFileBinary(chunks[index], function (binary) {
            if (xhr.sendAsBinary) {
                xhr.sendAsBinary(binary);
            } else {
                xhr.send(binary);
            }

        });

        xhr.onreadystatechange = function (e) {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    var resp = JSON.parse(xhr.responseText);
                    // 接口返回nextoffset
                    // resp = {
                    //     isFinish:false,
                    //     offset:100*1024
                    // }
                    if (typeof cb === &quot;function&quot;) {
                        cb.call(this, resp, chunks, query)
                    }
                }
            }
        }
    }

    // 每片上传成功后执行
    function successPerUpload(resp, chunks, query) {
        if (resp.isFinish === true) {
            alert(&quot;上传成功&quot;);
        } else {
            //未上传完毕
            query.offset = resp.offset;
            upload(chunks, query, successPerUpload);
        }
    }

    // 获取文件二进制数据
    function getFileBinary(file, cb) {
        var reader = new FileReader();
        reader.readAsArrayBuffer(file);
        reader.onload = function (e) {
            if (typeof cb === &quot;function&quot;) {
                cb.call(this, this.result);
            }
        }
    }
</code></pre><p>以上是文件分片上传前端的简单实现，当然，此功能还可以更加完善，如后台需要对合并后的文件大小进行校验；或者前端加密文件，全部上传完毕后后端解密校验等.</p>
<ul>
<li>通过url下载文件</li>
</ul>
<p>window.URL对象可以为Blob对象生成一个网络地址，结合a标签的download属性，可以实现点击url下载文件.</p>
<pre><code>createDownload(&quot;download.txt&quot;,&quot;download file&quot;);

function createDownload(fileName, content){
    var blob = new Blob([content]);
    var link = document.createElement(&quot;a&quot;);
    link.innerHTML = fileName;
    link.download = fileName;
    link.href = URL.createObjectURL(blob);
    document.getElementsByTagName(&quot;body&quot;)[0].appendChild(link);
}
</code></pre><ul>
<li>通过url显示图片</li>
</ul>
<p>我们知道，img的src属性及background的url属性，都可以通过接收图片的网络地址或base64来显示图片，同样的，我们也可以把图片转化为Blob对象，生成URL（URL.createObjectURL(blob)），来显示图片。</p>
<p>Blob对象作为一个装填二进制数据的基本对象，其作用也仅仅是一个容器，而真正的业务功能则需要通过FileReader、URL、Canvas等对象实现</p>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/html5的FileReader对象/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/html5的FileReader对象/" itemprop="url">
                  html5的FileReader对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-09 13:16:39 / 修改时间：13:31:15" itemprop="dateCreated datePublished" datetime="2018-11-09T13:16:39+08:00">2018-11-09</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/HTML5/" itemprop="url" rel="index"><span itemprop="name">HTML5</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HTML5的FileReader对象"><a href="#HTML5的FileReader对象" class="headerlink" title="HTML5的FileReader对象"></a>HTML5的FileReader对象</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>FileReader主要用于将文件内容读入内存，通过一系列异步接口，可以在主线程中访问本地文件。</p>
<p>使用FileReader对象，web应用程序可以异步的读取存储在用户计算机上的文件(或者原始数据缓冲)内容，可以使用File对象或者Blob对象来指定所要处理的文件或数据。</p>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><pre><code>var reader = new FileReader();
</code></pre><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre><code>方法定义                               描述
abort():void                     终止文件读取操作
readAsArrayBuffer(file):void     异步按字节读取文件内容，结果用ArrayBuffer对象表示
readAsBinaryString(file):void    异步按字节读取文件内容，结果为文件的二进制串
readAsDataURL(file):void         异步读取文件内容，结果用data:url的字符串形式表示
readAsText(file,encoding):void   异步按字符读取文件内容，结果用字符串形式表示
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>事件名称                         描述
onabort               当读取操作被中止时调用
onerror               当读取操作发生错误时调用
onload                当读取操作成功完成时调用
onloadend              当读取操作完成时调用,不管是成功还是失败
onloadstart              当读取操作将要开始之前调用    
onprogress              在读取数据过程中周期性调用
</code></pre><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>FileReader通过异步的方式读取文件内容，结果均是通过事件回调获取，下面是一个读取本地txt文件内容的例子：</p>
<pre><code>var input  = document.getElementById(&quot;file&quot;); //input file
input.onchange = function(){
    var file = this.files[0];
    if(!!file){
        //读取本地文件，以gbk编码方式输出
        var reader = new FileReader();
        reader.readAsText(file,&quot;gbk&quot;);
        reader.onload = function(){
            //读取完毕后输出结果
            console.log(this.result);
        }
    }
}
</code></pre><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>在线预览本地文件</li>
</ul>
<p>img的src属性或background的url属性，可以通过被赋值为图片网络地址或base64的方式显示图片。<br>在文件上传中，我们一般会先将本地文件上传到服务器，上传成功后，由后台返回图片的网络地址再在前端显示。<br>通过FileReader的readAsDataURL方法，我们可以不经过后台，直接将本地图片显示在页面上。这样做可以减少前后端频繁的交互过程，减少服务器端无用的图片资源，代码如下：</p>
<pre><code>var input  = document.getElementById(&quot;file&quot;);   // input file
input.onchange = function(){
    var file = this.files[0];
        if(!!file){
            var reader = new FileReader();
            // 图片文件转换为base64
            reader.readAsDataURL(file);
            reader.onload = function(){
                // 显示图片
                document.getElementById(&quot;file_img&quot;).src = this.result;
        }
    }
}
</code></pre><p>对于图片上传，我们也可以先将图片转换为base64进行传输，此时由于传输的图片内容就是一段字符串，故上传接口可以当做普通post接口处理，当图片传输到后台后，可以在转换为文件实体存储。<br>当然，考虑到base64转换效率及其本身的大小，本方法还是适合于上传内容简单或所占内存较小的文件。</p>
<ul>
<li>二进制数据上传</li>
</ul>
<p>我们可以直接上传或下载二进制内容，无需像以往一样通过form标签由后端拉取二进制内容。<br>简单整理下上传逻辑：<br>1、通过input[type=”file”]标签获取本地文件File对象<br>2、通过FileReader的readAsArrayBuffer方法将File对象转换为ArrayBuffer<br>3、创建xhr对象，配置请求信息<br>4、通过xhr.sendAsBinary直接将文件的ArrayBuffer内容装填至post body后发送</p>
<pre><code>var input  = document.getElementById(&quot;file&quot;);   // input file
input.onchange = function(){
    var file = this.files[0];
        if(!!file){
            var reader = new FileReader();
            reader.readAsArrayBuffer(file);
            reader.onload = function(){
                var binary = this.result;
                upload(binary);
        }
    }
}

//文件上传
function upload(binary){
    var xhr = new XMLHttpRequest();
    xhr.open(&quot;POST&quot;, &quot;http://xxxx/opload&quot;);
    xhr.overrideMimeType(&quot;application/octet-stream&quot;);
    //直接发送二进制数据
    if(xhr.sendAsBinary){
        xhr.sendAsBinary(binary);
    }else{
        xhr.send(binary);
    }

    // 监听变化
    xhr.onreadystatechange = function(e){
        if(xhr.readyState===4){
            if(xhr.status===200){
                // 响应成功       
            }
        }
    }
}
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/vue的一些工具方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/vue的一些工具方法/" itemprop="url">
                  vue的一些工具方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-09 10:17:33 / 修改时间：17:02:47" itemprop="dateCreated datePublished" datetime="2018-11-09T10:17:33+08:00">2018-11-09</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="常常应用的到的一些方法"><a href="#常常应用的到的一些方法" class="headerlink" title="常常应用的到的一些方法"></a>常常应用的到的一些方法</h3><pre><code>  /**
 * 判断两个对象是否相等
 * @param {*} obj1 
 * @param {*} obj2 
 */
export const objEqual = (obj1, obj2) =&gt; {
    const keysArr1 = Object.keys(obj1) //获取属性名
    const keysArr2 = Object.keys(obj2)
    if (keysArr1.length !== keysArr2.length) return false
    else if (keysArr1.length === 0 &amp;&amp; keysArr2.length === 0) return true
    else return !keysArr1.some(key =&gt; obj1[key] !== obj2[key])// some有一条相同返回true,取反为false
  }


/**
 * 根据路由的params生成对象
 * * */
  export const getRouteById = id =&gt; {
    let res = {}
    if (id.includes(&apos;&amp;&apos;)) {
      res.query = getObjBySplitStr(id, &apos;&amp;&apos;)
      id = id.split(&apos;&amp;&apos;)[0]
    }
    if (id.includes(&apos;:&apos;)) {
      res.params = getObjBySplitStr(id, &apos;:&apos;)
      id = id.split(&apos;:&apos;)[0]
    }
    res.name = id
    return res
  }


 export const routeEqual = (route1, route2) =&gt; {
    const params1 = route1.params || {} //逻辑或,route1.params不为空的话就返回他,或者返回{}空对象
    const params2 = route2.params || {}
    const query1 = route1.query || {} //因为路由传参有两种方式,所以要使用两种方式获取参数
    const query2 = route2.query || {}
    return route1.name === route2.name &amp;&amp; objEqual(params1, params2) &amp;&amp; objEqual(query1, query2)
  }
</code></pre><ul>
<li>点击上传Csv文件</li>
</ul>
<pre><code>/**
 * @param {Object} file 从上传组件得到的文件对象
 * @returns {Promise} resolve参数是解析后的二维数组
 * @description 从Csv文件中解析出表格，解析成二维数组
 */
export const getArrayFromFile = (file) =&gt; {
    let nameSplit = file.name.split(&apos;.&apos;) //按照指定符号.切割文件
    let format = nameSplit[nameSplit.length - 1] //[-1]得到文件名
    return new Promise((resolve, reject) =&gt; {//返回promise可以用then来获取
      let reader = new FileReader() //h5创建读取文件
      reader.readAsText(file) // 以文本格式读取
      let arr = []
      reader.onload = function (evt) {//event事件里面有各种属性
        let data = evt.target.result // 读到的数据
        let pasteData = data.trim() 
        //正则:[]指匹配里面任何一个都可以 \n 匹配一个换行符, \u0085匹配下一行 \u2028行分割 \u2029分段符号
        // \r 回车符 \n?匹配换行0此或者一次 /g代表全局匹配  \t匹配水平制表符
        arr = pasteData.split((/[\n\u0085\u2028\u2029]|\r\n?/g)).map(row =&gt; {
          return row.split(&apos;\t&apos;)
        }).map(item =&gt; {
          return item[0].split(&apos;,&apos;)
        })
        if (format === &apos;csv&apos;) resolve(arr)
        else reject(new Error(&apos;[Format Error]:你上传的不是Csv文件&apos;))
      }
    })
  }

/**
 * @param {Array} array 表格数据二维数组
 * @returns {Object} { columns, tableData }
 * @description 从二维数组中获取表头和表格数据，将第一行作为表头，用于在iView的表格中展示数据
 */
export const getTableDataFromArray = (array) =&gt; {
  let columns = []
  let tableData = []
  if (array.length &gt; 1) {
    let titles = array.shift() //删除数组中的第一个元素（red），并返回被删除元素的值
    columns = titles.map(item =&gt; {
      return {
        title: item,
        key: item
      }
    })
    tableData = array.map(item =&gt; {
      let res = {}
      item.forEach((col, i) =&gt; {
        res[titles[i]] = col
      })
      return res
    })
  }
  return {
    columns,
    tableData
  }
}

iview Upload组件的beforeUpload应用

beforeUpload (file) {//beforeUpload得到文件对象
      getArrayFromFile(file).then(data =&gt; {
        let {columns, tableData} = getTableDataFromArray(data)
        this.columns = columns
        this.tableData = tableData
      }).catch(() =&gt; {
        this.$Notice.warning({
          title: &apos;只能上传Csv文件&apos;,
          desc: &apos;只能上传Csv文件，请重新上传&apos;
        })
      })
      return false
    }
</code></pre><ul>
<li><p>数组的交集</p>
<pre><code>/**
 * @param {Array} arr1
 * @param {Array} arr2
 * @description 得到两个数组的交集, 两个数组的元素为数值或字符串
 */
export const getIntersection = (arr1, arr2) =&gt; {
  let len = Math.min(arr1.length, arr2.length)
  let i = -1
  let res = []
  while (++i &lt; len) {
    const item = arr2[i]
    if (arr1.indexOf(item) &gt; -1) res.push(item)
  }
  return res
}
</code></pre></li>
<li><p>数组的并集</p>
<pre><code>/**
 * @param {Array} arr1
 * @param {Array} arr2
 * @description 得到两个数组的并集, 两个数组的元素为数值或字符串
 */
export const getUnion = (arr1, arr2) =&gt; {
  return Array.from(new Set([...arr1, ...arr2]))
}
</code></pre></li>
</ul>
<ul>
<li>判断数组</li>
</ul>
<pre><code>/**
 * @param {Array} target 目标数组
 * @param {Array} arr 需要查询的数组
 * @description 判断要查询的数组是否至少有一个元素包含在目标数组中
 */
export const hasOneOf = (target, arr) =&gt; {
  return target.some(_ =&gt; arr.indexOf(_) &gt; -1)
}
</code></pre><ul>
<li><p>验证</p>
<pre><code>/**
 * @param {String|Number} value 要验证的字符串或数值
 * @param {*} validList 用来验证的列表
 */
export function oneOf (value, validList) {
  for (let i = 0; i &lt; validList.length; i++) {
    if (value === validList[i]) {
      return true
    }
  }
  return false
}
</code></pre></li>
</ul>
<pre><code>/**
 * 判断一个对象是否存在key，如果传入第二个参数key，则是判断这个obj对象是否存在key这个属性
 * 如果没有传入key这个参数，则判断obj对象是否有键值对
 */
export const hasKey = (obj, key) =&gt; {
  if (key) return key in obj
  else {
    let keysArr = Object.keys(obj)
    return keysArr.length
  }
}
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/node-js模块定义模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/node-js模块定义模式/" itemprop="url">
                  node.js模块定义模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-09 08:52:42 / 修改时间：09:42:02" itemprop="dateCreated datePublished" datetime="2018-11-09T08:52:42+08:00">2018-11-09</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/node-js/" itemprop="url" rel="index"><span itemprop="name">node.js</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="模块定义模式"><a href="#模块定义模式" class="headerlink" title="模块定义模式"></a>模块定义模式</h3><p>模块除了用于加载依赖关系的机制之外,还用于定义API工具,最大限度地隐藏信息和API可用性,可扩展性和代码复用.</p>
<h4 id="命名导出"><a href="#命名导出" class="headerlink" title="命名导出"></a>命名导出</h4><p>最基本的方法,把要公开的值赋给由exports(或者module.exports)引用对象的属性.生成导出对象为一组相关功能的容器或命名空间.</p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><ul>
<li>定义模块</li>
</ul>
<pre><code>//file  logger.js
exports.info = (message) =&gt; {
    console.log(&apos;info:&apos;+message)
}

exports.verbose = (message) =&gt; {
    console.log(&apos;verbose&apos; + message)
}
</code></pre><ul>
<li>引用模块</li>
</ul>
<pre><code>const logger = require(&apos;./logger&apos;)

logger.info(&apos;this is info&apos;)

logger.verbose(&apos;this is a verbose&apos;)
</code></pre><h4 id="导出函数-–substack模式"><a href="#导出函数-–substack模式" class="headerlink" title="导出函数 –substack模式"></a>导出函数 –substack模式</h4><p>最流行的一种模块定义模式是将整个module.exports变量重新分配给一个函数,主要优点只暴露一个单一的功能,提供明确的入口点,遵守小接触面的原则,也称为substack模式</p>
<h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><ul>
<li><p>定义导出函数模块</p>
<pre><code>//logger.js
module.exports = (message) =&gt; {//默认导出的
    console.log(`info:${message}`)
}

module.exports.verbose = (message) =&gt; {
    console.log(`verbose:${message}`)
}
</code></pre></li>
<li><p>引用模块</p>
<pre><code>//file main.js

const logger = require(&apos;./module&apos;)

logger(&apos;this is info default function&apos;)

logger.verbose(&apos;this is verbose function&apos;)
</code></pre></li>
</ul>
<p>虽然只输出一个函数看上去是一种限制,实际上它是一种完美的方式,把重心放在一个模块最重要的单一功能,减低内部的可见性同时,导出函数本身的属性,node.js的模块快极大鼓励采用单一责任原则,每个模块应该对单个功能负责,该责任完全由模块封装.</p>
<h4 id="导出构造函数"><a href="#导出构造函数" class="headerlink" title="导出构造函数"></a>导出构造函数</h4><p>导出构造函数的模块是导出函数模块的特别化, 区别在于:使用该模式,允许用户使用构造函数创建新实例,还可以扩展其原型并创建新类</p>
<ul>
<li><p>定义构造函数模块</p>
<pre><code>//logger.js
function Logger(name) {
    this.name = name
}

Logger.prototype.log = function(message){
    console.log(`[${this.name}] ${message}`)
}

Logger.prototype.verbose = function(message) {
    this.log(`info:${message}`)
}

Logger.prototype.info = function(message) {
    this.log(`info:${message}`)
}

module.exports = Logger
</code></pre></li>
<li><p>引用构造函数</p>
</li>
</ul>
<pre><code>const Logger = require(&apos;./module&apos;)
const dblog = new Logger(&apos;db&apos;)

dblog.info(&apos;this info fun&apos;)

const accessLogger = new Logger(&apos;adcb&apos;)
accessLogger.verbose(&apos;this is verbose fun&apos;)
</code></pre><ul>
<li><p>ES6方式</p>
<pre><code>class Logger {
    constructor(name) {
        this.name = name
    }
    log(message) {
        console.log(`[${this.name}] [${message}]`)
    }
    info(message) {
        this.log(`info:${message}`)
    }
    verbose(message) {
        this.log(`verbose:${message}`)
    }
}

module.exports = Logger;
</code></pre></li>
</ul>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/08/javascript闭包/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/08/javascript闭包/" itemprop="url">
                  javascript闭包
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-08 14:48:42 / 修改时间：15:17:06" itemprop="dateCreated datePublished" datetime="2018-11-08T14:48:42+08:00">2018-11-08</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="学习javascript闭包"><a href="#学习javascript闭包" class="headerlink" title="学习javascript闭包"></a>学习javascript闭包</h3><h4 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h4><p>变量的作用域无非就两种:全局变量和局部变量</p>
<ul>
<li><p>函数内部可以直接读取全局变量</p>
<pre><code>var n =1;
function f1(){
    alert(n)
}
f1();//1
</code></pre></li>
<li><p>函数外部无法读取函数内的局部变量</p>
<pre><code>function f1(){
var n =1
}
alert(n) //n is not defined
</code></pre></li>
</ul>
<h4 id="外部如何读取局部变量"><a href="#外部如何读取局部变量" class="headerlink" title="外部如何读取局部变量"></a>外部如何读取局部变量</h4><ul>
<li><p>那就是在函数的内部，再定义一个函数。</p>
<pre><code>function f1(){
　　var n=999;
　　function f2(){
　　alert(n); 
　　}
　　return f2;
　　}
var result=f1();
result();//999
</code></pre></li>
</ul>
<p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，就可以在f1外部读取它的内部变量了吗！</p>
<h3 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h3><p>闭包就是能够读取其他函数内部变量的函数。<br>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。<br>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<h3 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h3><ul>
<li>一个是前面提到的可以读取函数内部的变量</li>
<li><p>另一个就是让这些变量的值始终保持在内存中。</p>
<pre><code>function f1(){

　　　　var n=999;

　　　　nAdd=function(){n+=1}

　　　　function f2(){
　　　　　　alert(n);
　　　　}

　　　　return f2;

　　}

　　var result=f1();

　　result(); // 999

　　nAdd();

　　result(); // 1000
</code></pre></li>
</ul>
<p>result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p>
<p>原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<h3 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h3><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/08/javaScript的异步编程解决方案-Promise/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/08/javaScript的异步编程解决方案-Promise/" itemprop="url">
                  javaScript的异步编程解决方案-Promise
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-08 13:27:18 / 修改时间：14:45:20" itemprop="dateCreated datePublished" datetime="2018-11-08T13:27:18+08:00">2018-11-08</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="javascript异步编程解决方案-promise"><a href="#javascript异步编程解决方案-promise" class="headerlink" title="javascript异步编程解决方案-promise"></a>javascript异步编程解决方案-promise</h2><p>主要内容根据阮一峰的书籍ES6第三版</p>
<h3 id="Promise的含义"><a href="#Promise的含义" class="headerlink" title="Promise的含义"></a>Promise的含义</h3><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6规定: Promise对象是一个构造函数,用来生成Promise示例</p>
<pre><code>const promise = new Promise(function(resolve,reject){
            //...some code
            let a = 3 + 5
            if (a) {//异步操作成功,保存结果值
                resolve(a)
            } else {
                reject(error)
            }
        })
        promise.then() //Promise {&lt;pending&gt;}
        console.log(promise.then((value)=&gt;{
            console.log(value) //8
        }))
</code></pre><p>Promise构造函数接收一个函数为参数,该函数的两个参数分别是resolve和reject.(分别是两个函数)</p>
<ul>
<li><p>resolve函数的作用: 将Promise对象的状态从”未完成”变为”成功”,既从pending变为resolved,在异步操作成功调用,并将异步操作的结果,作为参数传递出去.</p>
</li>
<li><p>reject函数的作用:将Promise对象的状态从”未完成”变为失败,既从pending变为reject,在异步操作失败的时候调用,并将异步操作报出的错误作为参数传递出去.</p>
</li>
</ul>
<p>Promise实例生成以后,可以用then方法分别指定resolved状态和rejected状态的回调函数.</p>
<pre><code>promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
</code></pre><ul>
<li>then方法可以接受两个回调函数作为参数, 第一个回调函数是Promise对象的状态变为resolved时调用, 第二回调函数是promise对象变为reject时候调用,其中,第二个函数是可选的,不一定要提供,这两个函数都接收Promise对象传出的值作为参数.</li>
</ul>
<h4 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h4><pre><code>function timeout(ms) {
            return new Promise((resolve,reject)=&gt;{
                setTimeout(resolve,ms,&apos;done&apos;)
            })
        }

        timeout(100).then((value)=&gt;{
            console.log(value) //输出done
        })
</code></pre><p>解析: timeout方法返回一个Promise实例,表示一段时间以后才会发送的结果,过了指定参数ms以后,Promise实例的状态变为resolved,就会触发then方法绑定的回调函数.</p>
<h4 id="一个promise知识点-Promise新建后会立即执行"><a href="#一个promise知识点-Promise新建后会立即执行" class="headerlink" title="一个promise知识点:Promise新建后会立即执行"></a>一个promise知识点:Promise新建后会立即执行</h4><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><pre><code>let test = new Promise(function(resolve,reject){
        console.log(&apos;Promise&apos;)
        resolve()
    })
    test.then(function(){
        console.log(&apos;resolved&apos;)
    })
    console.log(&apos;hello promise&apos;)
    //输出的顺序
    //  Promise
    //  hello promise
    //  resolved
</code></pre><p>解析: Promise新建之后立即执行,所以首先输出的是Promise,然后then方法指定的回调韩素华,将在当前脚本所有同步任务执行完才会执行,所有resolved最后输出.</p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><pre><code>function loadImageAsync(url){
        return new Promise(function(resolve,reject){
            const image = new Image()
            image.onload = function(){
                resolve(image)
            }
            image.onerror = function(){
                reject(new Error(&apos;could not load image at&apos; + url))
            }
            image.src = url
        })
    }
</code></pre><p>没给参数调用的结果</p>
<pre><code>loadImageAsync().then(function(value){
    console.log(value)
},function(error){
    console.log(error)
})
</code></pre><p>Error: could not load image atundefined<br>    at Image.image.onerror (promise.html:54)</p>
<h5 id="用Promise对象实现的-Ajax-操作的例子。"><a href="#用Promise对象实现的-Ajax-操作的例子。" class="headerlink" title="用Promise对象实现的 Ajax 操作的例子。"></a>用Promise对象实现的 Ajax 操作的例子。</h5><pre><code>const getJSON = function(url){
    const promise = new Promise(function (resolve,reject) {
        const handler = function(){
            if (this.readyState !== 4){
                return
            }
            if (this.status === 200) {
                resolve(this.response)
            } else {
                reject(new Error(this.statusText))
            }
        }
        const client = new XMLHttpRequest()
        client.open(&quot;GET&quot;,url)
        client.onreadystatechange = handler
        client.responseType = &quot;json&quot;
        client.setRequestHeader(&quot;Accept&quot;,&quot;application/json&quot;)
        client.send()
      })
      return promise
}
    getJSON(&quot;/post.json&quot;).then(function(json){
        console.log(&apos;Contents:&apos; + json)
    },function(error){
        console.error(&apos;c出错了&apos;, error)
    })
</code></pre><p>上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。</p>
<p>如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>
<pre><code>const p1 = new Promise(function (resolve, reject) {
  // ...
});

const p2 = new Promise(function (resolve, reject) {
  // ...
  resolve(p1);
})
</code></pre><p>注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。</p>
<pre><code>const p1 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; reject(new Error(&apos;fail&apos;)), 3000)
})

const p2 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; resolve(p1), 1000)
})

p2
  .then(result =&gt; console.log(result))
  .catch(error =&gt; console.log(error))
// Error: fail
</code></pre><p>上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</p>
<p>注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。</p>
<pre><code>new Promise((resolve, reject) =&gt; {
  resolve(1);
  console.log(2);
}).then(r =&gt; {
  console.log(r);
});
// 2
// 1
</code></pre><p>上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>
<p>一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。</p>
<pre><code>new Promise((resolve, reject) =&gt; {
  return resolve(1);
  // 后面的语句不会执行
  console.log(2);
})
</code></pre><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p>
<p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<pre><code>getJSON(&quot;/posts.json&quot;).then(function(json) {
  return json.post;
}).then(function(post) {
  // ...
});
</code></pre><p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>
<pre><code>getJSON(&quot;/post/1.json&quot;).then(function(post) {
  return getJSON(post.commentURL);
}).then(function funcA(comments) {
  console.log(&quot;resolved: &quot;, comments);
}, function funcB(err){
  console.log(&quot;rejected: &quot;, err);
});
</code></pre><p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。</p>
<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>
<pre><code>getJSON(&quot;/post/1.json&quot;).then(
  post =&gt; getJSON(post.commentURL)
).then(
  comments =&gt; console.log(&quot;resolved: &quot;, comments),
  err =&gt; console.log(&quot;rejected: &quot;, err)
);
</code></pre><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<pre><code>getJSON(&apos;/posts.json&apos;).then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log(&apos;发生错误！&apos;, error);
});
</code></pre><p>上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p>
<pre><code>p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))
  .catch((err) =&gt; console.log(&apos;rejected&apos;, err));

// 等同于
p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))
  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));
</code></pre><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</p>
<pre><code>getJSON(&apos;/post/1.json&apos;).then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
});
</code></pre><p>上面代码中，一共有三个 Promise 对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。</p>
<p>一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。</p>
<pre><code>// bad
promise
  .then(function(data) {
    // success
  }, function(err) {
    // error
  });

// good
promise
  .then(function(data) { //cb
    // success
  })
  .catch(function(err) {
    // error
  });
</code></pre><p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。</p>
<pre><code>Promise.resolve()
.catch(function(error) {
  console.log(&apos;oh no&apos;, error);
})
.then(function() {
  console.log(&apos;carry on&apos;);
});
// carry on
</code></pre><p>上面的代码因为没有报错，跳过了catch方法，直接执行后面的then方法。此时，要是then方法里面报错，就与前面的catch无关了。</p>
<p>一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。</p>
<h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<pre><code>promise
.then(result =&gt; {···})
.catch(error =&gt; {···})
.finally(() =&gt; {···});
</code></pre><p>上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p>
<pre><code>server.listen(port)
  .then(function () {
    // ...
  })
  .finally(server.stop);
</code></pre><p>finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<p>finally本质上是then方法的特例。</p>
<pre><code>promise
.finally(() =&gt; {
  // 语句
});

// 等同于
promise
.then(
  result =&gt; {
    // 语句
    return result;
  },
  error =&gt; {
    // 语句
    throw error;
  }
);
</code></pre><p>上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。</p>
<pre><code>Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    value  =&gt; P.resolve(callback()).then(() =&gt; value),
    reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason })
  );
};
</code></pre><p>上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。</p>
<p>从上面的实现还可以看到，finally方法总是会返回原来的值。</p>
<pre><code>// resolve 的值是 undefined
Promise.resolve(2).then(() =&gt; {}, () =&gt; {})

// resolve 的值是 2
Promise.resolve(2).finally(() =&gt; {})

// reject 的值是 undefined
Promise.reject(3).then(() =&gt; {}, () =&gt; {})

// reject 的值是 3
Promise.reject(3).finally(() =&gt; {})
</code></pre><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<pre><code>const p = Promise.all([p1, p2, p3]);
</code></pre><p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p>
<p>p的状态由p1、p2、p3决定，分成两种情况。</p>
<p>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p>
<p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>
<pre><code>// 生成一个Promise对象的数组

const promises = [2, 3, 5, 7, 11, 13].map(function (id) {
  return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;);
});

Promise.all(promises).then(function (posts) {
  // ...
}).catch(function(reason){
  // ...
});
</code></pre><p>上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。</p>
<pre><code>const databasePromise = connectDatabase();

const booksPromise = databasePromise
  .then(findAllBooks);

const userPromise = databasePromise
  .then(getCurrentUser);

Promise.all([
  booksPromise,
  userPromise
])
.then(([books, user]) =&gt; pickTopRecommentations(books, user));
</code></pre><p>上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。</p>
<p>注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</p>
<pre><code>const p1 = new Promise((resolve, reject) =&gt; {
  resolve(&apos;hello&apos;);
})
.then(result =&gt; result)
.catch(e =&gt; e);

const p2 = new Promise((resolve, reject) =&gt; {
  throw new Error(&apos;报错了&apos;);
})
.then(result =&gt; result)
.catch(e =&gt; e);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// [&quot;hello&quot;, Error: 报错了]
</code></pre><p>上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。</p>
<p>如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。</p>
<pre><code>const p1 = new Promise((resolve, reject) =&gt; {
  resolve(&apos;hello&apos;);
})
.then(result =&gt; result);

const p2 = new Promise((resolve, reject) =&gt; {
  throw new Error(&apos;报错了&apos;);
})
.then(result =&gt; result);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// Error: 报错了
</code></pre><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<pre><code>const p = Promise.race([p1, p2, p3]);
</code></pre><p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p>
<p>Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p>
<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。</p>
<pre><code>const p = Promise.race([
  fetch(&apos;/resource-that-may-take-a-while&apos;),
  new Promise(function (resolve, reject) {
    setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000)
  })
]);

p
.then(console.log)
.catch(console.error);
</code></pre><p>上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。</p>
<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p>有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用</p>
<pre><code>const jsPromise = Promise.resolve($.ajax(&apos;/whatever.json&apos;));
</code></pre><p>上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。<br>Promise.resolve等价于下面的写法。</p>
<pre><code>Promise.resolve(&apos;foo&apos;)
// 等价于
new Promise(resolve =&gt; resolve(&apos;foo&apos;))
</code></pre><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h4><p>我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。</p>
<pre><code>const preloadImage = function (path) {
  return new Promise(function (resolve, reject) {
    const image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  });
};
</code></pre><h4 id="Generator与Promise的结合"><a href="#Generator与Promise的结合" class="headerlink" title="Generator与Promise的结合"></a>Generator与Promise的结合</h4><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。</p>
<pre><code>function getFoo () {
  return new Promise(function (resolve, reject){
    resolve(&apos;foo&apos;);
  });
}

const g = function* () {
  try {
    const foo = yield getFoo();
    console.log(foo);
  } catch (e) {
    console.log(e);
  }
};

function run (generator) {
  const it = generator();

  function go(result) {
    if (result.done) return result.value;

    return result.value.then(function (value) {
      return go(it.next(value));
    }, function (error) {
      return go(it.throw(error));
    });
  }

  go(it.next());
}

run(g);
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="厚朴酚">
            
              <p class="site-author-name" itemprop="name">厚朴酚</p>
              <p class="site-description motion-element" itemprop="description">学习笔记</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">53</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">厚朴酚</span>

  

  
</div>



<!--
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.4.2</div>
 -->



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>

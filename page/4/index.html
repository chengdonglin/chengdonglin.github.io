<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="厚朴酚">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="厚朴酚">
<meta property="og:description" content="学习笔记">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="厚朴酚">
<meta name="twitter:description" content="学习笔记">






  <link rel="canonical" href="http://yoursite.com/page/4/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>厚朴酚</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">厚朴酚</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">打磨技术!</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/12/koa基于mongoose模块化实现/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/12/koa基于mongoose模块化实现/" itemprop="url">
                  在koa中应用mongoose模块化实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-12 17:25:32 / 修改时间：18:14:23" itemprop="dateCreated datePublished" datetime="2018-11-12T17:25:32+08:00">2018-11-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/koa/" itemprop="url" rel="index"><span itemprop="name">koa</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="在koa中应用mongoose模块化实现"><a href="#在koa中应用mongoose模块化实现" class="headerlink" title="在koa中应用mongoose模块化实现"></a>在koa中应用mongoose模块化实现</h3><pre><code>为了让项目拥有更好的可读性以及可管理性,那么
</code></pre><ul>
<li>数据库连接</li>
</ul>
<pre><code>//init.js

const mongoose = require(&apos;mongoose&apos;)
const db = &quot;mongodb://localhost/smile-vue&quot;
const glob = require(&apos;glob&apos;)
const {resolve} = require(&apos;path&apos;)

//一次性全部导入模型
exports.initSchemas = ()=&gt;{
    glob.sync(resolve(__dirname,&apos;./schema&apos;,&apos;**/*.js&apos;)).forEach(require)
}
exports.connect = ()=&gt;{
    //连接数据库
    mongoose.connect(db)
    let  maxConnectTimes = 0
    return new Promise((resolve,reject)=&gt;{
         //增加数据库监听事件
        mongoose.connection.on(&apos;disconnected&apos;,()=&gt;{
            console.log(&apos;***********数据库断开***********&apos;)
            if(maxConnectTimes&lt;=3){
                maxConnectTimes++
                mongoose.connect(db)
            }else{
                reject()
                throw new Error(&apos;数据库出现问题&apos;)
            }      
        })
        mongoose.connection.on(&apos;error&apos;,(err)=&gt;{
            console.log(&apos;***********数据库错误&apos;)
            if(maxConnectTimes&lt;=3){
                maxConnectTimes++
                mongoose.connect(db)
            }else{
                reject(err)
                throw new Error(&apos;数据库出现问题&apos;)
            }
        })
        //链接打开的时
        mongoose.connection.once(&apos;open&apos;,()=&gt;{
            console.log(&apos;MongoDB connected successfully&apos;)           
            resolve()
        })
    })
}
</code></pre><ul>
<li><p>shema文件夹创建模型</p>
<pre><code>//User.js
const mongoose = require(&apos;mongoose&apos;)
const Schema = mongoose.Schema
let ObjectId = Schema.Types.ObjectId
const bcrypt = require(&apos;bcrypt&apos;)
const SALT_WORK_FACTOR = 10

//创建UserShema
const userSchema = new Schema({
    UserId :{type:ObjectId},
    userName : {unique:true,type:String},
    password : String,
    createAt:{type:Date, default:Date.now()},
    lastLoginAt:{type:Date, default:Date.now()}
},{
  collection:&apos;user&apos;  
}) 
userSchema.pre(&apos;save&apos;, function(next){
    bcrypt.genSalt(SALT_WORK_FACTOR,(err,salt)=&gt;{
        if(err) return next(err)
        bcrypt.hash(this.password,salt,(err,hash)=&gt;{
            if(err) return next(err)
            this.password = hash
            next()
        })
    })
})

userSchema.methods={
    comparePassword:(_password,password)=&gt;{
        return new Promise((resolve,reject)=&gt;{
            bcrypt.compare(_password,password,(err,isMatch)=&gt;{
                if(!err) resolve(isMatch)
                else reject(err)
            })
        })
    }
}
</code></pre></li>
</ul>
<pre><code>//发布模型
mongoose.model(&apos;User&apos;,userSchema)
</code></pre><ul>
<li>服务器连接开启数据库并导入模型</li>
</ul>
<pre><code>const Koa = require(&apos;koa&apos;)
const app = new Koa()
const { connect , initSchemas } = require(&apos;./database/init.js&apos;)
const mongoose = require(&apos;mongoose&apos;)
const bodyParser = require(&apos;koa-bodyparser&apos;)
const cors = require(&apos;koa2-cors&apos;)
const Router = require(&apos;koa-router&apos;)
app.use(bodyParser())
app.use(cors())
let user = require(&apos;./appApi/user.js&apos;)
let home = require(&apos;./appApi/home.js&apos;)
let goods = require(&apos;./appApi/goods.js&apos;)

//装载所有子路由
let router = new Router()
router.use(&apos;/user&apos;,user.routes())
router.use(&apos;/home&apos;,home.routes())
router.use(&apos;/goods&apos;,goods.routes())
//egg.js

//加载路由中间件
app.use(router.routes())
app.use(router.allowedMethods())
//这个函数说明立即执行,创建数据库连接导入模型
;(async ()=&gt;{
    await connect()
    initSchemas()
})()
app.use(async(ctx)=&gt;{
    ctx.body=&apos;&lt;h1&gt;Hello Koa2&lt;/h1&gt;&apos;
})
app.listen(3000,()=&gt;{
    console.log(&apos;[Server] starting at port 3000&apos;)
})
</code></pre><ul>
<li><p>在路由中使用</p>
<pre><code>const Router = require(&apos;koa-router&apos;)
const mongoose = require(&apos;mongoose&apos;)

let router = new Router()
router.get(&apos;/&apos;,async(ctx)=&gt;{
    ctx.body=&quot;这是用户操作首页&quot;
})

router.post(&apos;/register&apos;,async(ctx)=&gt;{
    const User = mongoose.model(&apos;User&apos;)
    let newUser = new User(ctx.request.body)
    await newUser.save().then(()=&gt;{
        ctx.body={
            code:200,
            message:&apos;注册成功&apos;
        }
    }).catch(error=&gt;{
        ctx.body={
            code:500,
            message:error
        }
    })
})
router.post(&apos;/login&apos;,async(ctx)=&gt;{
    let loginUser = ctx.request.body
    console.log(loginUser)
    let userName = loginUser.userName
    let password = loginUser.password
    //引入User的model
    const User = mongoose.model(&apos;User&apos;)
    await User.findOne({userName:userName}).exec().then(async(result)=&gt;{
        console.log(result)
        if(result){
            let newUser = new User()
            await newUser.comparePassword(password,result.password)
            .then(isMatch=&gt;{
                ctx.body={code:200,message:isMatch}
            })
            .catch(error=&gt;{
                console.log(error)
                ctx.body={code:500,message:error}
            })
        }else{
            ctx.body={code:200,message:&apos;用户名不存在&apos;}
        }
    }).catch(error=&gt;{
        console.log(error)
        ctx.body={code:500,message:error}
    })
})

module.exports =router
</code></pre></li>
</ul>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/12/js-xlsx前置知识点/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/12/js-xlsx前置知识点/" itemprop="url">
                  js-xlsx前置知识点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-12 10:12:35 / 修改时间：10:46:52" itemprop="dateCreated datePublished" datetime="2018-11-12T10:12:35+08:00">2018-11-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/node-js/" itemprop="url" rel="index"><span itemprop="name">node.js</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="js-xlsx"><a href="#js-xlsx" class="headerlink" title="js-xlsx"></a>js-xlsx</h3><ul>
<li><p>安装</p>
<pre><code>npm install xlsx
</code></pre></li>
</ul>
<h4 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h4><ul>
<li>workbook</li>
</ul>
<p>指的是整份Excel文档</p>
<ul>
<li>worksheet</li>
</ul>
<p>指Excel文档的表,一份Excel文档包含多张表,每一章表对应的就是worksheet对象</p>
<ul>
<li>cell对象</li>
</ul>
<p>指worksheet的单元格</p>
<ul>
<li><p>具体如下</p>
<pre><code>// workbook
{
    SheetNames: [&apos;sheet1&apos;, &apos;sheet2&apos;],
    Sheets: {
        // worksheet
        &apos;sheet1&apos;: {
            // cell
            &apos;A1&apos;: { ... },
            // cell
            &apos;A2&apos;: { ... },
            ...
        },
        // worksheet
        &apos;sheet2&apos;: {
            // cell
            &apos;A1&apos;: { ... },
            // cell
            &apos;A2&apos;: { ... },
            ...
        }
    }
}
</code></pre></li>
</ul>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ol>
<li>用 XLSX.read 读取获取到的 Excel 数据，返回 workbook</li>
<li>用 XLSX.readFile 打开 Excel 文件，返回 workbook</li>
<li>用 workbook.SheetNames 获取表名</li>
<li>用 workbook.Sheets[xxx] 通过表名获取表格</li>
<li>用 worksheet[address]操作单元格</li>
<li>用XLSX.utils.sheet_to_json针对单个表获取表格数据转换为json格式</li>
<li>用XLSX.writeFile(wb, ‘output.xlsx’)生成新的 Excel 文件</li>
</ol>
<h4 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h4><ul>
<li><p>读取Excel文件</p>
<pre><code>workbook ＝ XLSX.read(excelData, {type: &apos;base64&apos;});
workbook ＝ XLSX.writeFile(&apos;someExcel.xlsx&apos;, opts);
</code></pre></li>
<li><p>获取Excel文件的表</p>
<pre><code>// 获取 Excel 中所有表名
var sheetNames = workbook.SheetNames; // 返回 [&apos;sheet1&apos;, &apos;sheet2&apos;,……]
// 根据表名获取对应某张表
var worksheet = workbook.Sheets[sheetNames[0]];
</code></pre></li>
<li><p>worksheet[address]操作表格,以!开头的key是特殊的字段</p>
<pre><code>// 获取 A1 单元格对象
let a1 = worksheet[&apos;A1&apos;]; // 返回 { v: &apos;hello&apos;, t: &apos;s&apos;, ... }
// 获取 A1 中的值
a1.v // 返回 &apos;hello&apos;
// 获取表的有效范围
worksheet[&apos;!ref&apos;] // 返回 &apos;A1:B20&apos;
worksheet[&apos;!range&apos;] // 返回 range 对象，{ s: { r: 0, c: 0}, e: { r: 100, c: 2 } }
// 获取合并过的单元格
worksheet[&apos;!merges&apos;] // 返回一个包含 range 对象的列表，[ {s: { r: 0, c: 0 }, c: { r: 2, c: 1 } } ]
</code></pre></li>
<li><p>获取Excel 文件的表转换为json数据</p>
</li>
</ul>
<pre><code>XLSX.utils.sheet_to_json(worksheet)  //针对单个表，返回序列化json数据
</code></pre><ul>
<li><p>生成新的Excel文件</p>
<pre><code>//服务端通过XLSX.writeFile
XLSX = require(&quot;xlsx&quot;);
XLSX.writeFile(wb, &apos;output.xlsx&apos;)   
//客服端，只能通过XLSX.write(wb, write_opts) 写入 表格数据，借助FileSaver生成，且只支持在高版本浏览器。
var wopts = { bookType:&apos;xlsx&apos;, bookSST:false, type:&apos;binary&apos; };
var wbout = XLSX.write(wb,wopts);
function s2ab(s) {
  var buf = new ArrayBuffer(s.length);
  var view = new Uint8Array(buf);
  for (var i=0; i!=s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xFF;
  return buf;
}
/* the saveAs call downloads a file on the local machine */
saveAs(new Blob([s2ab(wbout)],{type:&quot;&quot;}), &quot;test.xlsx&quot;)
</code></pre></li>
</ul>
<h4 id="js-xlsx实战"><a href="#js-xlsx实战" class="headerlink" title="js-xlsx实战"></a>js-xlsx实战</h4><ul>
<li><p>解析Excel生成JSON</p>
<pre><code>function to_json(workbook) {
    var result = {};
    // 获取 Excel 中所有表名
    var sheetNames = workbook.SheetNames; // 返回 [&apos;sheet1&apos;, &apos;sheet2&apos;]
    workbook.SheetNames.forEach(function(sheetName) {
        var worksheet = workbook.Sheets[sheetName];
        result[sheetName] = XLSX.utils.sheet_to_json(worksheet);
    });    
    console.log(&quot;打印表信息&quot;,JSON.stringify(result, 2, 2));  //显示格式{&quot;表1&quot;:[],&quot;表2&quot;:[]}
    return result;
}
</code></pre></li>
<li><p>导出表格</p>
</li>
<li></li>
</ul>
<ol>
<li><p>构建特定的数据结构,通过new Blob</p>
<pre><code>// workbook
{
    SheetNames: [&apos;mySheet&apos;],
    Sheets: {
        &apos;mySheet&apos;: {
            &apos;!ref&apos;: &apos;A1:E4&apos;, // 必须要有这个范围才能输出，否则导出的 excel 会是一个空表
            A1: { v: &apos;id&apos; },
            ...
        }
    }
}
</code></pre></li>
<li><p>调用XLSX.write,借助FIleSaver中的new Blob生成</p>
<pre><code>var _headers = [&apos;id&apos;, &apos;name&apos;, &apos;age&apos;, &apos;country&apos;, &apos;remark&apos;]
var _data = [ { id: &apos;1&apos;,
                name: &apos;test1&apos;,
                age: &apos;30&apos;,
                country: &apos;China&apos;,
                remark: &apos;hello&apos; },
              { id: &apos;2&apos;,
                name: &apos;test2&apos;,
                age: &apos;20&apos;,
                country: &apos;America&apos;,
                remark: &apos;world&apos; },
              { id: &apos;3&apos;,
                name: &apos;test3&apos;,
                age: &apos;18&apos;,
                country: &apos;Unkonw&apos;,
                remark: &apos;???&apos; } ];
var headers = _headers
                // 为 _headers 添加对应的单元格位置
                // [ { v: &apos;id&apos;, position: &apos;A1&apos; },
                //   { v: &apos;name&apos;, position: &apos;B1&apos; },
                //   { v: &apos;age&apos;, position: &apos;C1&apos; },
                //   { v: &apos;country&apos;, position: &apos;D1&apos; },
                //   { v: &apos;remark&apos;, position: &apos;E1&apos; } ]
                .map((v, i) =&gt; Object.assign({}, {v: v, position: String.fromCharCode(65+i) + 1 }))
                // 转换成 worksheet 需要的结构
                // { A1: { v: &apos;id&apos; },
                //   B1: { v: &apos;name&apos; },
                //   C1: { v: &apos;age&apos; },
                //   D1: { v: &apos;country&apos; },
                //   E1: { v: &apos;remark&apos; } }
                .reduce((prev, next) =&gt; Object.assign({}, prev, {[next.position]: {v: next.v}}), {});
var data = _data
              // 匹配 headers 的位置，生成对应的单元格数据
              // [ [ { v: &apos;1&apos;, position: &apos;A2&apos; },
              //     { v: &apos;test1&apos;, position: &apos;B2&apos; },
              //     { v: &apos;30&apos;, position: &apos;C2&apos; },
              //     { v: &apos;China&apos;, position: &apos;D2&apos; },
              //     { v: &apos;hello&apos;, position: &apos;E2&apos; } ],
              //   [ { v: &apos;2&apos;, position: &apos;A3&apos; },
              //     { v: &apos;test2&apos;, position: &apos;B3&apos; },
              //     { v: &apos;20&apos;, position: &apos;C3&apos; },
              //     { v: &apos;America&apos;, position: &apos;D3&apos; },
              //     { v: &apos;world&apos;, position: &apos;E3&apos; } ],
              //   [ { v: &apos;3&apos;, position: &apos;A4&apos; },
              //     { v: &apos;test3&apos;, position: &apos;B4&apos; },
              //     { v: &apos;18&apos;, position: &apos;C4&apos; },
              //     { v: &apos;Unkonw&apos;, position: &apos;D4&apos; },
              //     { v: &apos;???&apos;, position: &apos;E4&apos; } ] ]
              .map((v, i) =&gt; _headers.map((k, j) =&gt; Object.assign({}, { v: v[k], position: String.fromCharCode(65+j) + (i+2) })))
              // 对刚才的结果进行降维处理（二维数组变成一维数组）
              // [ { v: &apos;1&apos;, position: &apos;A2&apos; },
              //   { v: &apos;test1&apos;, position: &apos;B2&apos; },
              //   { v: &apos;30&apos;, position: &apos;C2&apos; },
              //   { v: &apos;China&apos;, position: &apos;D2&apos; },
              //   { v: &apos;hello&apos;, position: &apos;E2&apos; },
              //   { v: &apos;2&apos;, position: &apos;A3&apos; },
              //   { v: &apos;test2&apos;, position: &apos;B3&apos; },
              //   { v: &apos;20&apos;, position: &apos;C3&apos; },
              //   { v: &apos;America&apos;, position: &apos;D3&apos; },
              //   { v: &apos;world&apos;, position: &apos;E3&apos; },
              //   { v: &apos;3&apos;, position: &apos;A4&apos; },
              //   { v: &apos;test3&apos;, position: &apos;B4&apos; },
              //   { v: &apos;18&apos;, position: &apos;C4&apos; },
              //   { v: &apos;Unkonw&apos;, position: &apos;D4&apos; },
              //   { v: &apos;???&apos;, position: &apos;E4&apos; } ]
              .reduce((prev, next) =&gt; prev.concat(next))
              // 转换成 worksheet 需要的结构
              //   { A2: { v: &apos;1&apos; },
              //     B2: { v: &apos;test1&apos; },
              //     C2: { v: &apos;30&apos; },
              //     D2: { v: &apos;China&apos; },
              //     E2: { v: &apos;hello&apos; },
              //     A3: { v: &apos;2&apos; },
              //     B3: { v: &apos;test2&apos; },
              //     C3: { v: &apos;20&apos; },
              //     D3: { v: &apos;America&apos; },
              //     E3: { v: &apos;world&apos; },
              //     A4: { v: &apos;3&apos; },
              //     B4: { v: &apos;test3&apos; },
              //     C4: { v: &apos;18&apos; },
              //     D4: { v: &apos;Unkonw&apos; },
              //     E4: { v: &apos;???&apos; } }
              .reduce((prev, next) =&gt; Object.assign({}, prev, {[next.position]: {v: next.v}}), {});
// 合并 headers 和 data
var output = Object.assign({}, headers, data);
// 获取所有单元格的位置
var outputPos = Object.keys(output);
// 计算出范围
var ref = outputPos[0] + &apos;:&apos; + outputPos[outputPos.length - 1];
// 构建 workbook 对象
var wb = {
    SheetNames: [&apos;mySheet&apos;],
    Sheets: {
        &apos;mySheet&apos;: Object.assign({}, output, { &apos;!ref&apos;: ref })
    }
};
// 导出 Excel
//XLSX.writeFile(wb, &apos;output.xlsx&apos;);
var wopts = { bookType:&apos;xlsx&apos;, bookSST:false, type:&apos;binary&apos; };
var wbout = XLSX.write(wb,wopts);
function s2ab(s) {
  var buf = new ArrayBuffer(s.length);
  var view = new Uint8Array(buf);
  for (var i=0; i!=s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xFF;
  return buf;
}
/* the saveAs call downloads a file on the local machine */
saveAs(new Blob([s2ab(wbout)],{type:&quot;&quot;}), &quot;test.xlsx&quot;)
</code></pre></li>
</ol>
<ul>
<li>利用Excel-export生成Excel文件</li>
<li><pre><code>var express = require(&apos;express&apos;);
var nodeExcel = require(&apos;excel-export&apos;);
var app = express();
app.get(&apos;/Excel&apos;, function(req, res){
    var conf ={};
    conf.stylesXmlFile = &quot;styles.xml&quot;;
    conf.name = &quot;mysheet&quot;;
    conf.cols = [{
        caption:&apos;string&apos;,
        type:&apos;string&apos;,
        beforeCellWrite:function(row, cellData){
             return cellData.toUpperCase();
        },
        width:28.7109375
    },{
        caption:&apos;date&apos;,
        type:&apos;date&apos;,
        beforeCellWrite:function(){
            var originDate = new Date(Date.UTC(1899,11,30));
            return function(row, cellData, eOpt){
                if (eOpt.rowNum%2){
                    eOpt.styleIndex = 1;
                }  
                else{
                    eOpt.styleIndex = 2;
                }
                if (cellData === null){
                  eOpt.cellType = &apos;string&apos;;
                  return &apos;N/A&apos;;
                } else
                  return (cellData - originDate) / (24 * 60 * 60 * 1000);
            } 
        }()
    },{
        caption:&apos;bool&apos;,
        type:&apos;bool&apos;
    },{
        caption:&apos;number&apos;,
         type:&apos;number&apos;              
    }];
    conf.rows = [
        [&apos;pi&apos;, new Date(Date.UTC(2013, 4, 1)), true, 3.14],
        [&quot;e&quot;, new Date(2012, 4, 1), false, 2.7182],
        [&quot;M&amp;M&lt;&gt;&apos;&quot;, new Date(Date.UTC(2013, 6, 9)), false, 1.61803],
        [&quot;null date&quot;, null, true, 1.414]  
    ];
    var result = nodeExcel.execute(conf);
    res.setHeader(&apos;Content-Type&apos;, &apos;application/vnd.openxmlformats&apos;);
    res.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + &quot;Report.xlsx&quot;);
    res.end(result, &apos;binary&apos;);
});
app.listen(3000);
console.log(&apos;Listening on port 3000&apos;);
</code></pre></li>
</ul>
<p>分析生成excel流程：</p>
<ol>
<li>配置excel文件名conf.name</li>
<li>设置表caption，每列单元格数据类型，宽度</li>
<li>填充表中每行数据conf.rows，nodeExcel.execute生成数据结构，设置头部，拼接生成表</li>
</ol>
<p>来源: 凹凸实验室（<a href="https://aotu.io/notes/2016/04/07/node-excel/）" target="_blank" rel="noopener">https://aotu.io/notes/2016/04/07/node-excel/）</a></p>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/11/mongoose模块化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/11/mongoose模块化/" itemprop="url">
                  mongoose模块化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-11 21:25:12 / 修改时间：22:04:31" itemprop="dateCreated datePublished" datetime="2018-11-11T21:25:12+08:00">2018-11-11</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/node-js-mongodb/" itemprop="url" rel="index"><span itemprop="name">node.js mongodb</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="mongoose模块化"><a href="#mongoose模块化" class="headerlink" title="mongoose模块化"></a>mongoose模块化</h3><p>为了便于管理,代码复用的原则</p>
<p>connect连接的时候mongodb4.x版本会有deprecationwaring警告,为了消除这个,可以在第二个参数传入{userNewParser:true},同时为了监听连接的情况,可以写个回调.</p>
<ul>
<li><p>mongoose连接的代码</p>
<pre><code>var mongoose = require(&apos;mongoose&apos;)

mongoose.connect(&apos;mongodb数据库地址&apos;,{userNewParser:true},function{
    if (err) {
    console.log(&quot;数据库连接失败&quot;)
    } else {
    console.log(&quot;数据库连接成功&quot;)
    }
})
</code></pre></li>
</ul>
<h4 id="mongoose-默认参数"><a href="#mongoose-默认参数" class="headerlink" title="mongoose 默认参数"></a>mongoose 默认参数</h4><p>增加数据的时候,如果不传入数据会使用默认配置的数据</p>
<ul>
<li><p>定义数据表映射  : 字段必须和数据库保持一致</p>
<p>  var UserSchema = mongoose.Schema({</p>
<pre><code>name:String,
age:Number,
status:{
    type:Number,
    default:1 //这就是默认参数
}    
</code></pre><p>})</p>
</li>
</ul>
<p>var UserModel = mongoose.model(“User”,UserSchema,’user’)</p>
<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><ul>
<li>数据库连接模块</li>
</ul>
<p>//连接数据库</p>
<pre><code>var mongoose=require(&apos;mongoose&apos;);

//useNewUrlParser这个属性会在url里识别验证用户所需的db,未升级前是不需要指定的,升级到一定要指定。

mongoose.connect(&apos;mongodb://127.0.0.1:27017/xxx&apos;,{ useNewUrlParser: true },function(err){
        if(err){

            console.log(err);
            return;
        }
        console.log(&apos;数据库连接成功&apos;)
});

module.exports=mongoose;
</code></pre><ul>
<li><p>模型定义</p>
<pre><code>var mongoose=require(&apos;./db.js&apos;);
</code></pre></li>
</ul>
<pre><code>var UserSchema=mongoose.Schema({
    name:String,
    age:Number,
    status:{
        type:Number,
        default:1   
    }
})

module.exports=mongoose.model(&apos;User&apos;,UserSchema,&apos;user&apos;)
</code></pre><ul>
<li><p>表的使用</p>
<p>  var UserModel=require(‘./model/user.js’);<br>  var user=new UserModel({</p>
<pre><code>name:&quot;李四666&quot;,
age:40
</code></pre><p>  })<br>  user.save(function(err){</p>
<pre><code>if(err){
    console.log(err);
    return;
}

//获取user表的数据
UserModel.find({},function(err,docs){
    if(err){ 
        console.log(err);
        return;
    }
    console.log(docs);
})
</code></pre><p>  })</p>
</li>
<li><p>性能测试</p>
<pre><code>console.time(&apos;user&apos;);
var UserModel=require(&apos;./model/user.js&apos;);
console.timeEnd(&apos;user&apos;);
console.time(&apos;news&apos;);
var NewsModel=require(&apos;./model/news.js&apos;);
console.timeEnd(&apos;news&apos;);
</code></pre></li>
</ul>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/11/async-await的应用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/11/async-await的应用/" itemprop="url">
                  async/await的应用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-11 14:01:55 / 修改时间：15:22:41" itemprop="dateCreated datePublished" datetime="2018-11-11T14:01:55+08:00">2018-11-11</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="异步策略解决方式-async-await"><a href="#异步策略解决方式-async-await" class="headerlink" title="异步策略解决方式-async/await"></a>异步策略解决方式-async/await</h3><p> ES2017 中的 async/await 特性编写出相比于 promise chain 和 callback hell 更容易阅读理解的代码。await 关键字接收一个 promise，终止代码的执行，直到 promise 状态变为 resolved 或者 rejected，这种特性能让我们的异步代码阅读起来更像是同步代码。</p>
<ul>
<li><p>初始代码</p>
<pre><code>const fetch = require(&apos;node-fetch&apos;)

function getZhihuColumn(id) {
    const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
    fetch(url)
        .then(response =&gt; response.json())
        .then(column =&gt; {
            console.log(`NAME:${column.name}`)
            console.log(`INTRO:${column.info}`)
        })
}

getZhihuColumn(&apos;feweekly&apos;)
</code></pre></li>
</ul>
<p>如何把这个代码改的更加扁平呢?</p>
<h4 id="async-await-函数"><a href="#async-await-函数" class="headerlink" title="async/await 函数"></a>async/await 函数</h4><pre><code>const fetch = require(&apos;node-fetch&apos;)

async function getZhihuColumn(id) {
    const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
    const response = await fetch(url)
    const column = await response.json()
    console.log(`NAME:${column.name}`)
    console.log(`INTRO:${column.info}`)
}

getZhihuColumn(&apos;feweekly&apos;)
</code></pre><p>定义函数的时候前缀改为async,在函数体内使用await等待数据完成</p>
<h4 id="将async函数用在promise-Chain"><a href="#将async函数用在promise-Chain" class="headerlink" title="将async函数用在promise Chain***"></a>将async函数用在promise Chain***</h4><pre><code>const fetch = require(&apos;node-fetch&apos;)

async function getZhihuColumn(id) {
    const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
    const response = await fetch(url)
    const column = await response.json()
    return column
    //上面两行可以直接写成
    //return await response.json()
}

getZhihuColumn(&apos;feweekly&apos;)
    .then(column =&gt; {
        console.log(`NAME:${column.name}`)
    console.log(`INTRO:${column.info}`)
    })
</code></pre><h4 id="将任意类型的函数转为async风格"><a href="#将任意类型的函数转为async风格" class="headerlink" title="将任意类型的函数转为async风格"></a>将任意类型的函数转为async风格</h4><pre><code>const fetch = require(&apos;node-fetch&apos;)

const getZhihuColumn= async (id) =&gt; {
    const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
    const response = await fetch(url)
    const column = await response.json()
    return column
}

//立即执行
(async()=&gt;{
    const column = await getZhihuColumn(&apos;feweekly&apos;)
    console.log(`NAME:${column.name}`)
    console.log(`INTRO:${column.info}`)
})()
</code></pre><h4 id="在class类中使用async风格"><a href="#在class类中使用async风格" class="headerlink" title="在class类中使用async风格"></a>在class类中使用async风格</h4><pre><code>class APIClient {
    async getColumn(id) {
        const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
        const response = await fetch(url)
        const column = await response.json()
        return column
    }
}

//立即执行
(async()=&gt;{
    const client = new APIClient()
    const column = await client.getColumn(&apos;feweekly&apos;)
    console.log(`NAME:${column.name}`)
    console.log(`INTRO:${column.info}`)
})()
</code></pre><h4 id="处理-async-函数中的错误"><a href="#处理-async-函数中的错误" class="headerlink" title="处理 async 函数中的错误"></a>处理 async 函数中的错误</h4><pre><code>const fetch = require(&apos;node-fetch&apos;)

async function getZhihuColumn(id) {
    const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
    const response = await fetch(url)
    if (response.status !== 200) {
        throw new Error(response.status)
    }
    return await response.json()
}

//方式一
getZhihuColumn(&apos;feweekly&apos;)
    .then(column =&gt; {
       console.log(`NAME:${column.name}`)
       console.log(`INTRO:${column.info}`)
   }).catch(err=&gt;{
       console.log(err)
   })

   //方式二

   const showColumnsInfo = async(id) =&gt; {
      try {
        const column = await getZhihuColumn(id)
        console.log(`NAME:${column.name}`)
        console.log(`INTRO:${column.info}`)
      } catch (error) {
          console.log(error)
      }
   }
   showColumnsInfo(&apos;feweek123&apos;)
</code></pre><h4 id="正确处理多个await操作的并行串行"><a href="#正确处理多个await操作的并行串行" class="headerlink" title="正确处理多个await操作的并行串行"></a>正确处理多个await操作的并行串行</h4><pre><code>const fetch = require(&apos;node-fetch&apos;)

    async function getZhihuColumn(id) {
        const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
        const response = await fetch(url)
        return await response.json()
    }

//串行
   const showColumnsInfo = async() =&gt; {
        const column = await getZhihuColumn(&apos;feweely&apos;)
        const toolingtips = await getZhihuColumn(&apos;toolingtips&apos;)
        console.log(`NAME:${column.name}`)
        console.log(`INTRO:${column.info}`)
        console.log(`NAME:${toolingtips.name}`)
        console.log(`INTRO:${toolingtips.info}`)
   }
showColumnsInfo()

//并行
const showColumnsInfo = async() =&gt; {
    const columnPromise = getZhihuColumn(&apos;feweely&apos;)
    const toolingtipsPromise = getZhihuColumn(&apos;toolingtips&apos;)
    const feweekly = await columnPromise
    const toolingtips = await toolingtipsPromise
    console.log(`NAME:${feweekly.name}`)
    console.log(`INTRO:${feweekly.info}`)
    console.log(`NAME:${toolingtips.name}`)
    console.log(`INTRO:${toolingtips.info}`)
}
</code></pre><h4 id="使用Promise-all-让多个await-操作并行"><a href="#使用Promise-all-让多个await-操作并行" class="headerlink" title="使用Promise.all()让多个await 操作并行"></a>使用Promise.all()让多个await 操作并行</h4><pre><code>const fetch = require(&apos;node-fetch&apos;)

    async function getZhihuColumn(id) {
        const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
        const response = await fetch(url)
        return await response.json()
    }


const showColumnsInfo = async() =&gt; {
        const [feweekly,toolingtips] = await Promise.all([//展开操作符
            getZhihuColumn(&apos;feweekly&apos;),
            getZhihuColumn(&apos;toolingtips&apos;)
        ])
        console.log(`$name:${feweekly.name}`)
        console.log(`$name:${feweekly.info}`)
        console.log(`$name:${toolingtips.name}`)
        console.log(`$name:${toolingtips.info}`)
   }
showColumnsInfo()
</code></pre><h4 id="在for循环中正确的使用await"><a href="#在for循环中正确的使用await" class="headerlink" title="在for循环中正确的使用await"></a>在for循环中正确的使用await</h4><pre><code>const fetch = require(&apos;node-fetch&apos;)    
    async function getZhihuColumn(id) {
        const url = `https://zhuanlan.zhihu.com/api/columns/${id}`
        const response = await fetch(url)
        return await response.json()
    }
    /**
     * 串行
     */
const showColumnsInfo = async() =&gt; {
    const names = [&apos;feweekly&apos;,&apos;toolingtips&apos;]
    for (const name of names) {
        const column = await getZhihuColumn(name)
        console.log(`NAME:${column.name}`)
        console.log(`NAME:${column.intro}`)
    }
   }
   /*
   * 并行
   **/
  const showColumnsInfo = async() =&gt; {
    const names = [&apos;feweekly&apos;,&apos;toolingtips&apos;]
    const promise = names.map(x =&gt; getZhihuColumn(x))
    for (const name of promise) {
        const column = await getZhihuColumn(name)
        console.log(`NAME:${column.name}`)
        console.log(`NAME:${column.intro}`)
    }
   }  


showColumnsInfo()
</code></pre><h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><p>微信公众号: 前端周刊</p>
<p>作者:王仕军</p>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/10/mongoose操作mongondb数据库入门/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/10/mongoose操作mongondb数据库入门/" itemprop="url">
                  mongoose操作mongondb数据库入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-10 20:34:17" itemprop="dateCreated datePublished" datetime="2018-11-10T20:34:17+08:00">2018-11-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-11 21:38:00" itemprop="dateModified" datetime="2018-11-11T21:38:00+08:00">2018-11-11</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/node-js-mongodb/" itemprop="url" rel="index"><span itemprop="name">node.js mongodb</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="mongoose操作mongodb数据库入门"><a href="#mongoose操作mongodb数据库入门" class="headerlink" title="mongoose操作mongodb数据库入门"></a>mongoose操作mongodb数据库入门</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Mongoose是在node.js异步环境下对mongodb进行的对象模型工具.</p>
<p>特点:</p>
<ul>
<li>通过关系型数据库的思想来设计非关系型数据库</li>
<li>基于mongodb驱动,简化操作</li>
</ul>
<h4 id="mongoose的安装以及使用"><a href="#mongoose的安装以及使用" class="headerlink" title="mongoose的安装以及使用"></a>mongoose的安装以及使用</h4><ol>
<li><p>安装</p>
<pre><code>npm install mongoose --save
</code></pre></li>
<li><p>引入mongoose并连接数据库</p>
<pre><code>const mongoose = require(&apos;&apos;mongoose)

mongoose.connect(&quot;mongodb://127.0.0.1:27017/数据库名&quot;)
</code></pre></li>
<li><p>定义Schema</p>
</li>
</ol>
<p>数据库中的Schema,为数据库对象的集合.schema是mongoose里会用到的一种数据模式,可以理解为表结构的定义;每个schema会映射到mongodb中的一个collection,不具备操作数据库的能力.</p>
<pre><code>var UserSchema = mongoose.Schema({
    name:String,
    age:Number,
    status:&apos;number&apos; //这种方式也可以
})
</code></pre><ol start="4">
<li>创建数据模型</li>
</ol>
<p>定义好了Schema,接下来就是生成Model.model是由schema生成的模型,可以对数据库进行操作</p>
<ul>
<li><p>备注:mongoose.model里面可以传入两个参数,也可以传入三个参数</p>
<pre><code>mongoose.model(参数1:模型名称(首字母大写),参数2:Schema)
mongoose.model(参数1:模型名称(首字母大写),参数2:Schema,参数3:数据库集合名称)
</code></pre></li>
</ul>
<p>如果传入2个参数:这个模型会模型名称相同的复数的数据库建立连接:如通过下面方法创建模型,那么这个模型将会操作users这个集合</p>
<p>如果传入三个参数的话,模型默认操作第三个参数定义的集合名称</p>
<pre><code>var User = mongoose.model(&quot;User&quot;,UserSchema)
</code></pre><ul>
<li><p>. 查找数据</p>
<pre><code>User.find({},function(err,docs){
    if (err) {
    console.log(err)
    return
    }
    console.log(docs)
})
</code></pre></li>
<li><p>. 增加数据</p>
<pre><code>var u = new User({//实例化模型,传入增加的数据
    name:&quot;wt&quot;,
    age:&quot;20&quot;,
    status:true    
})

u.save()
</code></pre></li>
</ul>
<ul>
<li>. 修改数据</li>
</ul>
<p>User.updateOne({name:”wt”},{name:”lcd”},function(err,res){<br>    if (err) {<br>    console.log(err)<br>    return<br>}<br>    console.log(“修改数据成功”)<br>})</p>
<ul>
<li><p>. 删除数据</p>
<pre><code>User.deleteOne({_id:&quot;127f77hjk45&quot;},function(err){
    if(err){//只会删除一条数据
    console.log(err)
    return
}
    console.log(&quot;删除数据成功&quot;)
})
</code></pre></li>
<li><p>.保存成功查找</p>
</li>
</ul>
<pre><code>var u = new User({
    name:&quot;lks&quot;,
    age:20,
    status:true
})  
u.save(function(err,docs){
    if (err){
    console.log(err)
    return
}
    User.find({},function(err,docs){
    if (err) {
      //
    }
    //
})
})
</code></pre><p>通过上述我们可以看到可以和你容易操作mongodb数据库,但是这种方式在应用过程会很麻烦,后面我们会采取模块化进行来管理.</p>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/javascript私有变量/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/javascript私有变量/" itemprop="url">
                  javascript私有变量
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-09 17:26:19 / 修改时间：17:50:44" itemprop="dateCreated datePublished" datetime="2018-11-09T17:26:19+08:00">2018-11-09</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="javascript私有变量"><a href="#javascript私有变量" class="headerlink" title="javascript私有变量"></a>javascript私有变量</h3><p>在javascript中,没有访问级别的修饰符,(比如,无法声明一个私有变量),所以实现封装的唯一方式就是通过函数作用域和闭包,使用一个工厂方法来实现私有变量</p>
<pre><code>function createPerson(name){
    const privateProperties = {};
    const person = {
        setName: name =&gt; {
            if (!name) throw new Error(&apos;A person must have a name&apos;)
            privateProperties.name = name
        },
        getName:() =&gt;{
            return privateProperties.name
        }
    };
    person.setName(name)
    return person
}

let a = new createPerson(&apos;lcd&apos;)
console.log(a.getName()) //出错  Cannot read property &apos;name&apos; of undefined
a.setName(&apos;lcd&apos;) 
console.log(a.getName())
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/js-xlsx的一些操作封装/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/js-xlsx的一些操作封装/" itemprop="url">
                  js-xlsx的一些操作封装
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-09 15:55:13 / 修改时间：16:51:22" itemprop="dateCreated datePublished" datetime="2018-11-09T15:55:13+08:00">2018-11-09</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/node-js/" itemprop="url" rel="index"><span itemprop="name">node.js</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="js-xlsx的一些常用封装"><a href="#js-xlsx的一些常用封装" class="headerlink" title="js-xlsx的一些常用封装"></a>js-xlsx的一些常用封装</h3><ul>
<li><p>从excel文件中获取头，返回数组</p>
<pre><code>// get head from excel file,return array
// 从excel文件中获取头，返回数组
function get_header_row(sheet) {
    const headers = []
        /*
         sheet1[&apos;!ref&apos;]　获取工作薄的有效范围　&apos;A1:C20&apos;
         XLSX.utils.decode_range 将有效范围转为　range对象
         range: {s: {r:0, c:0}, e: {r:10, 3}}
         */
    const range = XLSX.utils.decode_range(sheet[&apos;!ref&apos;]) 
    // worksheet[&apos;!ref&apos;] 是工作表的有效范围
    let C
    /* 获取单元格值 start in the first row */
    const R = range.s.r //行 //C 列
    for (C = range.s.c; C &lt;= range.e.c; ++C) { /* walk every column in the range */
        //{c:C,r:R} 单元格地址
        var cell = sheet[XLSX.utils.encode_cell({ c: C, r: R })] /* 根据地址得到单元格的值find the cell in the first row */
        var hdr = &apos;UNKNOWN &apos; + C // &lt;-- 替换为您想要的默认值replace with your desired default
        //XLSX.utils.format_cell 生成单元格文本值
        if (cell &amp;&amp; cell.t) hdr = XLSX.utils.format_cell(cell)
        headers.push(hdr)
    }
    return headers
}
</code></pre></li>
<li><p>读取excel的表头和表数据</p>
<pre><code>/*
* 读取excel的表头和表数据
 */
export const read = (data, type) =&gt; {
    /* if type == &apos;base64&apos; must fix data first */
    // const fixedData = fixdata(data)
    // const workbook = XLSX.read(btoa(fixedData), { type: &apos;base64&apos; })
    const workbook = XLSX.read(data, { type: type });//解析数据
    const firstSheetName = workbook.SheetNames[0];//获取Sheets中第一个Sheet的名字
    const worksheet = workbook.Sheets[firstSheetName];//获取第一个Sheet的数据
    const header = get_header_row(worksheet);//获取表的第一行为表头
    const results = XLSX.utils.sheet_to_json(worksheet); //表格对象变为json数据
    return {header, results};
}
</code></pre></li>
<li><p>针对base64的数据提前处理</p>
<pre><code>// fix data,return string
function fixdata(data) {
    let o = &apos;&apos;
    let l = 0
    const w = 10240
    for (; l &lt; data.byteLength / w; ++l) o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w, l * w + w)))
    o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w)))
    return o
}
</code></pre></li>
<li><p>表格转excle</p>
<p>  export const export_table_to_excel= (id, filename) =&gt; {</p>
<pre><code>const table = document.getElementById(id);
const wb = XLSX.utils.table_to_book(table);
XLSX.writeFile(wb, filename);

/* the second way */
// const table = document.getElementById(id);
// const wb = XLSX.utils.book_new();
// const ws = XLSX.utils.table_to_sheet(table);
// XLSX.utils.book_append_sheet(wb, ws, filename);
// XLSX.writeFile(wb, filename);
</code></pre><p>  }</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/HTML5的Blob对象/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/HTML5的Blob对象/" itemprop="url">
                  HTML5的Blob对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-09 13:31:53" itemprop="dateCreated datePublished" datetime="2018-11-09T13:31:53+08:00">2018-11-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-21 16:23:06" itemprop="dateModified" datetime="2018-11-21T16:23:06+08:00">2018-11-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/HTML5/" itemprop="url" rel="index"><span itemprop="name">HTML5</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HTML的Blob对象"><a href="#HTML的Blob对象" class="headerlink" title="HTML的Blob对象"></a>HTML的Blob对象</h3><p>####前言<br>一直以来，JS都没有比较好的可以直接处理二进制的方法。而Blob的存在，允许我们可以通过JS直接操作二进制数据。</p>
<h4 id="Blob对象"><a href="#Blob对象" class="headerlink" title="Blob对象"></a>Blob对象</h4><p>一个Blob对象就是一个包含有只读原始数据的类文件对象。Blob对象中的数据并不一定得是JavaScript中的原生形式。File接口基于Blob，继承了Blob的功能,并且扩展支持了用户计算机上的本地文件。</p>
<p>Blob对象可以看做是存放二进制数据的容器，此外还可以通过Blob设置二进制数据的MIME类型.</p>
<h4 id="创建Blob"><a href="#创建Blob" class="headerlink" title="创建Blob"></a>创建Blob</h4><pre><code>var blob = new Blob(dataArr:Array&lt;any&gt;, opt:{type:string});
</code></pre><ul>
<li>dataArray：数组，包含了要添加到Blob对象中的数据，数据可以是任意多个ArrayBuffer，ArrayBufferView， Blob，或者 DOMString对象。</li>
<li><p>opt：对象，用于设置Blob对象的属性（如：MIME类型）</p>
</li>
<li><p>创建一个装填DOMString对象的Blog对象</p>
<p>  var s = “ <div>hello world!!</div> “</p>
<p>  var blob = new Blob([s],{type:”text/xml”})</p>
<p>  blob</p>
<p>  Blob(24) {size: 24, type: “text/xml”}</p>
</li>
<li><p>创建一个装填ArrayBuffer对象的Blob对象</p>
<pre><code>var abf = new ArrayBuffer(8)
var blob = new Blob([abf],{type:&quot;text/plain&quot;})
blob
Blob{size:8,type:&quot;text/plain&quot;}
</code></pre></li>
<li><p>创建一个装填ArrayBufferView对象的Blob对象(ArrayBufferView可基于ArrayBuffer创建,返回值是一个类数组),如下:创建一个8字节的ArrayBuffer,在其上创建一个每个数组元素为2字节的视图</p>
<pre><code>var abf = new ArrayBuffer(8)
var abv = new Int16Array(abf)
var blob = new Blob(abv,{type:&quot;text/plain&quot;})
blob
Blob{size:4,type:&quot;text/plain&quot;}
</code></pre></li>
<li><p>通过Blob.slice()</p>
</li>
</ul>
<p>此方法返回一个新的BLob对象,包含了原对象指定范围内的数据</p>
<pre><code>Blob.slice(start:number,end:number,contentType:string)
</code></pre><ul>
<li>start: 开始索引,默认为0</li>
<li>end: 截取结束索引(不包括end)</li>
<li><p>contentType:新的Blob的MIME类型,默认为空字符串</p>
<pre><code>var b = new Blob([&quot;zxxxffggggff&quot;],{type:&quot;text/plain&quot;})
var b2 = b.slice(0,5,&quot;text/plain&quot;)
b2
Blob{size:5,type:&quot;text/plain&quot;}
</code></pre></li>
<li><p>通过canvas.toBlob()</p>
<pre><code>var canvas = document.getElementById(&quot;canvas&quot;);
canvas.toBlob(function(blob){
    console.log(blob);
});
</code></pre></li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>前面提到，File接口基于Blob，继承了Blob的功能并进行了扩展，故我们可以像使用Blob一样使用File对象。</p>
<ul>
<li>分片上传</li>
</ul>
<p>通过Blob.slice方法，可以将大文件分片，轮循向后台提交各文件片段，即可实现文件的分片上传。</p>
<p>分片上传逻辑如下：</p>
<ul>
<li>获取要上传文件的File对象，根据chunk（每片大小）对文件进行分片</li>
<li>通过post方法轮循上传每片文件，其中url中拼接querystring用于描述当前上传的文件信息；</li>
<li>post body中存放本次要上传的二进制数据片段</li>
<li>接口每次返回offset，用于执行下次上传</li>
</ul>
<p>下面是分片上传的简单实现：</p>
<pre><code>initUpload();

//初始化上传
function initUpload() {
    var chunk = 100 * 1024;   //每片大小
    var input = document.getElementById(&quot;file&quot;);    //input file
    input.onchange = function (e) {
        var file = this.files[0];
        var query = {};
        var chunks = [];
        if (!!file) {
            var start = 0;
            //文件分片
            for (var i = 0; i &lt; Math.ceil(file.size / chunk); i++) {
                var end = start + chunk;
                chunks[i] = file.slice(start , end);
                start = end;
            }

            // 采用post方法上传文件
            // url query上拼接以下参数，用于记录上传偏移
            // post body中存放本次要上传的二进制数据
            query = {
                fileSize: file.size,
                dataSize: chunk,
                nextOffset: 0
            }

            upload(chunks, query, successPerUpload);
        }
    }
}

// 执行上传
    function upload(chunks, query, cb) {
        var queryStr = Object.getOwnPropertyNames(query).map(key =&gt; {
            return key + &quot;=&quot; + query[key];
        }).join(&quot;&amp;&quot;);
        var xhr = new XMLHttpRequest();
        xhr.open(&quot;POST&quot;, &quot;http://xxxx/opload?&quot; + queryStr);
        xhr.overrideMimeType(&quot;application/octet-stream&quot;);

        //获取post body中二进制数据
        var index = Math.floor(query.nextOffset / query.dataSize);
        getFileBinary(chunks[index], function (binary) {
            if (xhr.sendAsBinary) {
                xhr.sendAsBinary(binary);
            } else {
                xhr.send(binary);
            }

        });

        xhr.onreadystatechange = function (e) {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    var resp = JSON.parse(xhr.responseText);
                    // 接口返回nextoffset
                    // resp = {
                    //     isFinish:false,
                    //     offset:100*1024
                    // }
                    if (typeof cb === &quot;function&quot;) {
                        cb.call(this, resp, chunks, query)
                    }
                }
            }
        }
    }

    // 每片上传成功后执行
    function successPerUpload(resp, chunks, query) {
        if (resp.isFinish === true) {
            alert(&quot;上传成功&quot;);
        } else {
            //未上传完毕
            query.offset = resp.offset;
            upload(chunks, query, successPerUpload);
        }
    }

    // 获取文件二进制数据
    function getFileBinary(file, cb) {
        var reader = new FileReader();
        reader.readAsArrayBuffer(file);
        reader.onload = function (e) {
            if (typeof cb === &quot;function&quot;) {
                cb.call(this, this.result);
            }
        }
    }
</code></pre><p>以上是文件分片上传前端的简单实现，当然，此功能还可以更加完善，如后台需要对合并后的文件大小进行校验；或者前端加密文件，全部上传完毕后后端解密校验等.</p>
<ul>
<li>通过url下载文件</li>
</ul>
<p>window.URL对象可以为Blob对象生成一个网络地址，结合a标签的download属性，可以实现点击url下载文件.</p>
<pre><code>createDownload(&quot;download.txt&quot;,&quot;download file&quot;);

function createDownload(fileName, content){
    var blob = new Blob([content]);
    var link = document.createElement(&quot;a&quot;);
    link.innerHTML = fileName;
    link.download = fileName;
    link.href = URL.createObjectURL(blob);
    document.getElementsByTagName(&quot;body&quot;)[0].appendChild(link);
}
</code></pre><ul>
<li>通过url显示图片</li>
</ul>
<p>我们知道，img的src属性及background的url属性，都可以通过接收图片的网络地址或base64来显示图片，同样的，我们也可以把图片转化为Blob对象，生成URL（URL.createObjectURL(blob)），来显示图片。</p>
<p>Blob对象作为一个装填二进制数据的基本对象，其作用也仅仅是一个容器，而真正的业务功能则需要通过FileReader、URL、Canvas等对象实现</p>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/html5的FileReader对象/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/html5的FileReader对象/" itemprop="url">
                  html5的FileReader对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-09 13:16:39 / 修改时间：13:31:15" itemprop="dateCreated datePublished" datetime="2018-11-09T13:16:39+08:00">2018-11-09</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/HTML5/" itemprop="url" rel="index"><span itemprop="name">HTML5</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HTML5的FileReader对象"><a href="#HTML5的FileReader对象" class="headerlink" title="HTML5的FileReader对象"></a>HTML5的FileReader对象</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>FileReader主要用于将文件内容读入内存，通过一系列异步接口，可以在主线程中访问本地文件。</p>
<p>使用FileReader对象，web应用程序可以异步的读取存储在用户计算机上的文件(或者原始数据缓冲)内容，可以使用File对象或者Blob对象来指定所要处理的文件或数据。</p>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><pre><code>var reader = new FileReader();
</code></pre><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre><code>方法定义                               描述
abort():void                     终止文件读取操作
readAsArrayBuffer(file):void     异步按字节读取文件内容，结果用ArrayBuffer对象表示
readAsBinaryString(file):void    异步按字节读取文件内容，结果为文件的二进制串
readAsDataURL(file):void         异步读取文件内容，结果用data:url的字符串形式表示
readAsText(file,encoding):void   异步按字符读取文件内容，结果用字符串形式表示
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre><code>事件名称                         描述
onabort               当读取操作被中止时调用
onerror               当读取操作发生错误时调用
onload                当读取操作成功完成时调用
onloadend              当读取操作完成时调用,不管是成功还是失败
onloadstart              当读取操作将要开始之前调用    
onprogress              在读取数据过程中周期性调用
</code></pre><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>FileReader通过异步的方式读取文件内容，结果均是通过事件回调获取，下面是一个读取本地txt文件内容的例子：</p>
<pre><code>var input  = document.getElementById(&quot;file&quot;); //input file
input.onchange = function(){
    var file = this.files[0];
    if(!!file){
        //读取本地文件，以gbk编码方式输出
        var reader = new FileReader();
        reader.readAsText(file,&quot;gbk&quot;);
        reader.onload = function(){
            //读取完毕后输出结果
            console.log(this.result);
        }
    }
}
</code></pre><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>在线预览本地文件</li>
</ul>
<p>img的src属性或background的url属性，可以通过被赋值为图片网络地址或base64的方式显示图片。<br>在文件上传中，我们一般会先将本地文件上传到服务器，上传成功后，由后台返回图片的网络地址再在前端显示。<br>通过FileReader的readAsDataURL方法，我们可以不经过后台，直接将本地图片显示在页面上。这样做可以减少前后端频繁的交互过程，减少服务器端无用的图片资源，代码如下：</p>
<pre><code>var input  = document.getElementById(&quot;file&quot;);   // input file
input.onchange = function(){
    var file = this.files[0];
        if(!!file){
            var reader = new FileReader();
            // 图片文件转换为base64
            reader.readAsDataURL(file);
            reader.onload = function(){
                // 显示图片
                document.getElementById(&quot;file_img&quot;).src = this.result;
        }
    }
}
</code></pre><p>对于图片上传，我们也可以先将图片转换为base64进行传输，此时由于传输的图片内容就是一段字符串，故上传接口可以当做普通post接口处理，当图片传输到后台后，可以在转换为文件实体存储。<br>当然，考虑到base64转换效率及其本身的大小，本方法还是适合于上传内容简单或所占内存较小的文件。</p>
<ul>
<li>二进制数据上传</li>
</ul>
<p>我们可以直接上传或下载二进制内容，无需像以往一样通过form标签由后端拉取二进制内容。<br>简单整理下上传逻辑：<br>1、通过input[type=”file”]标签获取本地文件File对象<br>2、通过FileReader的readAsArrayBuffer方法将File对象转换为ArrayBuffer<br>3、创建xhr对象，配置请求信息<br>4、通过xhr.sendAsBinary直接将文件的ArrayBuffer内容装填至post body后发送</p>
<pre><code>var input  = document.getElementById(&quot;file&quot;);   // input file
input.onchange = function(){
    var file = this.files[0];
        if(!!file){
            var reader = new FileReader();
            reader.readAsArrayBuffer(file);
            reader.onload = function(){
                var binary = this.result;
                upload(binary);
        }
    }
}

//文件上传
function upload(binary){
    var xhr = new XMLHttpRequest();
    xhr.open(&quot;POST&quot;, &quot;http://xxxx/opload&quot;);
    xhr.overrideMimeType(&quot;application/octet-stream&quot;);
    //直接发送二进制数据
    if(xhr.sendAsBinary){
        xhr.sendAsBinary(binary);
    }else{
        xhr.send(binary);
    }

    // 监听变化
    xhr.onreadystatechange = function(e){
        if(xhr.readyState===4){
            if(xhr.status===200){
                // 响应成功       
            }
        }
    }
}
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/vue的一些工具方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/vue的一些工具方法/" itemprop="url">
                  vue的一些工具方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-09 10:17:33 / 修改时间：17:02:47" itemprop="dateCreated datePublished" datetime="2018-11-09T10:17:33+08:00">2018-11-09</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="常常应用的到的一些方法"><a href="#常常应用的到的一些方法" class="headerlink" title="常常应用的到的一些方法"></a>常常应用的到的一些方法</h3><pre><code>  /**
 * 判断两个对象是否相等
 * @param {*} obj1 
 * @param {*} obj2 
 */
export const objEqual = (obj1, obj2) =&gt; {
    const keysArr1 = Object.keys(obj1) //获取属性名
    const keysArr2 = Object.keys(obj2)
    if (keysArr1.length !== keysArr2.length) return false
    else if (keysArr1.length === 0 &amp;&amp; keysArr2.length === 0) return true
    else return !keysArr1.some(key =&gt; obj1[key] !== obj2[key])// some有一条相同返回true,取反为false
  }


/**
 * 根据路由的params生成对象
 * * */
  export const getRouteById = id =&gt; {
    let res = {}
    if (id.includes(&apos;&amp;&apos;)) {
      res.query = getObjBySplitStr(id, &apos;&amp;&apos;)
      id = id.split(&apos;&amp;&apos;)[0]
    }
    if (id.includes(&apos;:&apos;)) {
      res.params = getObjBySplitStr(id, &apos;:&apos;)
      id = id.split(&apos;:&apos;)[0]
    }
    res.name = id
    return res
  }


 export const routeEqual = (route1, route2) =&gt; {
    const params1 = route1.params || {} //逻辑或,route1.params不为空的话就返回他,或者返回{}空对象
    const params2 = route2.params || {}
    const query1 = route1.query || {} //因为路由传参有两种方式,所以要使用两种方式获取参数
    const query2 = route2.query || {}
    return route1.name === route2.name &amp;&amp; objEqual(params1, params2) &amp;&amp; objEqual(query1, query2)
  }
</code></pre><ul>
<li>点击上传Csv文件</li>
</ul>
<pre><code>/**
 * @param {Object} file 从上传组件得到的文件对象
 * @returns {Promise} resolve参数是解析后的二维数组
 * @description 从Csv文件中解析出表格，解析成二维数组
 */
export const getArrayFromFile = (file) =&gt; {
    let nameSplit = file.name.split(&apos;.&apos;) //按照指定符号.切割文件
    let format = nameSplit[nameSplit.length - 1] //[-1]得到文件名
    return new Promise((resolve, reject) =&gt; {//返回promise可以用then来获取
      let reader = new FileReader() //h5创建读取文件
      reader.readAsText(file) // 以文本格式读取
      let arr = []
      reader.onload = function (evt) {//event事件里面有各种属性
        let data = evt.target.result // 读到的数据
        let pasteData = data.trim() 
        //正则:[]指匹配里面任何一个都可以 \n 匹配一个换行符, \u0085匹配下一行 \u2028行分割 \u2029分段符号
        // \r 回车符 \n?匹配换行0此或者一次 /g代表全局匹配  \t匹配水平制表符
        arr = pasteData.split((/[\n\u0085\u2028\u2029]|\r\n?/g)).map(row =&gt; {
          return row.split(&apos;\t&apos;)
        }).map(item =&gt; {
          return item[0].split(&apos;,&apos;)
        })
        if (format === &apos;csv&apos;) resolve(arr)
        else reject(new Error(&apos;[Format Error]:你上传的不是Csv文件&apos;))
      }
    })
  }

/**
 * @param {Array} array 表格数据二维数组
 * @returns {Object} { columns, tableData }
 * @description 从二维数组中获取表头和表格数据，将第一行作为表头，用于在iView的表格中展示数据
 */
export const getTableDataFromArray = (array) =&gt; {
  let columns = []
  let tableData = []
  if (array.length &gt; 1) {
    let titles = array.shift() //删除数组中的第一个元素（red），并返回被删除元素的值
    columns = titles.map(item =&gt; {
      return {
        title: item,
        key: item
      }
    })
    tableData = array.map(item =&gt; {
      let res = {}
      item.forEach((col, i) =&gt; {
        res[titles[i]] = col
      })
      return res
    })
  }
  return {
    columns,
    tableData
  }
}

iview Upload组件的beforeUpload应用

beforeUpload (file) {//beforeUpload得到文件对象
      getArrayFromFile(file).then(data =&gt; {
        let {columns, tableData} = getTableDataFromArray(data)
        this.columns = columns
        this.tableData = tableData
      }).catch(() =&gt; {
        this.$Notice.warning({
          title: &apos;只能上传Csv文件&apos;,
          desc: &apos;只能上传Csv文件，请重新上传&apos;
        })
      })
      return false
    }
</code></pre><ul>
<li><p>数组的交集</p>
<pre><code>/**
 * @param {Array} arr1
 * @param {Array} arr2
 * @description 得到两个数组的交集, 两个数组的元素为数值或字符串
 */
export const getIntersection = (arr1, arr2) =&gt; {
  let len = Math.min(arr1.length, arr2.length)
  let i = -1
  let res = []
  while (++i &lt; len) {
    const item = arr2[i]
    if (arr1.indexOf(item) &gt; -1) res.push(item)
  }
  return res
}
</code></pre></li>
<li><p>数组的并集</p>
<pre><code>/**
 * @param {Array} arr1
 * @param {Array} arr2
 * @description 得到两个数组的并集, 两个数组的元素为数值或字符串
 */
export const getUnion = (arr1, arr2) =&gt; {
  return Array.from(new Set([...arr1, ...arr2]))
}
</code></pre></li>
</ul>
<ul>
<li>判断数组</li>
</ul>
<pre><code>/**
 * @param {Array} target 目标数组
 * @param {Array} arr 需要查询的数组
 * @description 判断要查询的数组是否至少有一个元素包含在目标数组中
 */
export const hasOneOf = (target, arr) =&gt; {
  return target.some(_ =&gt; arr.indexOf(_) &gt; -1)
}
</code></pre><ul>
<li><p>验证</p>
<pre><code>/**
 * @param {String|Number} value 要验证的字符串或数值
 * @param {*} validList 用来验证的列表
 */
export function oneOf (value, validList) {
  for (let i = 0; i &lt; validList.length; i++) {
    if (value === validList[i]) {
      return true
    }
  }
  return false
}
</code></pre></li>
</ul>
<pre><code>/**
 * 判断一个对象是否存在key，如果传入第二个参数key，则是判断这个obj对象是否存在key这个属性
 * 如果没有传入key这个参数，则判断obj对象是否有键值对
 */
export const hasKey = (obj, key) =&gt; {
  if (key) return key in obj
  else {
    let keysArr = Object.keys(obj)
    return keysArr.length
  }
}
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="厚朴酚">
            
              <p class="site-author-name" itemprop="name">厚朴酚</p>
              <p class="site-description motion-element" itemprop="description">学习笔记</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">56</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">29</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">厚朴酚</span>

  

  
</div>



<!--
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.4.2</div>
 -->



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>

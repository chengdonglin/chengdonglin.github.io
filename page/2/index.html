<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="厚朴酚">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="厚朴酚">
<meta property="og:description" content="学习笔记">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="厚朴酚">
<meta name="twitter:description" content="学习笔记">






  <link rel="canonical" href="http://yoursite.com/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>厚朴酚</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">厚朴酚</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">打磨技术!</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/16/js进阶知识/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/16/js进阶知识/" itemprop="url">
                  js进阶知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-16 12:25:33" itemprop="dateCreated datePublished" datetime="2018-12-16T12:25:33+08:00">2018-12-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-25 16:45:03" itemprop="dateModified" datetime="2018-12-25T16:45:03+08:00">2018-12-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="js进阶知识"><a href="#js进阶知识" class="headerlink" title="js进阶知识"></a>js进阶知识</h2><h3 id="值类型与引用类型"><a href="#值类型与引用类型" class="headerlink" title="值类型与引用类型"></a>值类型与引用类型</h3><h4 id="值类型与引用类型在内存的存储情况"><a href="#值类型与引用类型在内存的存储情况" class="headerlink" title="值类型与引用类型在内存的存储情况"></a>值类型与引用类型在内存的存储情况</h4><pre><code>变量名 : 具体值
针对栈: 变量名 : 具体值
针对堆: 变量名 : 地址值
</code></pre><ol>
<li><p>栈内存: 值类型存放的位置</p>
<p> 简单类型比如string,number,boolean,null,undefined存放在栈空间</p>
</li>
<li><p>堆内存: 引用内存存放的位置, 内存空间</p>
<p> 比如:function, object, Array</p>
</li>
</ol>
<h4 id="值类型和引用类型与传递"><a href="#值类型和引用类型与传递" class="headerlink" title="值类型和引用类型与传递"></a>值类型和引用类型与传递</h4><ol>
<li><p>值类型的复制赋值和引用类型的赋值的区别</p>
<p> 引用类型的赋值操作:将引用类型堆上的内存地址进行赋值</p>
</li>
<li><p>函数参数的引用传递和值传递</p>
<ul>
<li>如果实参的值类型,会复制一个值类型的副本给函数,不会影响原来的传递参数的值类型变量</li>
<li><p>如果实参是引用类型,传递只是引用类型的一个地址值,在函数内部操作参数对应的引用对象会影响到传递的参数,也就是会改变原来传递参数的值</p>
<pre><code>var a = 9,b;
var c = {age:9},d;
//值类型
b=a
b=19
console.log(a)   //9
console.log(b)   //19
//引用类型
d =c;
d.age = 22,
console.log(c.age)  //22
console.log(d.age)  //22
</code></pre></li>
</ul>
</li>
</ol>
<h4 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h4><ol>
<li>arguments参数</li>
</ol>
<pre><code>//实现max方法,可以接收任意多个参数,返回参数中最大的哪个值
    function myMax(){
        if (arguments.length &lt;0){
            return NaN
        }
        var max = arguments[0];
        for (var i=0; i&lt; arguments.length;i++){
            if (arguments[i]&gt;max) {
                max = arguments[i]
            }
        }
        return max
    }

    const result = myMax(12,4,6,7,8)
    console.log(result)
</code></pre><ol start="2">
<li><p>函数参数的封装</p>
<p> 如果参数多于4个,难于记忆,可以将参数封装成对象来接受,对象的属性无序的,方便开发任意使用</p>
<pre><code>var rect = {
    x:19,
    y:20,
    width:256,
    height:256,
    bgColor:&apos;#ccc&apos;
}
function rect(rectObject){
    console.log(rectObject + &apos;&apos;+ rectObject.y)
}
</code></pre></li>
</ol>
<h3 id="函数高级"><a href="#函数高级" class="headerlink" title="函数高级"></a>函数高级</h3><h4 id="javascript事件循环机制-Event-Loop"><a href="#javascript事件循环机制-Event-Loop" class="headerlink" title="javascript事件循环机制(Event Loop)"></a>javascript事件循环机制(Event Loop)</h4><ul>
<li><p>为什么单线程? </p>
<p>  Javascript执行线程和UI线程是互斥的</p>
<p>  javascript的任务分为同步任务和异步任务</p>
<p>  同步任务:一般赋值操作,循环,分支语句等</p>
<p>  异步任务:DOM事件,Ajax,BOM等api</p>
</li>
<li><p>事件循环机制:</p>
<p>  javascript的执行引擎的主线程从队列中获取任务执行,如果任务是异步任务,那么运行到异步任务的时候,异步任务就退出主线程,主线程进行下一个任务的获取处理. 如果异步任务完成,就插入到任务队列的末尾,等待主线程处理.        </p>
<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4></li>
<li><p>javscript的解释和执行阶段</p>
<ul>
<li>解释阶段<ul>
<li>词法分析</li>
<li>语法分析</li>
<li>作用域规则确定</li>
</ul>
</li>
<li>执行阶段<ul>
<li>创建执行上下文</li>
<li>执行函数代码</li>
<li>垃圾回收</li>
</ul>
</li>
</ul>
</li>
<li><p>函数变量作用域</p>
<ol>
<li>作用域:就是变量声明的区域,就是变量和函数的可访问范围,在全局声明的变量为全局可见访问的就是全局变量,如果在函数内部声明的变量只能在函数内部访问</li>
<li>函数的参数只能在函数内部访问,是局部变量</li>
<li>javascript没有块级作用域,只有函数作用域和全局作用域,for循环内部定义的变量是函数级别的作用域,现在可以通过let解决</li>
<li>变量没有在函数内声明或者声明的时候没有带var就是全局变量,拥有全局作用域,特殊: var a = b = c = 0;b与c是全局变量.</li>
<li>全局作用域的变量可以在js中任何地方调用,函数作用域的变量只能在字节函数内部调用,包括字节定义的其他函数都可以直接调用</li>
<li>变量的作用域是以它声明时为准,因为变量的作用域在js代码的解释阶段已经完成规则的制订</li>
</ol>
</li>
</ul>
<pre><code>var t = 9 //全局作用域,全部都可以访问
function f1() { //f1函数全局作用域
    var t2 = 10 //t2是f1函数内部可访问
    console.log(t)
    function f2() {//函数f2是函数f1的作用域
        var t3 = 200; //t3只能在f2函数内部调用
        console.log(t2)
        return t2*t2 //f2函数可以访问f1函数作用域的变量以及f2字节内部变量
    }
    return f2()
}
var m =f1()
console.log(m)
</code></pre><p>函数的声明与变量同名的化,函数优先级较高,函数是一等公民</p>
<h4 id="变量提升与函数提升"><a href="#变量提升与函数提升" class="headerlink" title="变量提升与函数提升"></a>变量提升与函数提升</h4><ul>
<li><p>变量提升</p>
<ol>
<li>如果一个声明的变量在函数体内,那么它的作用域就是函数内部,如果是全局环境下声明的,那么它的作用域就是全局的,通过var声明的变量无法用delete删除的</li>
<li>函数内部的声明的变量会被提升到函数的头部,函数在解释执行的时候,先进行变量声明处理,然后再运行函数内部的代码</li>
<li>变量和赋值语句仪器书写,在js引擎解析时候,会将其拆成声明和赋值2部分,声明置顶,赋值保留在原来位置</li>
<li><p>变量重复声明不会出错,后面会覆盖前面的</p>
<pre><code>var a =10
function f1(){
    //函数的变量提升,因为在函数执行之前,先创建了函数的EC,
    //在创建EC的时候以及把函数声明的变量以及初始化为undefined
    console.log(a) //undefined
    var a = 19
    console.log(a) //19
}
f1()
console.log(a) //  10
</code></pre></li>
</ol>
</li>
</ul>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><ol>
<li>作用域链是一个数组</li>
<li>作用域链是控制变量作用域的有序访问js内部实现</li>
<li>作用域链存储在函数的执行上下文,作用域链存放的是执行环境中的VO或者AO</li>
<li>当前函数的作用域对象都是在最前端,而且全局的在最末端</li>
<li>变量(标识符)的搜索都是从作用域链的最前端向后搜索,直到全局作用域,标识符的解析是沿着作用域链一级一级搜索的过程,从第一个对象开始,逐渐向后回溯,直到找到同名标识符为止,找到后不在继续遍历,找不到就报错<h4 id="函数的arguments"><a href="#函数的arguments" class="headerlink" title="函数的arguments"></a>函数的arguments</h4><h4 id="函数执行上下文"><a href="#函数执行上下文" class="headerlink" title="函数执行上下文"></a>函数执行上下文</h4></li>
</ol>
<ul>
<li>执行上下文相关</li>
</ul>
<ol>
<li>栈的数据结构:先进后出</li>
<li>EC:函数执行环境(或执行上下文)</li>
<li>ECS:执行环境栈</li>
<li>VO变量对象:js的执行上下文中都有个对象用来存放执行上下文中可被访问但是不能被delete的函数标识符,形参,变量声明等.他们会被挂载这个对象上,对象的属性对应他们的名字对象属性的值对应他们的值但这个对象是规范上或者说是引擎实现上的不可在js环境中访问到活动对象.</li>
<li>AO激活对象:有了变量对象存每个上下文的东西,但是它是声明时候被访问呢?就是每进入一个执行上下文时,这个执行上下文的变量对象被激活,也就是该上下文的函数标识符,形参/变量声明就可以被访问了</li>
</ol>
<ul>
<li>执行上下文的执行栈</li>
</ul>
<ol>
<li>javascript执行在单线程上,使用代码都是排队执行</li>
<li>一开始浏览器执行全局的代码时,首先创建全局的执行上下文,压入执行栈的顶部.</li>
<li>每当进入一个函数的执行就会创建函数的执行上下文,并且把它压入执行栈的顶部.当函数执行完成后,当前函数的执行上下文出栈,并等待垃圾回收.</li>
<li>浏览器的Js执行引擎总是访问栈定的执行上下文</li>
<li><p>全局上下文只有唯一的一个,在浏览器关闭的时候出栈.</p>
<pre><code>//(EQ)代码执行之前的时候,就会立即创建一个全局的执行上下文  global excution context
//在这个例子当中就是这些函数
//创建完全局的执行上下文之后,把全局的上下文压入执行栈
function f1(){
    console.log(&apos;f1&apos;)
}
function f2(){
    console.log(&apos;f2&apos;)
    f3()
}
function f3(){
    console.log(&apos;f3&apos;)
    f4()
}
function f4(){
    console.log(&apos;f4&apos;)
}

f1() //代码进入f1函数,函数内的代码在执行之前,js执行引擎立即创建一个f1的
    //执行环境 f1  Excution Context 立即把这个执行环境压入到执行环境栈中ecs
    //f1() 函数执行完之后,从执行环境栈中弹出f1的执行上下文
//f2()函数执行之前,创建f2的执行上下文,压栈到执行环境栈中ECS
//因为f2调用了f3函数,f3函数执行之前也创建了一个f3的执行 上下文,并压栈到执行环境栈中
//f3函数调用f4函数,创建f4的EC,并把f4的EC压入到ECS中
//f4执行完成,f4的EC出栈
//f3执行完成,f3的EC出栈
//f2执行完成,f2的EC出栈
f2()  //f2()-&gt; f3()-&gt;f4()  //
</code></pre><h5 id="执行上下文的声明周期"><a href="#执行上下文的声明周期" class="headerlink" title="执行上下文的声明周期"></a>执行上下文的声明周期</h5></li>
</ol>
<ul>
<li>总的生命周期: 创建-&gt;执行-&gt;出栈等待销毁</li>
<li>创建阶段:<ol>
<li>创建作用域链</li>
<li>创建变量对象(AO):首先初始化函数的参数arguments,初始化函数声明,初始化变量(undefined),函数的优先级要高于变量,如果变量和函数重名,变量被忽略.<ul>
<li>创建arguments对象,检查上下文,初始化参数名称和值并创建引用的复制</li>
<li>扫描上下文的函数声明(而非函数表达式):<ul>
<li>为发现的每一个函数,在变量对象创建一个属性–确切的说是函数的名字,其有一个指向函数在内存中的引用</li>
<li>如果函数的名字已经存在,引用指针将被重写</li>
</ul>
</li>
<li>扫描上下文的变量声明:<ul>
<li>为发现的每个变量声明,在变量对象上创建一个属性-就是变量的名字,并且将变量的初始值为undefined</li>
<li>如果变量的名字已经在变量对象里存在,将不会进行任何操作并继续扫描</li>
</ul>
</li>
<li>求出上下文的内部this的值</li>
</ul>
</li>
</ol>
</li>
<li>执行阶段:<ul>
<li>执行变量赋值,代码执行</li>
</ul>
</li>
<li><p>回收阶段</p>
<ul>
<li><p>执行上下文出栈等待虚拟机回收执行上下文</p>
<pre><code>//变量声明
var a1 = 19,
    a2 = 20,
    a3 = &apos;sss&apos;,
    b1 = {name:&apos;lcd&apos;}
//函数声明
a1 = f1(a1,a2) 
//函数声明
function f1(a,b){
    //f1函数的执行上下文
    //第一步:扫描参数, a =19, b = 20
    //第二步:扫描函数声明 f2 = function(){}
    //第三步:扫描变量声明  t=undefined  m = undifined i = undefined   变量提升
    var t =0,
        m =10;
    for (var i= 0;i&lt; a;i++){
        console.log(i)
    }
    function f2() {
        console.log(f2)
    }
    return a + b;
}
</code></pre></li>
</ul>
</li>
</ul>
<h4 id="构造函数内部执行过程"><a href="#构造函数内部执行过程" class="headerlink" title="构造函数内部执行过程"></a>构造函数内部执行过程</h4><h4 id="函数的四种调用模式"><a href="#函数的四种调用模式" class="headerlink" title="函数的四种调用模式"></a>函数的四种调用模式</h4><h5 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h5><p>如果一个函数作为对象的一个方法属性调用,那么就是方法调用模式</p>
<pre><code>var a = {}; a.toString() //方法调用模式

    //定义构造函数
//定义一个Dog类的构造函数
function Dog(dogName){
    //如果函数当构造函数来用
    //第一步:创建一个空对象(新对象),函数上下文===this
    //第二步:把空对象赋值给函数的上下文, this=新对象
    this.name = dogName
    this.age = 0;
    this.run = function () {
        console.log(this.name + &apos;is running&apos;)
    }
    //如果函数当前当做构造函数调用,并没有返回任何数据的时候,默认返回新对象this
}
//当构造函数创建一个Dog类型的实例
var d = new Dog(&apos;lddd&apos;) //构造函数的返回值就是默认的新对象this
d.run()//调用d对象实例的run方法,这就是对象的方法调用模式
//在方法调用模式中,方法内部的this指向当前调用者的对象 =&gt; d
//this === d  //true
</code></pre><h5 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h5><ol>
<li>如果一个函数直接调用,那么调用者其实就是全局对象: window</li>
<li><p>函数调用模式this指向全局对象</p>
<pre><code>function f() {}   fn()://函数调用模式

   function dog(){
   this.age = 19;
   console.log(this)
   }
   dog()//函数执行模式  =&gt; window
   var d = new Dog() //构造函数执行模式  =&gt; d对象
</code></pre><h5 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h5><ul>
<li>构造器调用模式就是构造函数调用</li>
<li>构造器模式调用必须有关键字new存在</li>
<li><p>构造器模式调用this指向创建出来的新对象</p>
<pre><code>var t = new Dog() //构造器调用模式
</code></pre><ul>
<li>构造函数可以返回一个值,但是如果是简单类型会被忽略,如果是引用类型会替换新的插件对象返回</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>//构造器调用函数  构造函数
//关键字 :  new
function Cat(){
    //第一步:创建一个空对象(新对象)
    //第二步:给函数上下文赋值 新对象 this = 新对象
    this.age = 19
    this.name = &quot;cat&quot;//构造函数内部定义this属性
    this.run(){
        console.log(this.name + &apos;run&apos;)
    }
    //如果构造函数没有返回值,那么返回this(新对象)
    //return 3 //即使有返回值,如果返回值类型是简单类型,那么会被忽略
    //如果返回值是一个引用类型(去掉null)那么新对象会被抛弃,把这个引用类型返回
    return {
        name:999,
        run:function(){
            console.log(&apos;字节返回的{}&apos;)
        }
    }
}
var cat = new Cat()//构造函数调用模式
//如果使用new关键字+构造函数指向的话触发了构造函数执行模式
cat.age = 20;
cat.name = &apos;www&apos;
cat.run()//方法调用模式
</code></pre><h5 id="apply-call-调用模式-借用方法模式"><a href="#apply-call-调用模式-借用方法模式" class="headerlink" title="apply/call 调用模式(借用方法模式)"></a>apply/call 调用模式(借用方法模式)</h5><pre><code>- apply和call可以改变函数调用的内部this指向
- apply和call的功能一样,只不够参数不一样,第一个参数都是改变函数内部的this执行
- 第一个参数如果是null,undefined会被全局对象替代,如果是简单类型会被包装类型替代
- call第二个参数开始后面都是传给函数的参数,可以有多个,用逗号隔开
- apply第二个参数是一个传给函数的参数数组

    function sum(a,b) {
        console.log(this)
        return a +b
    }

    var t = {
        name:&apos;lcd&apos;
    }
    sum(1,2)  //this =&gt; window
    //f.call(context,p1,p2)
    var m = sum.call(t,2,3)  //Object {name:&apos;lcd&apos;}
    console.log(m)//5

    var m2 = sum.apply(t,[1,2])//Object {name:&apos;lcd}
    console.log(m2)//3
    sum.call(null,3,5)//window
    sum.call(undeifined,3,5)//window
    sum.call(3,3,5) //返回包装类型  Number{}
</code></pre><h6 id="函数四种调用模式案例"><a href="#函数四种调用模式案例" class="headerlink" title="函数四种调用模式案例"></a>函数四种调用模式案例</h6><pre><code>//1. 定义按钮类,要求按钮类的构造函数可以接受参数初始化的宽度,高度,坐标
function Btn(width,height,x,y){
    //构造函数内部初始化值
    this.width = width //给this对象上的width属性赋值, width参数的参数值
    this.height = height
    this.x = x
    this.y = y
}
var b = new Btn(100,100,30,30)

//2. 借用Math的min方法实现求数组[2,9,33]中的最小值
Math.min.apply(null,[2,9,33])

//3. 把类数组转为真正的数组
var t = {} //类数组,跟数组相识,单不是数组
t[0] =1;
t[1] = true;
t[2] = &apos;lcd&apos;
t.length = 3
//t = [1,true,&apos;lcd&apos;] 转为这种类型
//var m = [1,2,3]
//m.slice()//如果上面都不传,默认从0索引开始截取到数组最好
//第一个参数是: 截取开始的位置, startIndex
//第二个参数是: 截取结束的位置+1, endIndex
//如果借用数组的slice方法,然后把this指向t对象,那么slice方法就会返回t对象对应的数组
Array.prototype.slice.call(t,0)


//4. 判断代码输出内容
function Dog(){
    console.log(this)
}
Dog()//window
var d = new Dog() //this === d
Dog(null) //借用调用模式, window
</code></pre><h4 id="没有重载-通过arguments模拟实现"><a href="#没有重载-通过arguments模拟实现" class="headerlink" title="没有重载(通过arguments模拟实现)"></a>没有重载(通过arguments模拟实现)</h4><ul>
<li>javascript函数不能重名,如果重名了后面的会把前面的覆盖</li>
<li>原因:所有的函数声明都会创建在Vo或者AO上的一个属性,而后面声明的函数会把前面vo或者ao中的同名属性覆盖</li>
<li>重载的概念:在程序中可以定义相同名字.不同参数的形式的不同函数,函数在调用的时候,自动适别不同参数对应的函数,实现了相同函数名不同的函数调用</li>
<li>javascript中通过arguments实现函数重载</li>
<li><p>数组的slice方法,splice方法等多可以传一个参数或者多个参数,不同参数方法内部实现不一样,就是方法重载.</p>
<pre><code>function React() { 
    //如果一个参数,返回正方形
    if(arguments.length ==1){
        this.width = arguments[0]
        this.height = arguments[0]
    }
    if(arguments.length &gt; 1) {
        this.width = arguments[0]
        this.height = arguments[0]
    }
    //由于跟原型toString()方法重名,会覆盖原型上的方法
    this.toString = function () {
        console.log(width,height)
    }
 }
 var r1 = new React(10)
 console.log(r1.toString())
</code></pre><h4 id="函数的属性和方法-length-prototype"><a href="#函数的属性和方法-length-prototype" class="headerlink" title="函数的属性和方法(.length,.prototype)"></a>函数的属性和方法(.length,.prototype)</h4></li>
<li><p>函数本身也是一种对象,构造函数也是function</p>
<pre><code>funtionName instanceof Object //true
</code></pre></li>
</ul>
<p>语法: object instance of construct</p>
<pre><code>1. object:要检测的对象
2. constructor:某个构造函数
3. instanceof运算符用力啊检测construcor.prototype是否在于参数object的原型链上
</code></pre><ul>
<li>函数有内部属性:arguments,可以在函数内步使用</li>
<li>函数的自身的属性:length,函数定义的形参个数</li>
<li>另外,我们可以自定义函数的其他属性和方法,一般用于全局对象,静态变量,公共存储.</li>
</ul>
<h4 id="函数的递归调用"><a href="#函数的递归调用" class="headerlink" title="函数的递归调用"></a>函数的递归调用</h4><ul>
<li>函数的递归调用就是指:函数调用自身</li>
<li>arguments.callee就是指向函数自身的变量,所以可以直接用它来代替函数名,在匿名函数非常有用.严格模式下会报错</li>
<li>函数表达式方式定义的时候,还可以用命名函数表达式<br>  例如: var f = function s(){}</li>
</ul>
<h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><ul>
<li>函数是javascript的一等公民</li>
<li>一等公民:指的是函数与其他类型一样,处于平等低位,可以赋值给其他变量,也可以作为参数,传入另一个函数,或者作为别的函数的返回值.</li>
<li><p>sort,map,forEach</p>
<pre><code>   t =[47,5,19,23,7]
t.sort(function(a,b){
    return a - b;
})
</code></pre></li>
</ul>
<h5 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h5><ul>
<li>方法接受一个回调函数,回调有三个参数:当前项,索引,操作的数组,不影响原数组,返回新数组.<h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5></li>
<li>没有返回值</li>
</ul>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="垃圾回收的基本知识"><a href="#垃圾回收的基本知识" class="headerlink" title="垃圾回收的基本知识"></a>垃圾回收的基本知识</h4><ul>
<li>javascript具有自动垃圾回收机制(GC:Garbage Collecation),我们不用关心内存申请和回收</li>
<li>垃圾收集器定期找出那些不在继续使用的变量,然后将其释放内存</li>
<li>js最常用的垃圾回收方式就是标记清楚,当变量进入环境,例如,在函数中声明一个变量,将这个变量标记位”进入环境”.从逻辑上讲,永远不能释放进入环境的变量占用的内存,因为只要执行流进入对应的环境,就可能用到,当变量离开环境的时候,将其标记位离开环境,被标记离开环境的变量在下一次垃圾回收启动的时候会被释放掉占用的内存空间.</li>
<li>javascript引擎基础GC方案是:mark and sweep标记清楚,既<ul>
<li>从根对象开始遍历所有可访问的对象</li>
<li>回收已不可访问的对象<h4 id="垃圾回收的应用"><a href="#垃圾回收的应用" class="headerlink" title="垃圾回收的应用"></a>垃圾回收的应用</h4></li>
</ul>
</li>
<li>数组的清零操作<ul>
<li>arr=[],虽然能清空arr数组,但是新建了一个[]空数组对象,最好的方法是:arr.length =0//既可清楚数组内容,还不会额外开辟新内存</li>
<li>对象尽量复用,尤其在循环等地方出现创建新对象,能复用就尽量复用,不用的对象,尽可能的设置位null,尽快被垃圾回收掉</li>
<li>在循环中的函数表达式,能复用最好放到循环外面</li>
</ul>
</li>
</ul>
<h3 id="原型链与闭包"><a href="#原型链与闭包" class="headerlink" title="原型链与闭包"></a>原型链与闭包</h3><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><ul>
<li>函数的原型对象(prototype)</li>
<li>原型对象的构造函数(constructor)</li>
<li>内部原型(<em>proto</em>)</li>
<li>javascript是基于原型的面向对象语言,也就是说所有对象都是基于原型上进行创建,而不像java和C#等是基于一个类型的模板创建</li>
<li>函数都有prototype属性指向函数的原型对象,只有函数根除外</li>
<li>所有的对象都有<em>proto</em>属性,null除外</li>
<li>Object是构造函数,也是对象,Object.prototype是所有对象的根</li>
<li>Function是函数对象的构造函数,Fcuntion的原型对象是所有函数的根,而它的内部原型是Object的原型对象<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4></li>
<li>函数的作用域</li>
<li>没有块级作用域</li>
<li>闭包的使用</li>
<li>沙箱模式</li>
</ul>
<pre><code>function foo(x) {
    let tmp = 3;//定义了一个局部遍历 tmp
    return function (y) {//把一个函数作为返回值返回
        console.log(x+y+(++tmp)) 
    }
}
//调用foo方法执行,并把返回的函数赋给了bar变量
var bar = foo(2) //此时bar指向了匿名函数 , bar是一个闭包, 函数 + x + tmp  ;
bar(10) // 2 + 10 + 4 = 16
bar(20) //20 +2 +5 = 27
</code></pre><ul>
<li><p>匿名自执行函数—-防止污染全局变量–模拟块级作用域</p>
<pre><code>;(function(a){
    console.log(a)
})(8)  //8
</code></pre></li>
<li><p>循环注册dom事件中的index</p>
</li>
</ul>
<pre><code>//循环注册事件的index的典型错误
for(var i=0;i&lt;lis.lenght;i++){
    lis[i].click = function (e) {//事件的方法执行是:当事件触发的时候执行
        //变量i是父函数里面的变量
        console.log(i)//把当前的索引的值打印出来
    }
} // i=5

//解决方法
//把循环注册事件做成自执行函数来传递变量i
for(var i=0;i&lt;lis.length;i++){
    (function(a){
        lis[a].click = function (e) {
            console.log(a)
        }
    })(i)
}//0,1,2,3...
</code></pre><ul>
<li><p>setTimeOut中的闭包应用</p>
<pre><code>//bom的一个方法,接受两个参数:第一个函数是回调函数;第二个参数是经过的毫秒数
setTimeout(function(){
    //当10000毫秒之后,执行当前的函数体
    console.log(10)
},1000)

for(var i =0;i&lt;10;i++){
    setTimeout(function(){
        console.log(i) //输出都是为0
    },1000)
}
//解决方式:自执行函数
for(var i =0;i&lt;10;i++){
    (function(a){
        setTimeout(function(){
            console.log(a) //输出都是为0
        },1000)
    })(i)
}
</code></pre></li>
<li><p>闭包的缺点</p>
<ol>
<li>闭包会导致js执行效率下降</li>
<li>闭包导致内存驻留,大量对象的闭包注意内存消耗</li>
</ol>
</li>
</ul>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="面向对象的概念"><a href="#面向对象的概念" class="headerlink" title="面向对象的概念"></a>面向对象的概念</h4><ul>
<li>面向对象就是一种思考问题和组织代码的方式</li>
<li>把任何的数据和行为抽象成一个形象的对象,类似人生活中思考的方式就是面向对象</li>
<li>继承:相类似的对象进行公共抽象,并公共复用就是继承<h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><h5 id="对象属性和行为复用"><a href="#对象属性和行为复用" class="headerlink" title="对象属性和行为复用"></a>对象属性和行为复用</h5></li>
<li>工厂的方式创建对象<ul>
<li>优点:可以进行批量的创建都有公共默认值和属性的对象</li>
<li>缺点:对象的方法不能跟其他对象共享,占用内存,不能识别对象的原型以及构造函数</li>
</ul>
</li>
</ul>
<pre><code>//工厂模式创建对象
function createCat(age,name){
    var o = new Object()
    o.age = age,
    o.name = name
    o.run = function () {
        console.log(o.name + &apos;running&apos;)
    }
    return o;
}
var c = createCat(19,&apos;d&apos;)
</code></pre><ul>
<li><p>构造函数创建对象</p>
<ol>
<li><p>优点:</p>
<ul>
<li>所有创建出来的对象,都可以找到它的原型和构造函数</li>
<li>公共的属性和方法也可以在创建的时候统一创建和维护</li>
</ul>
</li>
<li><p>缺点:</p>
<ol>
<li><p>对象的函数,每个对象都会拥有一份内存拷贝,浪费内存</p>
<pre><code>//构造函数创建对象模式
function Cat(age,name) {
    this.age = age
    this.name = name
    this.run =function(){
        console.loh(this.name + &apos;running&apos;)
    }
    //当使用new来调用构造函数时
    //1 创建一个空对象
    //2 把空对象赋值给this
    //3 执行构造函数的里面代码的时候,给this的属性做赋值初始化
    //4 把新创建的对象返回(如果有返回值,返回是简单类型会直接忽略,如果是引用类型,指返回引用类型)
}
var c = new Cat(19,&apos;d&apos;)
c.age =20 //修改对象的属性值
c.run()
c instanceof Cat//true
c.constructor === Cat
</code></pre></li>
</ol>
</li>
</ol>
</li>
</ul>
<p>使用构造函数的主要问题,就是每个方法毒药在每个实例上重新创建一遍,对于不同的对象实例都有run的方法,但是不同实例上的同名函数是步相等的.<br>创建两个完成同样的function的确没有必要,可以通过函数定义转移到构造函数外部解决这个问题</p>
<pre><code>function Cat(age,name) {
    this.age = age
    this.name = name
    this.run = run
}
function run() {
     console.log(this.name)
}
</code></pre><p>这种方法的两个cat实例对象共享了全局作用域中定义的同一个run方法,这样的确两个函数调用做同一件的问题,但是新问题:在全局作用域中定义的函数实际上只能被某个对象调用,者让全局作用域名不副实,另外,如果对象需要定义很多方法,那么就要定义很多全局函数,那么就没有封装性可言了,者就是原型链模式产生的原因</p>
<ul>
<li><p>原型创建对象</p>
<ul>
<li>原型动态性</li>
<li>赋值新对象的原型创建方式以及constructor处理</li>
<li>优点:所有原型上的属性和方法在所有的新对象中可以进行共享</li>
<li><p>缺点:如果对象需要自己特有的属性值,不与其他对象共享,则必须跟构造函数模式来配合进行</p>
<pre><code>//原型构建模式
function Cat() {
   this.age = 19
   //如果需要共享的方法和属性一般放到原型中定义 
}
Cat.prototype.run = function () {
    console.log(this.name,this.age)
}
Cat.prototype.name = &apos;black cat&apos;

var c1 = new Cat()
var c2 = new Cat()

c1.name = &apos;rw&apos;
console.log(c1.name)// rw---来自实例
console.log(c2.name)//black cat ----来自原型
</code></pre></li>
</ul>
</li>
</ul>
<p>问题:私有属性每个对象独有的</p>
<ul>
<li><p>混合模式:原型+构造函数(经典组合模式)</p>
<ol>
<li>公共的属性和方法放到原型上,独有的属性使用构造函数模式,放到对象自己身上</li>
<li><p>优点:既可保证了方法等共享的属性只在内存中保存一份,节省内存,又可以实现每个对象有自己单独存放的属性,是一种京东构建对象的方法</p>
<pre><code>function Cat(age,name) {
    this.age = age //每个对象有自己的属性,放到构造函数中
    this.name = name
}
//一般类型的方法,放到原型上
Cat.prototype.run = function () {
    console.log(this.name + &apos;running&apos;)
}
var c1 = new Cat(19,&apos;d&apos;)
var c2 = new Cat(20,&apos;c&apos;)
c1.run === c2.run //true
</code></pre><h5 id="ES6中的表现"><a href="#ES6中的表现" class="headerlink" title="ES6中的表现"></a>ES6中的表现</h5><p>class Point {<br>constructor(){<br> // …<br>}</p>
<p>toString(){<br> // …<br>}</p>
<p>toValue(){<br> // …<br>}<br>}</p>
<p>// 等同于</p>
<p>Point.prototype = {<br>toString(){},<br>toValue(){}<br>};<br>class B {}<br>let b = new B();</p>
<p>b.constructor === B.prototype.constructor // true</p>
</li>
</ol>
</li>
</ul>
<ul>
<li>寄生构造函数模式</li>
<li><p>稳妥构造函数模式</p>
<pre><code>function Persion(age,name){
    var o = {}
    o.age = age,
    o.name = name
    o.run = function () {
        console.log(o.name + &apos;runing&apos;)
    }
    return o
    //当构造函数有返回值的时候,如果是简单类型会直接忽略
    //如果是引用类型,直接适应引用类型替换掉新对象
}
var c1 = new Persion()
var c2 = Persion() //不适应new也可以创建对象

优点: 可以共享属性和方法的初始化代码,无论是否用了new还是没有适应new都
可以返回对象
缺点:无法追溯对象的原型和构造函数,默认没有公共的属性和方法,内存浪费
</code></pre><h4 id="面向对象继承"><a href="#面向对象继承" class="headerlink" title="面向对象继承"></a>面向对象继承</h4><h5 id="原型继承方式"><a href="#原型继承方式" class="headerlink" title="原型继承方式"></a>原型继承方式</h5><pre><code>//在动物基类的原型上添加run方法
Animal.prototype.run = function () {
    console.log(this.name + &apos;running&apos;)
}
function Cat(age,name){
    this.age = age
    this.name = name
}
//原型继承方式
//Cat.prototype.constaructor === Cat
Cat.prototype = new Animal()
Cat.prototype.constaructor = Cat
var c = new Cat(19,&apos;s&apos;) //希望cat继承animal的属性和方法
c.run()

//问题:子类的构造函数的参数无法传递给父类的构造函数
//子类原型的constructor会被改变.需要自己改变
</code></pre><h5 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h5><h5 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h5><pre><code>function Animal(age,name){
    this.age = age
    this.name = name
    this.foods = [&apos;水&apos;,&apos;苹果&apos;]
}
//父类的原型上创建一个run方法
Animal.prototype.run = function(){
    console.log(this.name + &apos;running&apos;)
}
//定义子类
function Cat(age,name){
    //Animal(age,name)  this === window 函数执行模式
    // this === c
    Animal.call(this,age,name)
} 
Cat.prototype = new Animal()//组合原型继承模式 //怎么去掉new
Cat.prototype.constructor = Cat
var c = new Cat(19,&apos;ddd&apos;)
</code></pre><h5 id="原型方法继承"><a href="#原型方法继承" class="headerlink" title="原型方法继承"></a>原型方法继承</h5></li>
<li>原型式继承是避免调用父类函数的一种巧妙的方式,本质就是借用对象来构造另外一个对象</li>
<li>缺点:原型对象上的引用类型的属性会造成子类对象机械能共享</li>
<li><p>//o 就是要借用的对象</p>
<pre><code>function object(o){
    function F(){
        F.prototype = o //让空函数的原型指向o对象
        return new F() //创建一个f实例,f的内部原型指向o对象
    }
}

var m = {age=19,name:&apos;ccc&apos;}
var m1 = object(m)
console.log(m1.age)
</code></pre><h5 id="寄生继承方式"><a href="#寄生继承方式" class="headerlink" title="寄生继承方式"></a>寄生继承方式</h5><pre><code>function object(o){
    function F(){
        F.prototype = o //让空函数的原型指向o对象
        return new F() //创建一个f实例,f的内部原型指向o对象
    }
}

function createPersion(p){
    var o = object(p)
    o.say = function () {
        console.log(&apos;qqq&apos;)
    }
    return o
}
</code></pre><h5 id="终极方式-寄生组合方式"><a href="#终极方式-寄生组合方式" class="headerlink" title="终极方式:寄生组合方式"></a>终极方式:寄生组合方式</h5><p>  function Animal(age,name){</p>
<pre><code>this.age = age
this.name = name
this.foods = [&apos;水&apos;,&apos;苹果&apos;]
</code></pre><p>  }<br>  //父类原型上的方法,通过寄生继承的方式进行继承<br>  Animal.prototype.run = function () {</p>
<pre><code>console.log(this.name + &apos;running&apos;)
</code></pre><p>  }<br>  function Cat(age,name){</p>
<pre><code>//借用构造函数继承来创建实例属性
Animal.call(this,age,name)
</code></pre><p>  }<br>  Cat.prototype = inheritFrom(Animal.prototype)<br>  function inheritFrom(o){</p>
<pre><code>var t = object(o)
t.constructor = Cat
return t;
</code></pre><p>  }<br>  function object(o) {</p>
<pre><code>function F(){
    F.prototype = o
    return new F()
}
</code></pre><p>  }<br>  var c = new Cat(19,’ddd’)</p>
</li>
</ul>
<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><ul>
<li>javaScript中并没有私有变量的概念,但是可以通过模拟,所谓的私有变量:对象的某个只能通过对象的方法进行访问,不能直接通过对象进行访问.</li>
<li>构造函数模拟私有变量的方式</li>
</ul>
<ol>
<li>第一种模拟私有变量</li>
</ol>
<pre><code>function Persion(){
    var age = 0
    this.getAge = function(){
        return age
    }
    this.setAge = function (a) {
        age = a
    }
}
</code></pre><ol start="2">
<li><p>第二种模拟私有变量</p>
<pre><code>function Persion(){
    var age = 0
    return {
    getAge:function(){
        return age
    },
    setAge:function (a) {
        age = a
    }
  }
}
</code></pre></li>
</ol>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul>
<li><p>什么是正则表达式?</p>
<p>  用于匹配字符串规律的表达式.正则表达式是对字符串操作的一种逻辑公式,就是用事先定义好的一些特定字符以及这些特定字符的组合,组成一个”规定字符串”,这个”规定字符串”用来表达对字符串的一种过滤逻辑</p>
</li>
<li>正则表达式的用途<ul>
<li>给定的字符串是否符合正则表达式的过滤逻辑</li>
<li>可以通过正则表达式,从字符串种获取想要的特定部分</li>
<li>强大的字符串替换能力</li>
</ul>
</li>
</ul>
<p>具体规则查看正则表达式的章节</p>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/07/扫描文件价生成指定格式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/扫描文件价生成指定格式/" itemprop="url">
                  扫描文件夹生成指定格式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-07 17:10:50 / 修改时间：17:21:26" itemprop="dateCreated datePublished" datetime="2018-12-07T17:10:50+08:00">2018-12-07</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/electron/" itemprop="url" rel="index"><span itemprop="name">electron</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="扫描文件夹生成指定格式"><a href="#扫描文件夹生成指定格式" class="headerlink" title="扫描文件夹生成指定格式"></a>扫描文件夹生成指定格式</h3><p>最近在做本地系统,需要对本地文件夹进行扫描生成树的格式看到一个插件非常不错</p>
<p>github地址:<a href="https://github.com/Lemonreds/folder2some" target="_blank" rel="noopener">https://github.com/Lemonreds/folder2some</a></p>
<pre><code>#### 源码

/**
 * 2018-4-3
 */
const fs = require(&apos;fs&apos;),
    path = require(&apos;path&apos;)


const defaults = {
    ignore: [],
    generateFile: false
}
class Folder2some {

    constructor(dir, options) {
        this.dir = dir
        this.options = Object.assign(defaults, options)
        this.files = null
    }

    toTree() {

        let tree = &apos;&apos;
        let read = (dir, space = &apos; &apos;) =&gt; {

            let files = fs.readdirSync(dir),
                len = files.length

            files.sort((a, b) =&gt; {
                let s = fs.statSync(path.resolve(dir, a))
                if (s.isDirectory()) {
                    return -1
                }
                return 1
            })

            files.forEach((file, idx) =&gt; {

                if (this._isIgnore(file)) {
                    return
                }

                let stat, sign
                idx === len - 1 ? sign = &apos;└─&apos; : sign = &apos;├─&apos;

                tree = tree + space.replace(&apos;|&apos;, &apos;&apos;) + sign + file + &apos;\n&apos;


                stat = fs.statSync(path.resolve(dir, file))

                if (stat.isDirectory()) {
                    read(path.resolve(dir, file), space + &apos;│&apos; + &apos; &apos;)
                }
            })
        }

        read(this.dir)
        this._makeFile(tree, &apos;_tree.txt&apos;)
        return tree
    }

    toJSON() {

        let read = (dir, container) =&gt; {

            let files = fs.readdirSync(dir),
                stat

            files.forEach(file =&gt; {

                if (this._isIgnore(file)) {
                    return
                }

                stat = fs.statSync(path.resolve(dir, file))

                if (stat.isFile()) {
                    container.push(file)
                } else {

                    let directory = {
                        [file]: []
                    }
                    container.push(directory)
                    read(path.resolve(dir, file), directory[file])
                }
            })
        }

        let ft = []
        read(this.dir, ft)
        this._makeFile(ft, &apos;_json.txt&apos;, true)
        return JSON.stringify(ft, null, 2)
    }

    toAnalysis() {

        let datas = this._toData(this.dir),
            totalSize = 0,
            totalCount = 0,
            extPercent = []

        for (let i = 0; i &lt; datas.length; i++) {
            totalSize += datas[i].size
            totalCount += datas[i].count
        }

        for (let j = 0; j &lt; datas.length; j++) {

            extPercent.push({
                ext: datas[j].ext,
                percent: ((datas[j].size / totalSize) * 100).toFixed(2),
                count: datas[j].count
            })
        }

        let analysis = JSON.stringify({
            path: this.dir,
            totalSize: (totalSize / 1024).toFixed(2) + &apos;KB&apos;, //B =&gt; KB
            totalCount: totalCount,
            extPercent: extPercent
        }, null, 2);

        this._makeFile(analysis, &apos;_analysis.txt&apos;)
        return analysis

    }
    _toData() {

        let datas = []
        let read = dir =&gt; {

            let files = fs.readdirSync(dir),
                stat

            files.forEach(file =&gt; {

                if (this._isIgnore(file)) {
                    return
                }

                stat = fs.statSync(path.resolve(dir, file))
                if (stat.isFile()) {

                    let i = 0,
                        isExist = false,
                        ext = file.substring(file.lastIndexOf(&apos;.&apos;), file.length),
                        size = stat.size


                    for (; i &lt; datas.length; i++) {

                        if (datas[i].ext === ext) {
                            datas[i].size += size
                            datas[i].count++
                                isExist = true
                            break
                        }
                    }

                    if (!isExist) {
                        datas.push({
                            ext: ext,
                            size: size,
                            count: 1
                        })
                    }


                } else {
                    read(path.resolve(dir, file))
                }
            })
        }
        read(this.dir)
        return datas
    }



    _makeFile(data, filename, toJson = false) {

        if (this.options.generateFile) {
            fs.writeFileSync(filename,
                toJson ? JSON.stringify(data, null, 2) : data)
        }
    }

    _isIgnore(file) {
        for (let ig of this.options.ignore) {
            if (typeof file === &apos;string&apos; &amp;&amp; file.toLowerCase() === ig.toLowerCase()) {
                return true
            }
        }
        return false
    }
}


module.exports = Folder2some
</code></pre><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式:"></a>使用方式:</h4><pre><code>let FT = require(&apos;./index&apos;),
    dir = &apos;./&apos;;

let ft = new FT(dir,{ 
    ignore: [&apos;node_modules&apos;,&apos;.git&apos;],
    generateFile: true
})

console.log(ft.toTree())
console.log(ft.toJSON())
console.log(ft.toAnalysis())
</code></pre><h4 id="另外一种"><a href="#另外一种" class="headerlink" title="另外一种"></a>另外一种</h4><pre><code>var fs = require(&apos;fs&apos;)


//遍历文件夹，获取所有文件夹里面的文件信息
/*
 * @param path 路径
 *
 */

function geFileList(path)
{
   var filesList = [];
   var targetObj = {};
   readFile(path,filesList,targetObj);
   return filesList;
}

//遍历读取文件
function readFile(path,filesList,targetObj)
{
   files = fs.readdirSync(path);//需要用到同步读取
   files.forEach(walk);
   function walk(file)
   {  
        states = fs.statSync(path+&apos;/&apos;+file);         
        if(states.isDirectory())
        {
            var item ;
            if(targetObj[&quot;children&quot;])
            {
                item = {name:file,children:[]};
                targetObj[&quot;children&quot;].push(item);
            }
            else
            {
               item = {name:file,children:[]};
               filesList.push(item);
            }

            readFile(path+&apos;/&apos;+file,filesList,item);
        }
        else
        {   
            //创建一个对象保存信息
            var obj = new Object();
            obj.size = states.size;//文件大小，以字节为单位
            obj.name = file;//文件名
            obj.path = path+&apos;/&apos;+file; //文件绝对路径

            if(targetObj[&quot;children&quot;])
            {
               var item = {name:file,value:obj.path}
               targetObj[&quot;children&quot;].push(item);
            }
            else
            {
                var item = {name:file,value:obj.path};
                filesList.push(item);
            }
        }     
    }
}

//写入文件utf-8格式
function writeFile(fileName,data)
{  
  fs.writeFile(fileName,data,&apos;utf-8&apos;,complete);
  function complete()
  {
     console.log(&quot;文件生成成功&quot;);
  } 
}


var filesList = geFileList(&quot;D:/Program Files/Egret/EgretEngine/win/egret/src&quot;);
var str = JSON.stringify(filesList);
str = &quot;var data ={name:&apos;Egret&apos;,children:#1}&quot;.replace(&quot;#1&quot;,str);
writeFile(&quot;tree.js&quot;,str);
</code></pre><p>原文：<a href="https://blog.csdn.net/hero82748274/article/" target="_blank" rel="noopener">https://blog.csdn.net/hero82748274/article/</a></p>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/07/web应用启动外部exe程序/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/web应用启动外部exe程序/" itemprop="url">
                  web应用启动外部exe程序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-07 10:21:14 / 修改时间：10:30:13" itemprop="dateCreated datePublished" datetime="2018-12-07T10:21:14+08:00">2018-12-07</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/electron/" itemprop="url" rel="index"><span itemprop="name">electron</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="web应用启动外部exe程序"><a href="#web应用启动外部exe程序" class="headerlink" title="web应用启动外部exe程序"></a>web应用启动外部exe程序</h3><p>有时候，需要在网页上去执行本地的一个EXE文件,但是采用js通常对大部分浏览器不支持,所以采用写注册表是一个比较好的解决方案</p>
<h4 id="url-protocol方式"><a href="#url-protocol方式" class="headerlink" title="url protocol方式"></a>url protocol方式</h4><p>在网页上点击的时候，就会弹出QQ，或者迅雷，电驴的下载界面，用的就是这个原理.</p>
<pre><code>Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\注册表名字]
@=&quot;注册表名字 Protocol&quot;
&quot;URL Protocol&quot;=&quot;&quot;

[HKEY_CLASSES_ROOT\注册表名字\DefaultIcon]
@=&quot;C:\\你的程序安装路径\\程序名字.exe&quot;

[HKEY_CLASSES_ROOT\注册表名字\shell]
@=&quot;&quot;

[HKEY_CLASSES_ROOT\注册表名字\shell\open]
@=&quot;&quot;

[HKEY_CLASSES_ROOT\注册表名字\shell\open\command]
@=&quot;\&quot;C:\\你的程序安装路径\\程序名字.exe\&quot; &quot;
</code></pre><h4 id="html代码"><a href="#html代码" class="headerlink" title="html代码"></a>html代码</h4><pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
  &lt;head&gt;
      &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;/head&gt;
    &lt;body&gt;
        &lt;div&gt;
            &lt;a href=&quot;刚才你写的注册表名称://&quot;&gt;
            执行可执行文件
            &lt;/a&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/vue中keep-alive组件的作用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/vue中keep-alive组件的作用/" itemprop="url">
                  vue中keep-alive组件的作用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-05 15:12:34 / 修改时间：15:18:37" itemprop="dateCreated datePublished" datetime="2018-12-05T15:12:34+08:00">2018-12-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="vue中keep-alive组件的作用"><a href="#vue中keep-alive组件的作用" class="headerlink" title="vue中keep-alive组件的作用"></a>vue中keep-alive组件的作用</h3><p>内容来源: <a href="https://www.kancloud.cn/hanxuming/vue-iq/" target="_blank" rel="noopener">https://www.kancloud.cn/hanxuming/vue-iq/</a></p>
<p>keep-alive:主要用于保存组件状态或避免重新渲染<br>比如: 有一个列表页面和一个 详情页面，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情这样的话 列表 和 详情 都是一个频率很高的页面，那么就可以对列表组件使用<keep-alive></keep-alive>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><pre><code>include:字符串或正则表达式。只有匹配的组件会被缓存。

exclude：字符串或正则表达式。任何匹配的组件都不会被缓存。
</code></pre><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><pre><code>&lt;!-- 基本 --&gt;
&lt;keep-alive&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;

&lt;!-- 多个条件判断的子组件 --&gt;
&lt;keep-alive&gt;
  &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt;
  &lt;comp-b v-else&gt;&lt;/comp-b&gt;
&lt;/keep-alive&gt;

&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;
&lt;transition&gt;
  &lt;keep-alive&gt;
    &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
  &lt;/keep-alive&gt;
&lt;/transition&gt;
</code></pre><h4 id="include和exclude属性的使用"><a href="#include和exclude属性的使用" class="headerlink" title="include和exclude属性的使用"></a>include和exclude属性的使用</h4><p>include 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：</p>
<pre><code>&lt;!-- 逗号分隔字符串 --&gt;
&lt;keep-alive include=&quot;a,b&quot;&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;

&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;
&lt;keep-alive :include=&quot;/a|b/&quot;&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;

&lt;!-- 数组 (使用 `v-bind`) --&gt;
&lt;keep-alive :include=&quot;[&apos;a&apos;, &apos;b&apos;]&quot;&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/04/前端性能优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/04/前端性能优化/" itemprop="url">
                  前端性能优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-04 16:48:18 / 修改时间：17:26:41" itemprop="dateCreated datePublished" datetime="2018-12-04T16:48:18+08:00">2018-12-04</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/HTML/" itemprop="url" rel="index"><span itemprop="name">HTML</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h2><h3 id="网络层面"><a href="#网络层面" class="headerlink" title="网络层面"></a>网络层面</h3><h4 id="请求过程优化"><a href="#请求过程优化" class="headerlink" title="请求过程优化"></a>请求过程优化</h4><h5 id="HTTP请求优化"><a href="#HTTP请求优化" class="headerlink" title="HTTP请求优化"></a>HTTP请求优化</h5><h6 id="构建工具性能优化"><a href="#构建工具性能优化" class="headerlink" title="构建工具性能优化"></a>构建工具性能优化</h6><h6 id="Gzip压缩原理"><a href="#Gzip压缩原理" class="headerlink" title="Gzip压缩原理"></a>Gzip压缩原理</h6><h6 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h6><h4 id="减少网络请求"><a href="#减少网络请求" class="headerlink" title="减少网络请求"></a>减少网络请求</h4><h5 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h5><h6 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h6><h6 id="离线存储技术"><a href="#离线存储技术" class="headerlink" title="离线存储技术"></a>离线存储技术</h6><h3 id="渲染层面"><a href="#渲染层面" class="headerlink" title="渲染层面"></a>渲染层面</h3><h4 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h4><h4 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h4><h5 id="CSS性能优化"><a href="#CSS性能优化" class="headerlink" title="CSS性能优化"></a>CSS性能优化</h5><h5 id="js性能优化"><a href="#js性能优化" class="headerlink" title="js性能优化"></a>js性能优化</h5><h4 id="DOM优化"><a href="#DOM优化" class="headerlink" title="DOM优化"></a>DOM优化</h4><h5 id="事件循环与异步更新"><a href="#事件循环与异步更新" class="headerlink" title="事件循环与异步更新"></a>事件循环与异步更新</h5><h5 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h5><h4 id="首屏渲染提速"><a href="#首屏渲染提速" class="headerlink" title="首屏渲染提速"></a>首屏渲染提速</h4><h5 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h5>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/30/electron实现下载进度条/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/30/electron实现下载进度条/" itemprop="url">
                  electron实现下载进度条
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-30 14:07:54 / 修改时间：14:10:34" itemprop="dateCreated datePublished" datetime="2018-11-30T14:07:54+08:00">2018-11-30</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/electron/" itemprop="url" rel="index"><span itemprop="name">electron</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="electron下载进度条"><a href="#electron下载进度条" class="headerlink" title="electron下载进度条"></a>electron下载进度条</h3><pre><code>通过 Electron 中 will-download 事件

mainWindow.webContents.session.on(&apos;will-download&apos;, (e, item) =&gt; {
    //获取文件的总大小
   const totalBytes = item.getTotalBytes();

    //设置文件的保存路径，此时默认弹出的 save dialog 将被覆盖
   const filePath = path.join(app.getPath(&apos;downloads&apos;), item.getFilename());
   item.setSavePath(filePath);

    //监听下载过程，计算并设置进度条进度
   item.on(&apos;updated&apos;, () =&gt; {
       mainWindow.setProgressBar(item.getReceivedBytes() / totalBytes);
   });

    //监听下载结束事件
   item.on(&apos;done&apos;, (e, state) =&gt; {
           //如果窗口还在的话，去掉进度条
       if (!mainWindow.isDestroyed()) {
           mainWindow.setProgressBar(-1);
       }

        //下载被取消或中断了
       if (state === &apos;interrupted&apos;) {
           electron.dialog.showErrorBox(&apos;下载失败&apos;, `文件 ${item.getFilename()} 因为某些原因被中断下载`);
       }

        //下载完成，让 dock 上的下载目录Q弹一下下
       if (state === &apos;completed&apos;) {
           app.dock.downloadFinished(filePath);
       }
   });
});
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/30/基础算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/30/基础算法/" itemprop="url">
                  基础算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-30 10:14:11 / 修改时间：13:41:16" itemprop="dateCreated datePublished" datetime="2018-11-30T10:14:11+08:00">2018-11-30</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基础算法-经典排序算法"><a href="#基础算法-经典排序算法" class="headerlink" title="基础算法-经典排序算法"></a>基础算法-经典排序算法</h3><p>主要在网上找的一些资源便与归纳学习</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
<h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p>
</li>
<li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>
</li>
<li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
</li>
</ol>
<h5 id="javacript实现"><a href="#javacript实现" class="headerlink" title="javacript实现"></a>javacript实现</h5><pre><code>function quickSort(arr, left, right) {
    var len = arr.length,
        partitionIndex,
        left = typeof left != &apos;number&apos; ? 0 : left,
        right = typeof right != &apos;number&apos; ? len - 1 : right;

    if (left &lt; right) {
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex-1);
        quickSort(arr, partitionIndex+1, right);
    }
    return arr;
}

function partition(arr, left ,right) {     // 分区操作
    var pivot = left,                      // 设定基准值（pivot）
        index = pivot + 1;
    for (var i = index; i &lt;= right; i++) {
        if (arr[i] &lt; arr[pivot]) {
            swap(arr, i, index);
            index++;
        }        
    }
    swap(arr, pivot, index - 1);
    return index-1;
}

function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
function partition2(arr, low, high) {
  let pivot = arr[low];
  while (low &lt; high) {
    while (low &lt; high &amp;&amp; arr[high] &gt; pivot) {
      --high;
    }
    arr[low] = arr[high];
    while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) {
      ++low;
    }
    arr[high] = arr[low];
  }
  arr[low] = pivot;
  return low;
}

function quickSort2(arr, low, high) {
  if (low &lt; high) {
    let pivot = partition2(arr, low, high);
    quickSort2(arr, low, pivot - 1);
    quickSort2(arr, pivot + 1, high);
  }
  return arr;
}
</code></pre><h5 id="go实现"><a href="#go实现" class="headerlink" title="go实现"></a>go实现</h5><pre><code>func quickSort(arr []int) []int {
    return _quickSort(arr, 0, len(arr)-1)
}

func _quickSort(arr []int, left, right int) []int {
    if left &lt; right {
        partitionIndex := partition(arr, left, right)
        _quickSort(arr, left, partitionIndex-1)
        _quickSort(arr, partitionIndex+1, right)
    }
    return arr
}

func partition(arr []int, left, right int) int {
    pivot := left
    index := pivot + 1

    for i := index; i &lt;= right; i++ {
        if arr[i] &lt; arr[pivot] {
            swap(arr, i, index)
            index += 1
        }
    }
    swap(arr, pivot, index-1)
    return index - 1
}

func swap(arr []int, i, j int) {
    arr[i], arr[j] = arr[j], arr[i]
}
</code></pre><h5 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h5><pre><code>def quickSort(arr, left=None, right=None):
    left = 0 if not isinstance(left,(int, float)) else left
    right = len(arr)-1 if not isinstance(right,(int, float)) else right
    if left &lt; right:
        partitionIndex = partition(arr, left, right)
        quickSort(arr, left, partitionIndex-1)
        quickSort(arr, partitionIndex+1, right)
    return arr

def partition(arr, left, right):
    pivot = left
    index = pivot+1
    i = index
    while  i &lt;= right:
        if arr[i] &lt; arr[pivot]:
            swap(arr, i, index)
            index+=1
        i+=1
    swap(arr,pivot,index-1)
    return index-1

def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]
</code></pre><h5 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class QuickSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        return quickSort(arr, 0, arr.length - 1);
    }

    private int[] quickSort(int[] arr, int left, int right) {
        if (left &lt; right) {
            int partitionIndex = partition(arr, left, right);
            quickSort(arr, left, partitionIndex - 1);
            quickSort(arr, partitionIndex + 1, right);
        }
        return arr;
    }

    private int partition(int[] arr, int left, int right) {
        // 设定基准值（pivot）
        int pivot = left;
        int index = pivot + 1;
        for (int i = index; i &lt;= right; i++) {
            if (arr[i] &lt; arr[pivot]) {
                swap(arr, i, index);
                index++;
            }
        }
        swap(arr, pivot, index - 1);
        return index - 1;
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

}
</code></pre><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p>
<h5 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p>
</li>
<li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p>
</li>
<li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p>
</li>
<li><p>重复步骤 3 直到某一指针达到序列尾；</p>
</li>
<li><p>将另一序列剩下的所有元素直接复制到合并序列尾</p>
</li>
</ol>
<h5 id="javascript实现"><a href="#javascript实现" class="headerlink" title="javascript实现"></a>javascript实现</h5><pre><code>function mergeSort(arr) {  // 采用自上而下的递归方法
    var len = arr.length;
    if(len &lt; 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right)
{
    var result = [];

    while (left.length &amp;&amp; right.length) {
        if (left[0] &lt;= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());

    return result;
}
</code></pre><h5 id="python实现-1"><a href="#python实现-1" class="headerlink" title="python实现"></a>python实现</h5><pre><code>def mergeSort(arr):
    import math
    if(len(arr)&lt;2):
        return arr
    middle = math.floor(len(arr)/2)
    left, right = arr[0:middle], arr[middle:]
    return merge(mergeSort(left), mergeSort(right))

def merge(left,right):
    result = []
    while left and right:
        if left[0] &lt;= right[0]:
            result.append(left.pop(0));
        else:
            result.append(right.pop(0));
    while left:
        result.append(left.pop(0));
    while right:
        result.append(right.pop(0));
    return result
</code></pre><h5 id="golang实现"><a href="#golang实现" class="headerlink" title="golang实现"></a>golang实现</h5><pre><code>func mergeSort(arr []int) []int {
    length := len(arr)
    if length &lt; 2 {
        return arr
    }
    middle := length / 2
    left := arr[0:middle]
    right := arr[middle:]
    return merge(mergeSort(left), mergeSort(right))
}

func merge(left []int, right []int) []int {
    var result []int
    for len(left) != 0 &amp;&amp; len(right) != 0 {
        if left[0] &lt;= right[0] {
            result = append(result, left[0])
            left = left[1:]
        } else {
            result = append(result, right[0])
            right = right[1:]
        }
    }

    for len(left) != 0 {
        result = append(result, left[0])
        left = left[1:]
    }

    for len(right) != 0 {
        result = append(result, right[0])
        right = right[1:]
    }

    return result
}
</code></pre><h5 id="java实现-1"><a href="#java实现-1" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class MergeSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        if (arr.length &lt; 2) {
            return arr;
        }
        int middle = (int) Math.floor(arr.length / 2);

        int[] left = Arrays.copyOfRange(arr, 0, middle);
        int[] right = Arrays.copyOfRange(arr, middle, arr.length);

        return merge(sort(left), sort(right));
    }

    protected int[] merge(int[] left, int[] right) {
        int[] result = new int[left.length + right.length];
        int i = 0;
        while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) {
            if (left[0] &lt;= right[0]) {
                result[i++] = left[0];
                left = Arrays.copyOfRange(left, 1, left.length);
            } else {
                result[i++] = right[0];
                right = Arrays.copyOfRange(right, 1, right.length);
            }
        }

        while (left.length &gt; 0) {
            result[i++] = left[0];
            left = Arrays.copyOfRange(left, 1, left.length);
        }

        while (right.length &gt; 0) {
            result[i++] = right[0];
            right = Arrays.copyOfRange(right, 1, right.length);
        }

        return result;
    }

}
</code></pre><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p>
<h5 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
</li>
<li><p>针对所有的元素重复以上的步骤，除了最后一个。</p>
</li>
<li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</p>
</li>
</ol>
<h5 id="javascript实现-1"><a href="#javascript实现-1" class="headerlink" title="javascript实现"></a>javascript实现</h5><pre><code>function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i &lt; len - 1; i++) {
        for (var j = 0; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j+1]) {        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
</code></pre><h5 id="golang实现-1"><a href="#golang实现-1" class="headerlink" title="golang实现"></a>golang实现</h5><pre><code>func bubbleSort(arr []int) []int {
    length := len(arr)
    for i := 0; i &lt; length; i++ {
        for j := 0; j &lt; length-1-i; j++ {
            if arr[j] &gt; arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
    return arr
}
</code></pre><h5 id="python实现-2"><a href="#python实现-2" class="headerlink" title="python实现"></a>python实现</h5><pre><code>def bubbleSort(arr):
    for i in range(1, len(arr)):
        for j in range(0, len(arr)-i):
            if arr[j] &gt; arr[j+1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
</code></pre><h5 id="java实现-2"><a href="#java实现-2" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class BubbleSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        for (int i = 1; i &lt; arr.length; i++) {
            // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。
            boolean flag = true;

            for (int j = 0; j &lt; arr.length - i; j++) {
                if (arr[j] &gt; arr[j + 1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;

                    flag = false;
                }
            }

            if (flag) {
                break;
            }
        }
        return arr;
    }
}
</code></pre><h5 id="golang实现-2"><a href="#golang实现-2" class="headerlink" title="golang实现"></a>golang实现</h5><pre><code>func bubbleSort(arr []int) []int {
    length := len(arr)
    for i := 0; i &lt; length; i++ {
        for j := 0; j &lt; length-1-i; j++ {
            if arr[j] &gt; arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
    return arr
}
</code></pre><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h5 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p>
</li>
<li><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
</li>
</ol>
<p>3 .重复第二步，直到所有元素均排序完毕。</p>
<h5 id="javascript实现-2"><a href="#javascript实现-2" class="headerlink" title="javascript实现"></a>javascript实现</h5><pre><code>function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) {
            if (arr[j] &lt; arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}
</code></pre><h5 id="python实现-3"><a href="#python实现-3" class="headerlink" title="python实现"></a>python实现</h5><pre><code>def selectionSort(arr):
    for i in range(len(arr) - 1):
        # 记录最小数的索引
        minIndex = i
        for j in range(i + 1, len(arr)):
            if arr[j] &lt; arr[minIndex]:
                minIndex = j
        # i 不是最小数时，将 i 和最小数进行交换
        if i != minIndex:
            arr[i], arr[minIndex] = arr[minIndex], arr[i]
    return arr
</code></pre><h5 id="golang实现-3"><a href="#golang实现-3" class="headerlink" title="golang实现"></a>golang实现</h5><pre><code>func selectionSort(arr []int) []int {
    length := len(arr)
    for i := 0; i &lt; length-1; i++ {
        min := i
        for j := i + 1; j &lt; length; j++ {
            if arr[min] &gt; arr[j] {
                min = j
            }
        }
        arr[i], arr[min] = arr[min], arr[i]
    }
    return arr
}
</code></pre><h5 id="java实现-3"><a href="#java实现-3" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class SelectionSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        // 总共要经过 N-1 轮比较
        for (int i = 0; i &lt; arr.length - 1; i++) {
            int min = i;

            // 每轮需要比较的次数 N-i
            for (int j = i + 1; j &lt; arr.length; j++) {
                if (arr[j] &lt; arr[min]) {
                    // 记录目前能找到的最小值元素的下标
                    min = j;
                }
            }

            // 将找到的最小值和i位置所在的值进行交换
            if (i != min) {
                int tmp = arr[i];
                arr[i] = arr[min];
                arr[min] = tmp;
            }

        }
        return arr;
    }
}
</code></pre><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h5 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
</li>
<li><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
</li>
</ol>
<h5 id="javascript实现-3"><a href="#javascript实现-3" class="headerlink" title="javascript实现"></a>javascript实现</h5><pre><code>function insertionSort(arr) {
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i &lt; len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) {
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex+1] = current;
    }
    return arr;
}
</code></pre><h5 id="python实现-4"><a href="#python实现-4" class="headerlink" title="python实现"></a>python实现</h5><pre><code>def insertionSort(arr):
    for i in range(len(arr)):
        preIndex = i-1
        current = arr[i]
        while preIndex &gt;= 0 and arr[preIndex] &gt; current:
            arr[preIndex+1] = arr[preIndex]
            preIndex-=1
        arr[preIndex+1] = current
    return arr
</code></pre><h5 id="golang实现-4"><a href="#golang实现-4" class="headerlink" title="golang实现"></a>golang实现</h5><pre><code>func insertionSort(arr []int) []int {
    for i := range arr {
        preIndex := i - 1
        current := arr[i]
        for preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current {
            arr[preIndex+1] = arr[preIndex]
            preIndex -= 1
        }
        arr[preIndex+1] = current
    }
    return arr
}
</code></pre><h5 id="java实现-4"><a href="#java实现-4" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class InsertSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的
        for (int i = 1; i &lt; arr.length; i++) {

            // 记录要插入的数据
            int tmp = arr[i];

            // 从已经排序的序列最右边的开始比较，找到比其小的数
            int j = i;
            while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) {
                arr[j] = arr[j - 1];
                j--;
            }

            // 存在比其小的数，插入
            if (j != i) {
                arr[j] = tmp;
            }

        }
        return arr;
    }
}
</code></pre><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<p>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；<br>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；<br>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><ol>
<li><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p>
</li>
<li><p>按增量序列个数 k，对序列进行 k 趟排序；</p>
</li>
<li><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
</li>
</ol>
<h5 id="javascript实现-4"><a href="#javascript实现-4" class="headerlink" title="javascript实现"></a>javascript实现</h5><pre><code>function shellSort(arr) {
    var len = arr.length,
        temp,
        gap = 1;
    while(gap &lt; len/3) {          //动态定义间隔序列
        gap =gap*3+1;
    }
    for (gap; gap &gt; 0; gap = Math.floor(gap/3)) {
        for (var i = gap; i &lt; len; i++) {
            temp = arr[i];
            for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) {
                arr[j+gap] = arr[j];
            }
            arr[j+gap] = temp;
        }
    }
    return arr;
}
</code></pre><h5 id="python实现-5"><a href="#python实现-5" class="headerlink" title="python实现"></a>python实现</h5><pre><code>def shellSort(arr):
    import math
    gap=1
    while(gap &lt; len(arr)/3):
        gap = gap*3+1
    while gap &gt; 0:
        for i in range(gap,len(arr)):
            temp = arr[i]
            j = i-gap
            while j &gt;=0 and arr[j] &gt; temp:
                arr[j+gap]=arr[j]
                j-=gap
            arr[j+gap] = temp
        gap = math.floor(gap/3)
    return arr
}
</code></pre><h5 id="golang实现-5"><a href="#golang实现-5" class="headerlink" title="golang实现"></a>golang实现</h5><pre><code>func shellSort(arr []int) []int {
    length := len(arr)
    gap := 1
    for gap &lt; gap/3 {
        gap = gap*3 + 1
    }
    for gap &gt; 0 {
        for i := gap; i &lt; length; i++ {
            temp := arr[i]
            j := i - gap
            for j &gt;= 0 &amp;&amp; arr[j] &gt; temp {
                arr[j+gap] = arr[j]
                j -= gap
            }
            arr[j+gap] = temp
        }
        gap = gap / 3
    }
    return arr
}
</code></pre><h5 id="java实现-5"><a href="#java实现-5" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class ShellSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        int gap = 1;
        while (gap &lt; arr.length) {
            gap = gap * 3 + 1;
        }

        while (gap &gt; 0) {
            for (int i = gap; i &lt; arr.length; i++) {
                int tmp = arr[i];
                int j = i - gap;
                while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) {
                    arr[j + gap] = arr[j];
                    j -= gap;
                }
                arr[j + gap] = tmp;
            }
            gap = (int) Math.floor(gap / 3);
        }

        return arr;
    }
}
</code></pre><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；<br>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；<br>堆排序的平均时间复杂度为 Ο(nlogn)。</p>
<h5 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h5><ol>
<li><p>创建一个堆 H[0……n-1]；</p>
</li>
<li><p>把堆首（最大值）和堆尾互换；</p>
</li>
<li><p>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</p>
</li>
<li><p>重复步骤 2，直到堆的尺寸为 1。</p>
</li>
</ol>
<h5 id="javascript实现-5"><a href="#javascript实现-5" class="headerlink" title="javascript实现"></a>javascript实现</h5><pre><code>var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量

function buildMaxHeap(arr) {   // 建立大顶堆
    len = arr.length;
    for (var i = Math.floor(len/2); i &gt;= 0; i--) {
        heapify(arr, i);
    }
}

function heapify(arr, i) {     // 堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;

    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {
        largest = left;
    }

    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {
        largest = right;
    }

    if (largest != i) {
        swap(arr, i, largest);
        heapify(arr, largest);
    }
}

function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

function heapSort(arr) {
    buildMaxHeap(arr);

    for (var i = arr.length-1; i &gt; 0; i--) {
        swap(arr, 0, i);
        len--;
        heapify(arr, 0);
    }
    return arr;
}
</code></pre><h5 id="python实现-6"><a href="#python实现-6" class="headerlink" title="python实现"></a>python实现</h5><pre><code>def buildMaxHeap(arr):
    import math
    for i in range(math.floor(len(arr)/2),-1,-1):
        heapify(arr,i)

def heapify(arr, i):
    left = 2*i+1
    right = 2*i+2
    largest = i
    if left &lt; arrLen and arr[left] &gt; arr[largest]:
        largest = left
    if right &lt; arrLen and arr[right] &gt; arr[largest]:
        largest = right

    if largest != i:
        swap(arr, i, largest)
        heapify(arr, largest)

def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]

def heapSort(arr):
    global arrLen
    arrLen = len(arr)
    buildMaxHeap(arr)
    for i in range(len(arr)-1,0,-1):
        swap(arr,0,i)
        arrLen -=1
        heapify(arr, 0)
    return arr
</code></pre><h5 id="golang实现-6"><a href="#golang实现-6" class="headerlink" title="golang实现"></a>golang实现</h5><pre><code>func heapSort(arr []int) []int {
    arrLen := len(arr)
    buildMaxHeap(arr, arrLen)
    for i := arrLen - 1; i &gt;= 0; i-- {
        swap(arr, 0, i)
        arrLen -= 1
        heapify(arr, 0, arrLen)
    }
    return arr
}

func buildMaxHeap(arr []int, arrLen int) {
    for i := arrLen / 2; i &gt;= 0; i-- {
        heapify(arr, i, arrLen)
    }
}

func heapify(arr []int, i, arrLen int) {
    left := 2*i + 1
    right := 2*i + 2
    largest := i
    if left &lt; arrLen &amp;&amp; arr[left] &gt; arr[largest] {
        largest = left
    }
    if right &lt; arrLen &amp;&amp; arr[right] &gt; arr[largest] {
        largest = right
    }
    if largest != i {
        swap(arr, i, largest)
        heapify(arr, largest, arrLen)
    }
}

func swap(arr []int, i, j int) {
    arr[i], arr[j] = arr[j], arr[i]
}
</code></pre><h5 id="java实现-6"><a href="#java实现-6" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class HeapSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        int len = arr.length;

        buildMaxHeap(arr, len);

        for (int i = len - 1; i &gt; 0; i--) {
            swap(arr, 0, i);
            len--;
            heapify(arr, 0, len);
        }
        return arr;
    }

    private void buildMaxHeap(int[] arr, int len) {
        for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) {
            heapify(arr, i, len);
        }
    }

    private void heapify(int[] arr, int i, int len) {
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        int largest = i;

        if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {
            largest = left;
        }

        if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {
            largest = right;
        }

        if (largest != i) {
            swap(arr, i, largest);
            heapify(arr, largest, len);
        }
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

}
</code></pre><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h5 id="javascript实现-6"><a href="#javascript实现-6" class="headerlink" title="javascript实现"></a>javascript实现</h5><pre><code>function countingSort(arr, maxValue) {
    var bucket = new Array(maxValue+1),
        sortedIndex = 0;
        arrLen = arr.length,
        bucketLen = maxValue + 1;

    for (var i = 0; i &lt; arrLen; i++) {
        if (!bucket[arr[i]]) {
            bucket[arr[i]] = 0;
        }
        bucket[arr[i]]++;
    }

    for (var j = 0; j &lt; bucketLen; j++) {
        while(bucket[j] &gt; 0) {
            arr[sortedIndex++] = j;
            bucket[j]--;
        }
    }

    return arr;
}
</code></pre><h5 id="python实现-7"><a href="#python实现-7" class="headerlink" title="python实现"></a>python实现</h5><pre><code>def countingSort(arr, maxValue):
    bucketLen = maxValue+1
    bucket = [0]*bucketLen
    sortedIndex =0
    arrLen = len(arr)
    for i in range(arrLen):
        if not bucket[arr[i]]:
            bucket[arr[i]]=0
        bucket[arr[i]]+=1
    for j in range(bucketLen):
        while bucket[j]&gt;0:
            arr[sortedIndex] = j
            sortedIndex+=1
            bucket[j]-=1
    return arr
</code></pre><h5 id="golang实现-7"><a href="#golang实现-7" class="headerlink" title="golang实现"></a>golang实现</h5><pre><code>func countingSort(arr []int, maxValue int) []int {
    bucketLen := maxValue + 1
    bucket := make([]int, bucketLen) // 初始为0的数组

    sortedIndex := 0
    length := len(arr)

    for i := 0; i &lt; length; i++ {
        bucket[arr[i]] += 1
    }

    for j := 0; j &lt; bucketLen; j++ {
        for bucket[j] &gt; 0 {
            arr[sortedIndex] = j
            sortedIndex += 1
            bucket[j] -= 1
        }
    }

    return arr
}
</code></pre><h5 id="java实现-7"><a href="#java实现-7" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class CountingSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        int maxValue = getMaxValue(arr);

        return countingSort(arr, maxValue);
    }

    private int[] countingSort(int[] arr, int maxValue) {
        int bucketLen = maxValue + 1;
        int[] bucket = new int[bucketLen];

        for (int value : arr) {
            bucket[value]++;
        }

        int sortedIndex = 0;
        for (int j = 0; j &lt; bucketLen; j++) {
            while (bucket[j] &gt; 0) {
                arr[sortedIndex++] = j;
                bucket[j]--;
            }
        }
        return arr;
    }

    private int getMaxValue(int[] arr) {
        int maxValue = arr[0];
        for (int value : arr) {
            if (maxValue &lt; value) {
                maxValue = value;
            }
        }
        return maxValue;
    }

}
</code></pre><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<p>在额外空间充足的情况下，尽量增大桶的数量<br>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中<br>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<h5 id="javascript实现-7"><a href="#javascript实现-7" class="headerlink" title="javascript实现"></a>javascript实现</h5><pre><code>function bucketSort(arr, bucketSize) {
    if (arr.length === 0) {
      return arr;
    }

    var i;
    var minValue = arr[0];
    var maxValue = arr[0];
    for (i = 1; i &lt; arr.length; i++) {
      if (arr[i] &lt; minValue) {
          minValue = arr[i];                // 输入数据的最小值
      } else if (arr[i] &gt; maxValue) {
          maxValue = arr[i];                // 输入数据的最大值
      }
    }

    //桶的初始化
    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5
    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;   
    var buckets = new Array(bucketCount);
    for (i = 0; i &lt; buckets.length; i++) {
        buckets[i] = [];
    }

    //利用映射函数将数据分配到各个桶中
    for (i = 0; i &lt; arr.length; i++) {
        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);
    }

    arr.length = 0;
    for (i = 0; i &lt; buckets.length; i++) {
        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序
        for (var j = 0; j &lt; buckets[i].length; j++) {
            arr.push(buckets[i][j]);                      
        }
    }

    return arr;
}
</code></pre><h5 id="java实现-8"><a href="#java实现-8" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class BucketSort implements IArraySort {

    private static final InsertSort insertSort = new InsertSort();

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        return bucketSort(arr, 5);
    }

    private int[] bucketSort(int[] arr, int bucketSize) throws Exception {
        if (arr.length == 0) {
            return arr;
        }

        int minValue = arr[0];
        int maxValue = arr[0];
        for (int value : arr) {
            if (value &lt; minValue) {
                minValue = value;
            } else if (value &gt; maxValue) {
                maxValue = value;
            }
        }

        int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1;
        int[][] buckets = new int[bucketCount][0];

        // 利用映射函数将数据分配到各个桶中
        for (int i = 0; i &lt; arr.length; i++) {
            int index = (int) Math.floor((arr[i] - minValue) / bucketSize);
            buckets[index] = arrAppend(buckets[index], arr[i]);
        }

        int arrIndex = 0;
        for (int[] bucket : buckets) {
            if (bucket.length &lt;= 0) {
                continue;
            }
            // 对每个桶进行排序，这里使用了插入排序
            bucket = insertSort.sort(bucket);
            for (int value : bucket) {
                arr[arrIndex++] = value;
            }
        }

        return arr;
    }

    /**
     * 自动扩容，并保存数据
     *
     * @param arr
     * @param value
     */
    private int[] arrAppend(int[] arr, int value) {
        arr = Arrays.copyOf(arr, arr.length + 1);
        arr[arr.length - 1] = value;
        return arr;
    }

}
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/27/electron-vue学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/27/electron-vue学习/" itemprop="url">
                  electron-vue学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-27 15:22:45" itemprop="dateCreated datePublished" datetime="2018-11-27T15:22:45+08:00">2018-11-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-05 13:02:31" itemprop="dateModified" datetime="2018-12-05T13:02:31+08:00">2018-12-05</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/electron/" itemprop="url" rel="index"><span itemprop="name">electron</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="electron-vue学习"><a href="#electron-vue学习" class="headerlink" title="electron-vue学习"></a>electron-vue学习</h3><h4 id="隐藏顶部菜单"><a href="#隐藏顶部菜单" class="headerlink" title="隐藏顶部菜单"></a>隐藏顶部菜单</h4><p>在创建窗体完成的时候的时候设置</p>
<pre><code>mainWindow.setMenu(null)
</code></pre><p>去掉顶部导航 去掉关闭按钮 最大化最小化按钮</p>
<pre><code>在创建BrowserWindow的时候设置frame的属性未false
</code></pre><h4 id="electron中使用nedb数据库"><a href="#electron中使用nedb数据库" class="headerlink" title="electron中使用nedb数据库"></a>electron中使用nedb数据库</h4><p>使用 electron 的一大好处是可以访问用户的文件系统。这使你可以读取和写入本地系统上的文件。为了避免 Chromium 的限制以及对应用程序内部文件的改写，请确保使用 electron 的 API，特别是 app.getPath(name) 函数。这个帮助函数可以使你获得指向系统目录的文件路径，如用户的桌面、系统临时文件等等.</p>
<h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><pre><code>yarn add nedb # 或 npm install nedb --save
</code></pre><p>src/renderer/datastore.js</p>
<p>我们设置 NeDB 并将其指向我们的 userData 目录。这个空间专门为我们的应用程序所保留，所以，我们可以确信，其他程序 或 与其他用户的交互不应该篡改这个文件空间。至此，我们可以在 renderer 进程中导入 datastore.js 并使用它。</p>
<pre><code>import Datastore from &apos;nedb&apos;
import path from &apos;path&apos;
import { remote } from &apos;electron&apos;

export default new Datastore({
  autoload: true,
  filename: path.join(remote.app.getPath(&apos;userData&apos;), &apos;/data.db&apos;)
})
</code></pre><p>app.getPath你可以通过名称请求以下的路径:</p>
<pre><code>home 用户的 home 文件夹（主目录）
appData 当前用户的应用数据文件夹，默认对应：

%APPDATA% Windows 中
$XDG_CONFIG_HOME or ~/.config Linux 中
~/Library/Application Support macOS 中
userData 储存你应用程序设置文件的文件夹，默认是 appData 文件夹附加应用的名称
temp 临时文件夹
exe当前的可执行文件
module The libchromiumcontent 库
desktop 当前用户的桌面文件夹
documents 用户文档目录的路径
downloads 用户下载目录的路径
music 用户音乐目录的路径
pictures 用户图片目录的路径
videos 用户视频目录的路径
logs应用程序的日志文件夹
pepperFlashSystemPlugin Pepper Flash 插件的系统版本的完成路径。
</code></pre><p>src/renderer/main.js</p>
<p>为了更进一步，我们可以将数据存储导入到 src/renderer/main.js 里，并将其附加到 Vue 的 原型 (prototype) 上。通过在所有组件文件中使用 this.$db，我们现在可以访问数据存储的 API。</p>
<pre><code>import db from &apos;./datastore&apos;
</code></pre><p>/<em> 其它代码 </em>/</p>
<pre><code>Vue.prototype.$db = db
</code></pre><h5 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h5><pre><code>npm install babel-plugin-syntax-jsx babel-plugin-transform-vue-jsx babel-helper-vue-jsx-merge-props babel-preset-env --save-dev

&quot;renderer&quot;: {
      &quot;presets&quot;: [
        [&quot;env&quot;, {
          &quot;modules&quot;: false
        }],
        &quot;stage-0&quot;
      ],
      &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;]
    },
</code></pre><h5 id="弹出框"><a href="#弹出框" class="headerlink" title="弹出框"></a>弹出框</h5><p>在electron-vue项目中由于使用组件UI的弹出框会有警告,所以采用原生的dialog的API来实现</p>
<pre><code>this.$electron.remote.dialog.showMessageBox({
                            type:&apos;info&apos;,
                            title:&apos;删除节点操作&apos;,
                            message:`您确认要删除节点${data.title}吗?`,
                            buttons:[&apos;ok&apos;,&apos;cancel&apos;]
                        },(index)=&gt;{
                            if (index == 0){
                                this.remove(root,node,data)
                                this.$Message.success({
                                     content: &apos;删除成功&apos;,
                                     duration: 3
                                })
                            } else {
                                this.$Message.error({
                                     content: &apos;删除失败&apos;,
                                     duration: 3
                                })
                            }
                        })
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/26/Nedb数据库的使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/26/Nedb数据库的使用/" itemprop="url">
                  Nedb数据库的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-26 14:20:52 / 修改时间：14:22:37" itemprop="dateCreated datePublished" datetime="2018-11-26T14:20:52+08:00">2018-11-26</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="nedb数据库"><a href="#nedb数据库" class="headerlink" title="nedb数据库"></a>nedb数据库</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><pre><code>const Datastore = require(&apos;nedb&apos;);

function DB(database) {
    let options = {
        filename: database,
        autoload: true,
    };
    this.db = new Datastore(options);
}

DB.prototype.limit = function(offset, limit) {
    this.offset = offset || 0;
    this.limit = limit || 15;
    return this;
}

DB.prototype.sort = function(orderby) {
    this.orderby = orderby;
    return this;
}
/**
 * query: Object类型  查询条件 支持使用比较运算符($lt, $lte, $gt, $gte, $in, $nin, $ne), 逻辑运算符
 * offset: 偏移量 忽略多少条  用于分页
 * limit: 返回条数  用于分页
 * 返回: docs 数组  返回查询到的数据
 * * */
DB.prototype.find = function(query, select) {
    return new Promise((resolve, reject) =&gt; {
        let stmt = this.db.find(query || {});
        if (this.orderby !== undefined) {
            stmt.sort(this.orderby);
        }
        if (this.offset !== undefined) {
            stmt.skip(this.offset).limit(this.limit);
        }
        if (select != undefined) {
            stmt.projection(select || {});
        }
        stmt.exec((err, docs) =&gt; {
            if (err) {
                return reject(err);
            }
            resolve(docs);
        })
    })
};
/**
 * query: object  查询条件
 * 查找一条
 * 返回: 查到数据
 * * */
DB.prototype.findOne = function(query, select) {
    return new Promise((resolve, reject) =&gt; {
        let stmt = this.db.findOne(query || {});
        if (this.sort !== undefined) {
            stmt.sort(this.sort);
        }
        if (select != undefined) {
            stmt.projection(select || {});
        }
        stmt.exec((err, doc) =&gt; {
            if (err) {
                return reject(err);
            }
            resolve(doc);
        })
    })
}

/**
 * 插入数据
 * value: 插入的数据  
 * 使用array，实现批量插入。一旦其中一个操作失败，所有改变将会回滚。
 * * */
DB.prototype.insert = function(values) {
    return new Promise((resolve, reject) =&gt; {
        this.db.insert(values, (err, newDoc) =&gt; {
            if (err) {
                return reject(err);
            }
            resolve(newDoc);
        })
    })
}

/**
 * 更新数据
 * query: object  查询的数据
 * values: 更新的数据
 * options : object  muti(默认false)，是否允许修改多条文档；upsert(默认为false)
 * * */
DB.prototype.update = function(query, values, options) {
    return new Promise((resolve, reject) =&gt; {
        this.db.update(query || {}, values || {}, options || {}, (err, numAffected) =&gt; {
            if (err) {
                return reject(err);
            }
            resolve(numAffected);
        })
    });
}

/**
 * 根据options配置删除所有query匹配到的文档集。
 * query: 与find和findOne中query参数的用法一致
 * options: 只有一个可用。muti(默认false)，允许删除多个文档
 * * */
DB.prototype.remove = function(query, options) {
    return new Promise((resolve, reject) =&gt; {
        this.db.remove(query || {}, options || {}, (err, numAffected) =&gt; {
            if (err) {
                return reject(err);
            }
            resolve(numAffected);
        })
    });
}


 module.exports = (database) =&gt; {
     return new DB(database);
 }
</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code>const db = require(&apos;./nedb&apos;)(&apos;testdb&apos;);

//第一种用法:async  await
//  (async function(){
//     await db.insert({number: 12,age:14});
//     await db.insert({number: 11,age:14});
//     await db.insert({number: 13,age:14});
//     let res = await db.sort({number: -1}).limit(0, 2).find();
//     console.log(res);

// })();

//第二种用法: then() catch()
db.insert({name:&apos;深圳&apos;,age:35,address:&quot;广东&quot;}).then(res=&gt;{
    console.log(res)
}).catch(err=&gt;{
    console.log(err)
})
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/22/微信小程序基础学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/22/微信小程序基础学习/" itemprop="url">
                  微信小程序基础学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-22 15:33:38 / 修改时间：16:50:37" itemprop="dateCreated datePublished" datetime="2018-11-22T15:33:38+08:00">2018-11-22</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="微信小程序基础学习"><a href="#微信小程序基础学习" class="headerlink" title="微信小程序基础学习"></a>微信小程序基础学习</h3><h4 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h4><ul>
<li>新建components文件夹</li>
<li>在components文件夹下面插件自定义组件的文件名的文件夹,然后创建组件</li>
<li><p>在其他组件要进行调用此子组件:</p>
<ol>
<li><p>在父组件的json文件下面</p>
<pre><code>{
  &quot;navigationBarTitleText&quot;:&quot;父组件页面标题&quot;,

  &quot;usingComponents&quot;: {
    &quot;br&quot;: &quot;../../components/br/br&quot; ,//注册的子组件    
    &quot;header&quot;: &quot;../../components/header/header&quot;//注册的子组件
  }
}
</code></pre></li>
</ol>
</li>
<li><p>备注: 特别需要注意的是路径</p>
</li>
</ul>
<h4 id="父组件给子组件传值"><a href="#父组件给子组件传值" class="headerlink" title="父组件给子组件传值"></a>父组件给子组件传值</h4><ul>
<li>父组件调用子组件的时候给子组件绑定属性(也就是定义字段)</li>
<li><p>在子组件的js文件里面定义properties</p>
<pre><code>properties: {
    title: { // 属性名
      type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）
      value: &apos;&apos;, // 属性初始值（可选），如果未指定则会根据类型选择一个
      observer: function(newVal, oldVal){} // 属性被改变时执行的函数（可选），也可以写成在methods段中定义的方法名字符串, 如：&apos;_propertyChange&apos;
    },
    name: String // 简化的定义方式
  }
</code></pre></li>
<li><p>同时子组件可以定义slot来承载父组件调用的时候中间写wxml语言</p>
</li>
</ul>
<h4 id="父组件调用子组件的方法"><a href="#父组件调用子组件的方法" class="headerlink" title="父组件调用子组件的方法"></a>父组件调用子组件的方法</h4><ol>
<li>调用子组件的时候定义一个id</li>
</ol>
<pre><code>&lt;header id=&quot;header&quot;&gt;&lt;/header&gt;
</code></pre><ol start="2">
<li><p>父组件获取子组件的实例 </p>
<pre><code>var header = this.selectComponent(&quot;#header&quot;)
</code></pre></li>
<li><p>header.方法名.  (实例.方法名)</p>
<pre><code> 调用子组件里面的方法
header.data.msg父组件里面直接获取子组件的数据
</code></pre></li>
</ol>
<h4 id="子组件调用父组件的方法"><a href="#子组件调用父组件的方法" class="headerlink" title="子组件调用父组件的方法"></a>子组件调用父组件的方法</h4><ul>
<li><p>父组件的方法</p>
<pre><code>    run(){
    console.log(&quot;我是父组件的方法&quot;)
}
</code></pre></li>
</ul>
<ul>
<li><p>在footer子组件方法</p>
<pre><code>&lt;Button bindtap=&quot;getParent&quot;&gt;触发父组件的run方法&lt;/button&gt;

//methods

1. this.triggerEvent(&apos;myevent&apos;, 数据, 参数）
2. &lt;footer bindmyevent=&quot;run&quot; /&gt;

getParent(){
    this.triggerEvent(&apos;parent&apos;,&apos;子组件数据&apos;)
}
</code></pre></li>
<li><p>在父组件的footer绑定</p>
<pre><code>&lt;footer bingparent=&quot;run&quot;&gt;&lt;/footer&gt;
</code></pre></li>
</ul>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="厚朴酚">
            
              <p class="site-author-name" itemprop="name">厚朴酚</p>
              <p class="site-description motion-element" itemprop="description">学习笔记</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">58</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">厚朴酚</span>

  

  
</div>



<!--
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.4.2</div>
 -->



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>

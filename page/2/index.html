<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="厚朴酚">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="厚朴酚">
<meta property="og:description" content="学习笔记">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="厚朴酚">
<meta name="twitter:description" content="学习笔记">






  <link rel="canonical" href="http://yoursite.com/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>厚朴酚</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">厚朴酚</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">打磨技术!</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/vue中keep-alive组件的作用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/vue中keep-alive组件的作用/" itemprop="url">
                  vue中keep-alive组件的作用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-05 15:12:34 / 修改时间：15:18:37" itemprop="dateCreated datePublished" datetime="2018-12-05T15:12:34+08:00">2018-12-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="vue中keep-alive组件的作用"><a href="#vue中keep-alive组件的作用" class="headerlink" title="vue中keep-alive组件的作用"></a>vue中keep-alive组件的作用</h3><p>内容来源: <a href="https://www.kancloud.cn/hanxuming/vue-iq/" target="_blank" rel="noopener">https://www.kancloud.cn/hanxuming/vue-iq/</a></p>
<p>keep-alive:主要用于保存组件状态或避免重新渲染<br>比如: 有一个列表页面和一个 详情页面，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情这样的话 列表 和 详情 都是一个频率很高的页面，那么就可以对列表组件使用<keep-alive></keep-alive>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><pre><code>include:字符串或正则表达式。只有匹配的组件会被缓存。

exclude：字符串或正则表达式。任何匹配的组件都不会被缓存。
</code></pre><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><pre><code>&lt;!-- 基本 --&gt;
&lt;keep-alive&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;

&lt;!-- 多个条件判断的子组件 --&gt;
&lt;keep-alive&gt;
  &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt;
  &lt;comp-b v-else&gt;&lt;/comp-b&gt;
&lt;/keep-alive&gt;

&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;
&lt;transition&gt;
  &lt;keep-alive&gt;
    &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
  &lt;/keep-alive&gt;
&lt;/transition&gt;
</code></pre><h4 id="include和exclude属性的使用"><a href="#include和exclude属性的使用" class="headerlink" title="include和exclude属性的使用"></a>include和exclude属性的使用</h4><p>include 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：</p>
<pre><code>&lt;!-- 逗号分隔字符串 --&gt;
&lt;keep-alive include=&quot;a,b&quot;&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;

&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;
&lt;keep-alive :include=&quot;/a|b/&quot;&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;

&lt;!-- 数组 (使用 `v-bind`) --&gt;
&lt;keep-alive :include=&quot;[&apos;a&apos;, &apos;b&apos;]&quot;&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/04/前端性能优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/04/前端性能优化/" itemprop="url">
                  前端性能优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-04 16:48:18 / 修改时间：17:26:41" itemprop="dateCreated datePublished" datetime="2018-12-04T16:48:18+08:00">2018-12-04</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/HTML/" itemprop="url" rel="index"><span itemprop="name">HTML</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h2><h3 id="网络层面"><a href="#网络层面" class="headerlink" title="网络层面"></a>网络层面</h3><h4 id="请求过程优化"><a href="#请求过程优化" class="headerlink" title="请求过程优化"></a>请求过程优化</h4><h5 id="HTTP请求优化"><a href="#HTTP请求优化" class="headerlink" title="HTTP请求优化"></a>HTTP请求优化</h5><h6 id="构建工具性能优化"><a href="#构建工具性能优化" class="headerlink" title="构建工具性能优化"></a>构建工具性能优化</h6><h6 id="Gzip压缩原理"><a href="#Gzip压缩原理" class="headerlink" title="Gzip压缩原理"></a>Gzip压缩原理</h6><h6 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h6><h4 id="减少网络请求"><a href="#减少网络请求" class="headerlink" title="减少网络请求"></a>减少网络请求</h4><h5 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h5><h6 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h6><h6 id="离线存储技术"><a href="#离线存储技术" class="headerlink" title="离线存储技术"></a>离线存储技术</h6><h3 id="渲染层面"><a href="#渲染层面" class="headerlink" title="渲染层面"></a>渲染层面</h3><h4 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h4><h4 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h4><h5 id="CSS性能优化"><a href="#CSS性能优化" class="headerlink" title="CSS性能优化"></a>CSS性能优化</h5><h5 id="js性能优化"><a href="#js性能优化" class="headerlink" title="js性能优化"></a>js性能优化</h5><h4 id="DOM优化"><a href="#DOM优化" class="headerlink" title="DOM优化"></a>DOM优化</h4><h5 id="事件循环与异步更新"><a href="#事件循环与异步更新" class="headerlink" title="事件循环与异步更新"></a>事件循环与异步更新</h5><h5 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h5><h4 id="首屏渲染提速"><a href="#首屏渲染提速" class="headerlink" title="首屏渲染提速"></a>首屏渲染提速</h4><h5 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h5>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/30/electron实现下载进度条/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/30/electron实现下载进度条/" itemprop="url">
                  electron实现下载进度条
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-30 14:07:54 / 修改时间：14:10:34" itemprop="dateCreated datePublished" datetime="2018-11-30T14:07:54+08:00">2018-11-30</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/electron/" itemprop="url" rel="index"><span itemprop="name">electron</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="electron下载进度条"><a href="#electron下载进度条" class="headerlink" title="electron下载进度条"></a>electron下载进度条</h3><pre><code>通过 Electron 中 will-download 事件

mainWindow.webContents.session.on(&apos;will-download&apos;, (e, item) =&gt; {
    //获取文件的总大小
   const totalBytes = item.getTotalBytes();

    //设置文件的保存路径，此时默认弹出的 save dialog 将被覆盖
   const filePath = path.join(app.getPath(&apos;downloads&apos;), item.getFilename());
   item.setSavePath(filePath);

    //监听下载过程，计算并设置进度条进度
   item.on(&apos;updated&apos;, () =&gt; {
       mainWindow.setProgressBar(item.getReceivedBytes() / totalBytes);
   });

    //监听下载结束事件
   item.on(&apos;done&apos;, (e, state) =&gt; {
           //如果窗口还在的话，去掉进度条
       if (!mainWindow.isDestroyed()) {
           mainWindow.setProgressBar(-1);
       }

        //下载被取消或中断了
       if (state === &apos;interrupted&apos;) {
           electron.dialog.showErrorBox(&apos;下载失败&apos;, `文件 ${item.getFilename()} 因为某些原因被中断下载`);
       }

        //下载完成，让 dock 上的下载目录Q弹一下下
       if (state === &apos;completed&apos;) {
           app.dock.downloadFinished(filePath);
       }
   });
});
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/30/基础算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/30/基础算法/" itemprop="url">
                  基础算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-30 10:14:11 / 修改时间：13:41:16" itemprop="dateCreated datePublished" datetime="2018-11-30T10:14:11+08:00">2018-11-30</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基础算法-经典排序算法"><a href="#基础算法-经典排序算法" class="headerlink" title="基础算法-经典排序算法"></a>基础算法-经典排序算法</h3><p>主要在网上找的一些资源便与归纳学习</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
<h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p>
</li>
<li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>
</li>
<li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
</li>
</ol>
<h5 id="javacript实现"><a href="#javacript实现" class="headerlink" title="javacript实现"></a>javacript实现</h5><pre><code>function quickSort(arr, left, right) {
    var len = arr.length,
        partitionIndex,
        left = typeof left != &apos;number&apos; ? 0 : left,
        right = typeof right != &apos;number&apos; ? len - 1 : right;

    if (left &lt; right) {
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex-1);
        quickSort(arr, partitionIndex+1, right);
    }
    return arr;
}

function partition(arr, left ,right) {     // 分区操作
    var pivot = left,                      // 设定基准值（pivot）
        index = pivot + 1;
    for (var i = index; i &lt;= right; i++) {
        if (arr[i] &lt; arr[pivot]) {
            swap(arr, i, index);
            index++;
        }        
    }
    swap(arr, pivot, index - 1);
    return index-1;
}

function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
function partition2(arr, low, high) {
  let pivot = arr[low];
  while (low &lt; high) {
    while (low &lt; high &amp;&amp; arr[high] &gt; pivot) {
      --high;
    }
    arr[low] = arr[high];
    while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) {
      ++low;
    }
    arr[high] = arr[low];
  }
  arr[low] = pivot;
  return low;
}

function quickSort2(arr, low, high) {
  if (low &lt; high) {
    let pivot = partition2(arr, low, high);
    quickSort2(arr, low, pivot - 1);
    quickSort2(arr, pivot + 1, high);
  }
  return arr;
}
</code></pre><h5 id="go实现"><a href="#go实现" class="headerlink" title="go实现"></a>go实现</h5><pre><code>func quickSort(arr []int) []int {
    return _quickSort(arr, 0, len(arr)-1)
}

func _quickSort(arr []int, left, right int) []int {
    if left &lt; right {
        partitionIndex := partition(arr, left, right)
        _quickSort(arr, left, partitionIndex-1)
        _quickSort(arr, partitionIndex+1, right)
    }
    return arr
}

func partition(arr []int, left, right int) int {
    pivot := left
    index := pivot + 1

    for i := index; i &lt;= right; i++ {
        if arr[i] &lt; arr[pivot] {
            swap(arr, i, index)
            index += 1
        }
    }
    swap(arr, pivot, index-1)
    return index - 1
}

func swap(arr []int, i, j int) {
    arr[i], arr[j] = arr[j], arr[i]
}
</code></pre><h5 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h5><pre><code>def quickSort(arr, left=None, right=None):
    left = 0 if not isinstance(left,(int, float)) else left
    right = len(arr)-1 if not isinstance(right,(int, float)) else right
    if left &lt; right:
        partitionIndex = partition(arr, left, right)
        quickSort(arr, left, partitionIndex-1)
        quickSort(arr, partitionIndex+1, right)
    return arr

def partition(arr, left, right):
    pivot = left
    index = pivot+1
    i = index
    while  i &lt;= right:
        if arr[i] &lt; arr[pivot]:
            swap(arr, i, index)
            index+=1
        i+=1
    swap(arr,pivot,index-1)
    return index-1

def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]
</code></pre><h5 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class QuickSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        return quickSort(arr, 0, arr.length - 1);
    }

    private int[] quickSort(int[] arr, int left, int right) {
        if (left &lt; right) {
            int partitionIndex = partition(arr, left, right);
            quickSort(arr, left, partitionIndex - 1);
            quickSort(arr, partitionIndex + 1, right);
        }
        return arr;
    }

    private int partition(int[] arr, int left, int right) {
        // 设定基准值（pivot）
        int pivot = left;
        int index = pivot + 1;
        for (int i = index; i &lt;= right; i++) {
            if (arr[i] &lt; arr[pivot]) {
                swap(arr, i, index);
                index++;
            }
        }
        swap(arr, pivot, index - 1);
        return index - 1;
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

}
</code></pre><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p>
<h5 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p>
</li>
<li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p>
</li>
<li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p>
</li>
<li><p>重复步骤 3 直到某一指针达到序列尾；</p>
</li>
<li><p>将另一序列剩下的所有元素直接复制到合并序列尾</p>
</li>
</ol>
<h5 id="javascript实现"><a href="#javascript实现" class="headerlink" title="javascript实现"></a>javascript实现</h5><pre><code>function mergeSort(arr) {  // 采用自上而下的递归方法
    var len = arr.length;
    if(len &lt; 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right)
{
    var result = [];

    while (left.length &amp;&amp; right.length) {
        if (left[0] &lt;= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());

    return result;
}
</code></pre><h5 id="python实现-1"><a href="#python实现-1" class="headerlink" title="python实现"></a>python实现</h5><pre><code>def mergeSort(arr):
    import math
    if(len(arr)&lt;2):
        return arr
    middle = math.floor(len(arr)/2)
    left, right = arr[0:middle], arr[middle:]
    return merge(mergeSort(left), mergeSort(right))

def merge(left,right):
    result = []
    while left and right:
        if left[0] &lt;= right[0]:
            result.append(left.pop(0));
        else:
            result.append(right.pop(0));
    while left:
        result.append(left.pop(0));
    while right:
        result.append(right.pop(0));
    return result
</code></pre><h5 id="golang实现"><a href="#golang实现" class="headerlink" title="golang实现"></a>golang实现</h5><pre><code>func mergeSort(arr []int) []int {
    length := len(arr)
    if length &lt; 2 {
        return arr
    }
    middle := length / 2
    left := arr[0:middle]
    right := arr[middle:]
    return merge(mergeSort(left), mergeSort(right))
}

func merge(left []int, right []int) []int {
    var result []int
    for len(left) != 0 &amp;&amp; len(right) != 0 {
        if left[0] &lt;= right[0] {
            result = append(result, left[0])
            left = left[1:]
        } else {
            result = append(result, right[0])
            right = right[1:]
        }
    }

    for len(left) != 0 {
        result = append(result, left[0])
        left = left[1:]
    }

    for len(right) != 0 {
        result = append(result, right[0])
        right = right[1:]
    }

    return result
}
</code></pre><h5 id="java实现-1"><a href="#java实现-1" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class MergeSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        if (arr.length &lt; 2) {
            return arr;
        }
        int middle = (int) Math.floor(arr.length / 2);

        int[] left = Arrays.copyOfRange(arr, 0, middle);
        int[] right = Arrays.copyOfRange(arr, middle, arr.length);

        return merge(sort(left), sort(right));
    }

    protected int[] merge(int[] left, int[] right) {
        int[] result = new int[left.length + right.length];
        int i = 0;
        while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) {
            if (left[0] &lt;= right[0]) {
                result[i++] = left[0];
                left = Arrays.copyOfRange(left, 1, left.length);
            } else {
                result[i++] = right[0];
                right = Arrays.copyOfRange(right, 1, right.length);
            }
        }

        while (left.length &gt; 0) {
            result[i++] = left[0];
            left = Arrays.copyOfRange(left, 1, left.length);
        }

        while (right.length &gt; 0) {
            result[i++] = right[0];
            right = Arrays.copyOfRange(right, 1, right.length);
        }

        return result;
    }

}
</code></pre><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p>
<h5 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
</li>
<li><p>针对所有的元素重复以上的步骤，除了最后一个。</p>
</li>
<li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</p>
</li>
</ol>
<h5 id="javascript实现-1"><a href="#javascript实现-1" class="headerlink" title="javascript实现"></a>javascript实现</h5><pre><code>function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i &lt; len - 1; i++) {
        for (var j = 0; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j+1]) {        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
</code></pre><h5 id="golang实现-1"><a href="#golang实现-1" class="headerlink" title="golang实现"></a>golang实现</h5><pre><code>func bubbleSort(arr []int) []int {
    length := len(arr)
    for i := 0; i &lt; length; i++ {
        for j := 0; j &lt; length-1-i; j++ {
            if arr[j] &gt; arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
    return arr
}
</code></pre><h5 id="python实现-2"><a href="#python实现-2" class="headerlink" title="python实现"></a>python实现</h5><pre><code>def bubbleSort(arr):
    for i in range(1, len(arr)):
        for j in range(0, len(arr)-i):
            if arr[j] &gt; arr[j+1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
</code></pre><h5 id="java实现-2"><a href="#java实现-2" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class BubbleSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        for (int i = 1; i &lt; arr.length; i++) {
            // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。
            boolean flag = true;

            for (int j = 0; j &lt; arr.length - i; j++) {
                if (arr[j] &gt; arr[j + 1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;

                    flag = false;
                }
            }

            if (flag) {
                break;
            }
        }
        return arr;
    }
}
</code></pre><h5 id="golang实现-2"><a href="#golang实现-2" class="headerlink" title="golang实现"></a>golang实现</h5><pre><code>func bubbleSort(arr []int) []int {
    length := len(arr)
    for i := 0; i &lt; length; i++ {
        for j := 0; j &lt; length-1-i; j++ {
            if arr[j] &gt; arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
    return arr
}
</code></pre><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h5 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p>
</li>
<li><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
</li>
</ol>
<p>3 .重复第二步，直到所有元素均排序完毕。</p>
<h5 id="javascript实现-2"><a href="#javascript实现-2" class="headerlink" title="javascript实现"></a>javascript实现</h5><pre><code>function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) {
            if (arr[j] &lt; arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}
</code></pre><h5 id="python实现-3"><a href="#python实现-3" class="headerlink" title="python实现"></a>python实现</h5><pre><code>def selectionSort(arr):
    for i in range(len(arr) - 1):
        # 记录最小数的索引
        minIndex = i
        for j in range(i + 1, len(arr)):
            if arr[j] &lt; arr[minIndex]:
                minIndex = j
        # i 不是最小数时，将 i 和最小数进行交换
        if i != minIndex:
            arr[i], arr[minIndex] = arr[minIndex], arr[i]
    return arr
</code></pre><h5 id="golang实现-3"><a href="#golang实现-3" class="headerlink" title="golang实现"></a>golang实现</h5><pre><code>func selectionSort(arr []int) []int {
    length := len(arr)
    for i := 0; i &lt; length-1; i++ {
        min := i
        for j := i + 1; j &lt; length; j++ {
            if arr[min] &gt; arr[j] {
                min = j
            }
        }
        arr[i], arr[min] = arr[min], arr[i]
    }
    return arr
}
</code></pre><h5 id="java实现-3"><a href="#java实现-3" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class SelectionSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        // 总共要经过 N-1 轮比较
        for (int i = 0; i &lt; arr.length - 1; i++) {
            int min = i;

            // 每轮需要比较的次数 N-i
            for (int j = i + 1; j &lt; arr.length; j++) {
                if (arr[j] &lt; arr[min]) {
                    // 记录目前能找到的最小值元素的下标
                    min = j;
                }
            }

            // 将找到的最小值和i位置所在的值进行交换
            if (i != min) {
                int tmp = arr[i];
                arr[i] = arr[min];
                arr[min] = tmp;
            }

        }
        return arr;
    }
}
</code></pre><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h5 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
</li>
<li><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
</li>
</ol>
<h5 id="javascript实现-3"><a href="#javascript实现-3" class="headerlink" title="javascript实现"></a>javascript实现</h5><pre><code>function insertionSort(arr) {
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i &lt; len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) {
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex+1] = current;
    }
    return arr;
}
</code></pre><h5 id="python实现-4"><a href="#python实现-4" class="headerlink" title="python实现"></a>python实现</h5><pre><code>def insertionSort(arr):
    for i in range(len(arr)):
        preIndex = i-1
        current = arr[i]
        while preIndex &gt;= 0 and arr[preIndex] &gt; current:
            arr[preIndex+1] = arr[preIndex]
            preIndex-=1
        arr[preIndex+1] = current
    return arr
</code></pre><h5 id="golang实现-4"><a href="#golang实现-4" class="headerlink" title="golang实现"></a>golang实现</h5><pre><code>func insertionSort(arr []int) []int {
    for i := range arr {
        preIndex := i - 1
        current := arr[i]
        for preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current {
            arr[preIndex+1] = arr[preIndex]
            preIndex -= 1
        }
        arr[preIndex+1] = current
    }
    return arr
}
</code></pre><h5 id="java实现-4"><a href="#java实现-4" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class InsertSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的
        for (int i = 1; i &lt; arr.length; i++) {

            // 记录要插入的数据
            int tmp = arr[i];

            // 从已经排序的序列最右边的开始比较，找到比其小的数
            int j = i;
            while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) {
                arr[j] = arr[j - 1];
                j--;
            }

            // 存在比其小的数，插入
            if (j != i) {
                arr[j] = tmp;
            }

        }
        return arr;
    }
}
</code></pre><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<p>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；<br>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；<br>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><ol>
<li><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p>
</li>
<li><p>按增量序列个数 k，对序列进行 k 趟排序；</p>
</li>
<li><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
</li>
</ol>
<h5 id="javascript实现-4"><a href="#javascript实现-4" class="headerlink" title="javascript实现"></a>javascript实现</h5><pre><code>function shellSort(arr) {
    var len = arr.length,
        temp,
        gap = 1;
    while(gap &lt; len/3) {          //动态定义间隔序列
        gap =gap*3+1;
    }
    for (gap; gap &gt; 0; gap = Math.floor(gap/3)) {
        for (var i = gap; i &lt; len; i++) {
            temp = arr[i];
            for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) {
                arr[j+gap] = arr[j];
            }
            arr[j+gap] = temp;
        }
    }
    return arr;
}
</code></pre><h5 id="python实现-5"><a href="#python实现-5" class="headerlink" title="python实现"></a>python实现</h5><pre><code>def shellSort(arr):
    import math
    gap=1
    while(gap &lt; len(arr)/3):
        gap = gap*3+1
    while gap &gt; 0:
        for i in range(gap,len(arr)):
            temp = arr[i]
            j = i-gap
            while j &gt;=0 and arr[j] &gt; temp:
                arr[j+gap]=arr[j]
                j-=gap
            arr[j+gap] = temp
        gap = math.floor(gap/3)
    return arr
}
</code></pre><h5 id="golang实现-5"><a href="#golang实现-5" class="headerlink" title="golang实现"></a>golang实现</h5><pre><code>func shellSort(arr []int) []int {
    length := len(arr)
    gap := 1
    for gap &lt; gap/3 {
        gap = gap*3 + 1
    }
    for gap &gt; 0 {
        for i := gap; i &lt; length; i++ {
            temp := arr[i]
            j := i - gap
            for j &gt;= 0 &amp;&amp; arr[j] &gt; temp {
                arr[j+gap] = arr[j]
                j -= gap
            }
            arr[j+gap] = temp
        }
        gap = gap / 3
    }
    return arr
}
</code></pre><h5 id="java实现-5"><a href="#java实现-5" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class ShellSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        int gap = 1;
        while (gap &lt; arr.length) {
            gap = gap * 3 + 1;
        }

        while (gap &gt; 0) {
            for (int i = gap; i &lt; arr.length; i++) {
                int tmp = arr[i];
                int j = i - gap;
                while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) {
                    arr[j + gap] = arr[j];
                    j -= gap;
                }
                arr[j + gap] = tmp;
            }
            gap = (int) Math.floor(gap / 3);
        }

        return arr;
    }
}
</code></pre><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；<br>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；<br>堆排序的平均时间复杂度为 Ο(nlogn)。</p>
<h5 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h5><ol>
<li><p>创建一个堆 H[0……n-1]；</p>
</li>
<li><p>把堆首（最大值）和堆尾互换；</p>
</li>
<li><p>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</p>
</li>
<li><p>重复步骤 2，直到堆的尺寸为 1。</p>
</li>
</ol>
<h5 id="javascript实现-5"><a href="#javascript实现-5" class="headerlink" title="javascript实现"></a>javascript实现</h5><pre><code>var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量

function buildMaxHeap(arr) {   // 建立大顶堆
    len = arr.length;
    for (var i = Math.floor(len/2); i &gt;= 0; i--) {
        heapify(arr, i);
    }
}

function heapify(arr, i) {     // 堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;

    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {
        largest = left;
    }

    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {
        largest = right;
    }

    if (largest != i) {
        swap(arr, i, largest);
        heapify(arr, largest);
    }
}

function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

function heapSort(arr) {
    buildMaxHeap(arr);

    for (var i = arr.length-1; i &gt; 0; i--) {
        swap(arr, 0, i);
        len--;
        heapify(arr, 0);
    }
    return arr;
}
</code></pre><h5 id="python实现-6"><a href="#python实现-6" class="headerlink" title="python实现"></a>python实现</h5><pre><code>def buildMaxHeap(arr):
    import math
    for i in range(math.floor(len(arr)/2),-1,-1):
        heapify(arr,i)

def heapify(arr, i):
    left = 2*i+1
    right = 2*i+2
    largest = i
    if left &lt; arrLen and arr[left] &gt; arr[largest]:
        largest = left
    if right &lt; arrLen and arr[right] &gt; arr[largest]:
        largest = right

    if largest != i:
        swap(arr, i, largest)
        heapify(arr, largest)

def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]

def heapSort(arr):
    global arrLen
    arrLen = len(arr)
    buildMaxHeap(arr)
    for i in range(len(arr)-1,0,-1):
        swap(arr,0,i)
        arrLen -=1
        heapify(arr, 0)
    return arr
</code></pre><h5 id="golang实现-6"><a href="#golang实现-6" class="headerlink" title="golang实现"></a>golang实现</h5><pre><code>func heapSort(arr []int) []int {
    arrLen := len(arr)
    buildMaxHeap(arr, arrLen)
    for i := arrLen - 1; i &gt;= 0; i-- {
        swap(arr, 0, i)
        arrLen -= 1
        heapify(arr, 0, arrLen)
    }
    return arr
}

func buildMaxHeap(arr []int, arrLen int) {
    for i := arrLen / 2; i &gt;= 0; i-- {
        heapify(arr, i, arrLen)
    }
}

func heapify(arr []int, i, arrLen int) {
    left := 2*i + 1
    right := 2*i + 2
    largest := i
    if left &lt; arrLen &amp;&amp; arr[left] &gt; arr[largest] {
        largest = left
    }
    if right &lt; arrLen &amp;&amp; arr[right] &gt; arr[largest] {
        largest = right
    }
    if largest != i {
        swap(arr, i, largest)
        heapify(arr, largest, arrLen)
    }
}

func swap(arr []int, i, j int) {
    arr[i], arr[j] = arr[j], arr[i]
}
</code></pre><h5 id="java实现-6"><a href="#java实现-6" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class HeapSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        int len = arr.length;

        buildMaxHeap(arr, len);

        for (int i = len - 1; i &gt; 0; i--) {
            swap(arr, 0, i);
            len--;
            heapify(arr, 0, len);
        }
        return arr;
    }

    private void buildMaxHeap(int[] arr, int len) {
        for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) {
            heapify(arr, i, len);
        }
    }

    private void heapify(int[] arr, int i, int len) {
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        int largest = i;

        if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {
            largest = left;
        }

        if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {
            largest = right;
        }

        if (largest != i) {
            swap(arr, i, largest);
            heapify(arr, largest, len);
        }
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

}
</code></pre><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h5 id="javascript实现-6"><a href="#javascript实现-6" class="headerlink" title="javascript实现"></a>javascript实现</h5><pre><code>function countingSort(arr, maxValue) {
    var bucket = new Array(maxValue+1),
        sortedIndex = 0;
        arrLen = arr.length,
        bucketLen = maxValue + 1;

    for (var i = 0; i &lt; arrLen; i++) {
        if (!bucket[arr[i]]) {
            bucket[arr[i]] = 0;
        }
        bucket[arr[i]]++;
    }

    for (var j = 0; j &lt; bucketLen; j++) {
        while(bucket[j] &gt; 0) {
            arr[sortedIndex++] = j;
            bucket[j]--;
        }
    }

    return arr;
}
</code></pre><h5 id="python实现-7"><a href="#python实现-7" class="headerlink" title="python实现"></a>python实现</h5><pre><code>def countingSort(arr, maxValue):
    bucketLen = maxValue+1
    bucket = [0]*bucketLen
    sortedIndex =0
    arrLen = len(arr)
    for i in range(arrLen):
        if not bucket[arr[i]]:
            bucket[arr[i]]=0
        bucket[arr[i]]+=1
    for j in range(bucketLen):
        while bucket[j]&gt;0:
            arr[sortedIndex] = j
            sortedIndex+=1
            bucket[j]-=1
    return arr
</code></pre><h5 id="golang实现-7"><a href="#golang实现-7" class="headerlink" title="golang实现"></a>golang实现</h5><pre><code>func countingSort(arr []int, maxValue int) []int {
    bucketLen := maxValue + 1
    bucket := make([]int, bucketLen) // 初始为0的数组

    sortedIndex := 0
    length := len(arr)

    for i := 0; i &lt; length; i++ {
        bucket[arr[i]] += 1
    }

    for j := 0; j &lt; bucketLen; j++ {
        for bucket[j] &gt; 0 {
            arr[sortedIndex] = j
            sortedIndex += 1
            bucket[j] -= 1
        }
    }

    return arr
}
</code></pre><h5 id="java实现-7"><a href="#java实现-7" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class CountingSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        int maxValue = getMaxValue(arr);

        return countingSort(arr, maxValue);
    }

    private int[] countingSort(int[] arr, int maxValue) {
        int bucketLen = maxValue + 1;
        int[] bucket = new int[bucketLen];

        for (int value : arr) {
            bucket[value]++;
        }

        int sortedIndex = 0;
        for (int j = 0; j &lt; bucketLen; j++) {
            while (bucket[j] &gt; 0) {
                arr[sortedIndex++] = j;
                bucket[j]--;
            }
        }
        return arr;
    }

    private int getMaxValue(int[] arr) {
        int maxValue = arr[0];
        for (int value : arr) {
            if (maxValue &lt; value) {
                maxValue = value;
            }
        }
        return maxValue;
    }

}
</code></pre><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<p>在额外空间充足的情况下，尽量增大桶的数量<br>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中<br>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<h5 id="javascript实现-7"><a href="#javascript实现-7" class="headerlink" title="javascript实现"></a>javascript实现</h5><pre><code>function bucketSort(arr, bucketSize) {
    if (arr.length === 0) {
      return arr;
    }

    var i;
    var minValue = arr[0];
    var maxValue = arr[0];
    for (i = 1; i &lt; arr.length; i++) {
      if (arr[i] &lt; minValue) {
          minValue = arr[i];                // 输入数据的最小值
      } else if (arr[i] &gt; maxValue) {
          maxValue = arr[i];                // 输入数据的最大值
      }
    }

    //桶的初始化
    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5
    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;   
    var buckets = new Array(bucketCount);
    for (i = 0; i &lt; buckets.length; i++) {
        buckets[i] = [];
    }

    //利用映射函数将数据分配到各个桶中
    for (i = 0; i &lt; arr.length; i++) {
        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);
    }

    arr.length = 0;
    for (i = 0; i &lt; buckets.length; i++) {
        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序
        for (var j = 0; j &lt; buckets[i].length; j++) {
            arr.push(buckets[i][j]);                      
        }
    }

    return arr;
}
</code></pre><h5 id="java实现-8"><a href="#java实现-8" class="headerlink" title="java实现"></a>java实现</h5><pre><code>public class BucketSort implements IArraySort {

    private static final InsertSort insertSort = new InsertSort();

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        return bucketSort(arr, 5);
    }

    private int[] bucketSort(int[] arr, int bucketSize) throws Exception {
        if (arr.length == 0) {
            return arr;
        }

        int minValue = arr[0];
        int maxValue = arr[0];
        for (int value : arr) {
            if (value &lt; minValue) {
                minValue = value;
            } else if (value &gt; maxValue) {
                maxValue = value;
            }
        }

        int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1;
        int[][] buckets = new int[bucketCount][0];

        // 利用映射函数将数据分配到各个桶中
        for (int i = 0; i &lt; arr.length; i++) {
            int index = (int) Math.floor((arr[i] - minValue) / bucketSize);
            buckets[index] = arrAppend(buckets[index], arr[i]);
        }

        int arrIndex = 0;
        for (int[] bucket : buckets) {
            if (bucket.length &lt;= 0) {
                continue;
            }
            // 对每个桶进行排序，这里使用了插入排序
            bucket = insertSort.sort(bucket);
            for (int value : bucket) {
                arr[arrIndex++] = value;
            }
        }

        return arr;
    }

    /**
     * 自动扩容，并保存数据
     *
     * @param arr
     * @param value
     */
    private int[] arrAppend(int[] arr, int value) {
        arr = Arrays.copyOf(arr, arr.length + 1);
        arr[arr.length - 1] = value;
        return arr;
    }

}
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/27/electron-vue学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/27/electron-vue学习/" itemprop="url">
                  electron-vue学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-27 15:22:45" itemprop="dateCreated datePublished" datetime="2018-11-27T15:22:45+08:00">2018-11-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-05 13:02:31" itemprop="dateModified" datetime="2018-12-05T13:02:31+08:00">2018-12-05</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/electron/" itemprop="url" rel="index"><span itemprop="name">electron</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="electron-vue学习"><a href="#electron-vue学习" class="headerlink" title="electron-vue学习"></a>electron-vue学习</h3><h4 id="隐藏顶部菜单"><a href="#隐藏顶部菜单" class="headerlink" title="隐藏顶部菜单"></a>隐藏顶部菜单</h4><p>在创建窗体完成的时候的时候设置</p>
<pre><code>mainWindow.setMenu(null)
</code></pre><p>去掉顶部导航 去掉关闭按钮 最大化最小化按钮</p>
<pre><code>在创建BrowserWindow的时候设置frame的属性未false
</code></pre><h4 id="electron中使用nedb数据库"><a href="#electron中使用nedb数据库" class="headerlink" title="electron中使用nedb数据库"></a>electron中使用nedb数据库</h4><p>使用 electron 的一大好处是可以访问用户的文件系统。这使你可以读取和写入本地系统上的文件。为了避免 Chromium 的限制以及对应用程序内部文件的改写，请确保使用 electron 的 API，特别是 app.getPath(name) 函数。这个帮助函数可以使你获得指向系统目录的文件路径，如用户的桌面、系统临时文件等等.</p>
<h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><pre><code>yarn add nedb # 或 npm install nedb --save
</code></pre><p>src/renderer/datastore.js</p>
<p>我们设置 NeDB 并将其指向我们的 userData 目录。这个空间专门为我们的应用程序所保留，所以，我们可以确信，其他程序 或 与其他用户的交互不应该篡改这个文件空间。至此，我们可以在 renderer 进程中导入 datastore.js 并使用它。</p>
<pre><code>import Datastore from &apos;nedb&apos;
import path from &apos;path&apos;
import { remote } from &apos;electron&apos;

export default new Datastore({
  autoload: true,
  filename: path.join(remote.app.getPath(&apos;userData&apos;), &apos;/data.db&apos;)
})
</code></pre><p>app.getPath你可以通过名称请求以下的路径:</p>
<pre><code>home 用户的 home 文件夹（主目录）
appData 当前用户的应用数据文件夹，默认对应：

%APPDATA% Windows 中
$XDG_CONFIG_HOME or ~/.config Linux 中
~/Library/Application Support macOS 中
userData 储存你应用程序设置文件的文件夹，默认是 appData 文件夹附加应用的名称
temp 临时文件夹
exe当前的可执行文件
module The libchromiumcontent 库
desktop 当前用户的桌面文件夹
documents 用户文档目录的路径
downloads 用户下载目录的路径
music 用户音乐目录的路径
pictures 用户图片目录的路径
videos 用户视频目录的路径
logs应用程序的日志文件夹
pepperFlashSystemPlugin Pepper Flash 插件的系统版本的完成路径。
</code></pre><p>src/renderer/main.js</p>
<p>为了更进一步，我们可以将数据存储导入到 src/renderer/main.js 里，并将其附加到 Vue 的 原型 (prototype) 上。通过在所有组件文件中使用 this.$db，我们现在可以访问数据存储的 API。</p>
<pre><code>import db from &apos;./datastore&apos;
</code></pre><p>/<em> 其它代码 </em>/</p>
<pre><code>Vue.prototype.$db = db
</code></pre><h5 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h5><pre><code>npm install babel-plugin-syntax-jsx babel-plugin-transform-vue-jsx babel-helper-vue-jsx-merge-props babel-preset-env --save-dev

&quot;renderer&quot;: {
      &quot;presets&quot;: [
        [&quot;env&quot;, {
          &quot;modules&quot;: false
        }],
        &quot;stage-0&quot;
      ],
      &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;]
    },
</code></pre><h5 id="弹出框"><a href="#弹出框" class="headerlink" title="弹出框"></a>弹出框</h5><p>在electron-vue项目中由于使用组件UI的弹出框会有警告,所以采用原生的dialog的API来实现</p>
<pre><code>this.$electron.remote.dialog.showMessageBox({
                            type:&apos;info&apos;,
                            title:&apos;删除节点操作&apos;,
                            message:`您确认要删除节点${data.title}吗?`,
                            buttons:[&apos;ok&apos;,&apos;cancel&apos;]
                        },(index)=&gt;{
                            if (index == 0){
                                this.remove(root,node,data)
                                this.$Message.success({
                                     content: &apos;删除成功&apos;,
                                     duration: 3
                                })
                            } else {
                                this.$Message.error({
                                     content: &apos;删除失败&apos;,
                                     duration: 3
                                })
                            }
                        })
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/26/Nedb数据库的使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/26/Nedb数据库的使用/" itemprop="url">
                  Nedb数据库的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-26 14:20:52 / 修改时间：14:22:37" itemprop="dateCreated datePublished" datetime="2018-11-26T14:20:52+08:00">2018-11-26</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="nedb数据库"><a href="#nedb数据库" class="headerlink" title="nedb数据库"></a>nedb数据库</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><pre><code>const Datastore = require(&apos;nedb&apos;);

function DB(database) {
    let options = {
        filename: database,
        autoload: true,
    };
    this.db = new Datastore(options);
}

DB.prototype.limit = function(offset, limit) {
    this.offset = offset || 0;
    this.limit = limit || 15;
    return this;
}

DB.prototype.sort = function(orderby) {
    this.orderby = orderby;
    return this;
}
/**
 * query: Object类型  查询条件 支持使用比较运算符($lt, $lte, $gt, $gte, $in, $nin, $ne), 逻辑运算符
 * offset: 偏移量 忽略多少条  用于分页
 * limit: 返回条数  用于分页
 * 返回: docs 数组  返回查询到的数据
 * * */
DB.prototype.find = function(query, select) {
    return new Promise((resolve, reject) =&gt; {
        let stmt = this.db.find(query || {});
        if (this.orderby !== undefined) {
            stmt.sort(this.orderby);
        }
        if (this.offset !== undefined) {
            stmt.skip(this.offset).limit(this.limit);
        }
        if (select != undefined) {
            stmt.projection(select || {});
        }
        stmt.exec((err, docs) =&gt; {
            if (err) {
                return reject(err);
            }
            resolve(docs);
        })
    })
};
/**
 * query: object  查询条件
 * 查找一条
 * 返回: 查到数据
 * * */
DB.prototype.findOne = function(query, select) {
    return new Promise((resolve, reject) =&gt; {
        let stmt = this.db.findOne(query || {});
        if (this.sort !== undefined) {
            stmt.sort(this.sort);
        }
        if (select != undefined) {
            stmt.projection(select || {});
        }
        stmt.exec((err, doc) =&gt; {
            if (err) {
                return reject(err);
            }
            resolve(doc);
        })
    })
}

/**
 * 插入数据
 * value: 插入的数据  
 * 使用array，实现批量插入。一旦其中一个操作失败，所有改变将会回滚。
 * * */
DB.prototype.insert = function(values) {
    return new Promise((resolve, reject) =&gt; {
        this.db.insert(values, (err, newDoc) =&gt; {
            if (err) {
                return reject(err);
            }
            resolve(newDoc);
        })
    })
}

/**
 * 更新数据
 * query: object  查询的数据
 * values: 更新的数据
 * options : object  muti(默认false)，是否允许修改多条文档；upsert(默认为false)
 * * */
DB.prototype.update = function(query, values, options) {
    return new Promise((resolve, reject) =&gt; {
        this.db.update(query || {}, values || {}, options || {}, (err, numAffected) =&gt; {
            if (err) {
                return reject(err);
            }
            resolve(numAffected);
        })
    });
}

/**
 * 根据options配置删除所有query匹配到的文档集。
 * query: 与find和findOne中query参数的用法一致
 * options: 只有一个可用。muti(默认false)，允许删除多个文档
 * * */
DB.prototype.remove = function(query, options) {
    return new Promise((resolve, reject) =&gt; {
        this.db.remove(query || {}, options || {}, (err, numAffected) =&gt; {
            if (err) {
                return reject(err);
            }
            resolve(numAffected);
        })
    });
}


 module.exports = (database) =&gt; {
     return new DB(database);
 }
</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code>const db = require(&apos;./nedb&apos;)(&apos;testdb&apos;);

//第一种用法:async  await
//  (async function(){
//     await db.insert({number: 12,age:14});
//     await db.insert({number: 11,age:14});
//     await db.insert({number: 13,age:14});
//     let res = await db.sort({number: -1}).limit(0, 2).find();
//     console.log(res);

// })();

//第二种用法: then() catch()
db.insert({name:&apos;深圳&apos;,age:35,address:&quot;广东&quot;}).then(res=&gt;{
    console.log(res)
}).catch(err=&gt;{
    console.log(err)
})
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/22/微信小程序基础学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/22/微信小程序基础学习/" itemprop="url">
                  微信小程序基础学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-22 15:33:38 / 修改时间：16:50:37" itemprop="dateCreated datePublished" datetime="2018-11-22T15:33:38+08:00">2018-11-22</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="微信小程序基础学习"><a href="#微信小程序基础学习" class="headerlink" title="微信小程序基础学习"></a>微信小程序基础学习</h3><h4 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h4><ul>
<li>新建components文件夹</li>
<li>在components文件夹下面插件自定义组件的文件名的文件夹,然后创建组件</li>
<li><p>在其他组件要进行调用此子组件:</p>
<ol>
<li><p>在父组件的json文件下面</p>
<pre><code>{
  &quot;navigationBarTitleText&quot;:&quot;父组件页面标题&quot;,

  &quot;usingComponents&quot;: {
    &quot;br&quot;: &quot;../../components/br/br&quot; ,//注册的子组件    
    &quot;header&quot;: &quot;../../components/header/header&quot;//注册的子组件
  }
}
</code></pre></li>
</ol>
</li>
<li><p>备注: 特别需要注意的是路径</p>
</li>
</ul>
<h4 id="父组件给子组件传值"><a href="#父组件给子组件传值" class="headerlink" title="父组件给子组件传值"></a>父组件给子组件传值</h4><ul>
<li>父组件调用子组件的时候给子组件绑定属性(也就是定义字段)</li>
<li><p>在子组件的js文件里面定义properties</p>
<pre><code>properties: {
    title: { // 属性名
      type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）
      value: &apos;&apos;, // 属性初始值（可选），如果未指定则会根据类型选择一个
      observer: function(newVal, oldVal){} // 属性被改变时执行的函数（可选），也可以写成在methods段中定义的方法名字符串, 如：&apos;_propertyChange&apos;
    },
    name: String // 简化的定义方式
  }
</code></pre></li>
<li><p>同时子组件可以定义slot来承载父组件调用的时候中间写wxml语言</p>
</li>
</ul>
<h4 id="父组件调用子组件的方法"><a href="#父组件调用子组件的方法" class="headerlink" title="父组件调用子组件的方法"></a>父组件调用子组件的方法</h4><ol>
<li>调用子组件的时候定义一个id</li>
</ol>
<pre><code>&lt;header id=&quot;header&quot;&gt;&lt;/header&gt;
</code></pre><ol start="2">
<li><p>父组件获取子组件的实例 </p>
<pre><code>var header = this.selectComponent(&quot;#header&quot;)
</code></pre></li>
<li><p>header.方法名.  (实例.方法名)</p>
<pre><code> 调用子组件里面的方法
header.data.msg父组件里面直接获取子组件的数据
</code></pre></li>
</ol>
<h4 id="子组件调用父组件的方法"><a href="#子组件调用父组件的方法" class="headerlink" title="子组件调用父组件的方法"></a>子组件调用父组件的方法</h4><ul>
<li><p>父组件的方法</p>
<pre><code>    run(){
    console.log(&quot;我是父组件的方法&quot;)
}
</code></pre></li>
</ul>
<ul>
<li><p>在footer子组件方法</p>
<pre><code>&lt;Button bindtap=&quot;getParent&quot;&gt;触发父组件的run方法&lt;/button&gt;

//methods

1. this.triggerEvent(&apos;myevent&apos;, 数据, 参数）
2. &lt;footer bindmyevent=&quot;run&quot; /&gt;

getParent(){
    this.triggerEvent(&apos;parent&apos;,&apos;子组件数据&apos;)
}
</code></pre></li>
<li><p>在父组件的footer绑定</p>
<pre><code>&lt;footer bingparent=&quot;run&quot;&gt;&lt;/footer&gt;
</code></pre></li>
</ul>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/22/centos7安装golang以及配置vscode编辑器/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/22/centos7安装golang以及配置vscode编辑器/" itemprop="url">
                  centos7安装golang以及配置vscode编辑器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-22 08:50:28 / 修改时间：09:06:22" itemprop="dateCreated datePublished" datetime="2018-11-22T08:50:28+08:00">2018-11-22</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="centos7安装golang以及配置vscode编辑器"><a href="#centos7安装golang以及配置vscode编辑器" class="headerlink" title="centos7安装golang以及配置vscode编辑器"></a>centos7安装golang以及配置vscode编辑器</h3><h4 id="centos7安装golang"><a href="#centos7安装golang" class="headerlink" title="centos7安装golang"></a>centos7安装golang</h4><ul>
<li>下载tar包</li>
</ul>
<p>链接地址  <a href="https://studygolang.com/dl" target="_blank" rel="noopener">https://studygolang.com/dl</a></p>
<ul>
<li>解压至指定文件夹</li>
</ul>
<p>tar -zxvf &lt;包名&gt;</p>
<ul>
<li><p>解压完毕后在 /usr/local 目录下会有一个go文件夹</p>
</li>
<li><p>建立工作目录workspace,新项目将建立在src文件夹下</p>
<pre><code>mkdir -p /usr/local/goproject
cd /usr/local/goproject
mkdir src pkg bin
</code></pre></li>
<li><p>设置环境变量</p>
<pre><code>在跟目录   ls -a  找到.bashrc文件
</code></pre></li>
<li><p>在文件最后加入如下代码，不要有空行, 保存退出</p>
<pre><code>export GOROOT=/usr/local/go
export PATH=$GOROOT/bin:$PATH
export GOPATH=/usr/local/goproject
</code></pre></li>
<li><p>刷新系统配置</p>
<pre><code>source .bashrc
</code></pre></li>
<li><p>输入go就可以查看是否安装成功</p>
</li>
</ul>
<h4 id="配置vscode编辑器"><a href="#配置vscode编辑器" class="headerlink" title="配置vscode编辑器"></a>配置vscode编辑器</h4><p>主要根据官网:<a href="https://code.visualstudio.com/docs/setup/linux" target="_blank" rel="noopener">https://code.visualstudio.com/docs/setup/linux</a></p>
<ul>
<li><p>注册源</p>
<pre><code>sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc
sudo sh -c &apos;echo -e &quot;[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc&quot; &gt; /etc/yum.repos.d/vscode.repo&apos;
</code></pre></li>
</ul>
<ul>
<li><p>更新源并安装</p>
<pre><code>yum check-update
sudo yum install code
</code></pre></li>
</ul>
<p>然后 在终端输入 code就可以启动了,然后可以安装各种插件助你提高开发效率.</p>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/21/electron-vue主进程分离/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/21/electron-vue主进程分离/" itemprop="url">
                  electron-vue主进程分离
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-21 16:59:52 / 修改时间：17:05:25" itemprop="dateCreated datePublished" datetime="2018-11-21T16:59:52+08:00">2018-11-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/electron/" itemprop="url" rel="index"><span itemprop="name">electron</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="electron-vue主进程分离"><a href="#electron-vue主进程分离" class="headerlink" title="electron-vue主进程分离"></a>electron-vue主进程分离</h3><ul>
<li>假设有一个菜单menu文件</li>
</ul>
<pre><code>import { Menu, globalShortcut, app } from &apos;electron&apos;

const template = [
    {
        label: &apos;Music&apos;,
        submenu: [
            {
                label: &apos;打开控制台&apos;,
                click() {
                    global.mainWindow.webContents.openDevTools({ mode: &apos;detach&apos; })
                }
            },
            {
                label: &apos;关于&apos;,
                click() {
                    require(&apos;electron&apos;).shell.openExternal(&apos;https://github.com/sunzongzheng/music&apos;)
                }
            },
            {
                label: &apos;退出音乐湖&apos;,
                accelerator: &apos;CommandOrControl+Q&apos;,
                click: () =&gt; {
                    global.mainWindow = null
                    app.exit()
                }
            }
        ]
    },
    {
        label: &apos;编辑&apos;,
        submenu: [
            {role: &apos;undo&apos;, label: &apos;撤销&apos;},
            {role: &apos;redo&apos;, label: &apos;重做&apos;},
            {type: &apos;separator&apos;},
            {role: &apos;cut&apos;, label: &apos;剪贴&apos;},
            {role: &apos;copy&apos;, label: &apos;拷贝&apos;},
            {role: &apos;paste&apos;, label: &apos;粘贴&apos;},
            {role: &apos;delete&apos;, label: &apos;删除&apos;},
            {role: &apos;selectall&apos;, label: &apos;全选&apos;}
        ]
    }
]
export default function initMenu() {
    const menu = Menu.buildFromTemplate(template)
    Menu.setApplicationMenu(menu)
    // 设置一个复杂的组合键打开控制台 方便调试
    const res = globalShortcut.register(&apos;Control+Q+W+E+R&apos;, () =&gt; {
        global.mainWindow.webContents.openDevTools({ mode: &apos;detach&apos; })
    })
    if (res) {
        console.log(`控制台组合键注册成功`)
    } else {
        console.log(`控制台组合键注册失败`)
    }
}
</code></pre><ul>
<li>主进程引入</li>
</ul>
<pre><code>import initMenu from &apos;./menu&apos;
</code></pre><p>并且在创建窗体的时候进行实例化</p>
<pre><code>initMenu()
</code></pre>
          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/21/electron文件上传以及断点下载/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="厚朴酚">
      <meta itemprop="description" content="学习笔记">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="厚朴酚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/21/electron文件上传以及断点下载/" itemprop="url">
                  electron文件上传以及断点上传
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-21 15:40:53 / 修改时间：16:22:26" itemprop="dateCreated datePublished" datetime="2018-11-21T15:40:53+08:00">2018-11-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/electron/" itemprop="url" rel="index"><span itemprop="name">electron</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="electron文件上传以及断点上传"><a href="#electron文件上传以及断点上传" class="headerlink" title="electron文件上传以及断点上传"></a>electron文件上传以及断点上传</h3><p>感谢博文:<a href="https://www.cnblogs.com/leejay6567/p/9865373.html" target="_blank" rel="noopener">https://www.cnblogs.com/leejay6567/p/9865373.html</a></p>
<p>在Electron中实现文件的上传以及断点续传。网上关于h5的上传下载的案例已经非常多，但是关于大文件的上传和续传的很少。</p>
<p>首先上传方案，我们通过将大文件进行分片处理，将大文件切割成固定大小的分片。通过node的fs.createReadStream方法实现：</p>
<pre><code>singleUpload function(file){
    let path = file.path; //文件本地路径 
    let stats = fs.statSync(path);//读取文件信息
    let chunkSize = 3*1024*1024;//每片分块的大小3M
    let size = stats.size;//文件大小
    let pieces = Math.ceil(size / chunkSize);//总共的分片数  
    function uploadPiece (i){ 
        //计算每块的结束位置
        let enddata = Math.min(size, (i + 1) * chunkSize);
        let arr = [];
       //创建一个readStream对象，根据文件起始位置和结束位置读取固定的分片
       let readStream = fs.createReadStream(path, { start: i * chunkSize, end: enddata-1 });
            //on data读取数据
            readStream.on(&apos;data&apos;, (data)=&gt;{
                arr.push(data)
            }) 
            //on end在该分片读取完成时触发
            readStream.on(&apos;end&apos;, ()=&gt;{
                //这里服务端只接受blob对象，需要把原始的数据流转成blob对象，这块为了配合后端才转
                let blob = new Blob(arr)
                //新建formdata数据对象
                var formdata = new FormData();
                let md5Val = md5(Buffer.concat(arr));
                formdata.append(&quot;file&quot;, blob);
                console.log(&apos;blob.size&apos;,blob.size)
                formdata.append(&quot;md5&quot;, md5Val);
                formdata.append(&quot;size&quot;, size + &apos;&apos;); // 数字30被转换成字符串&quot;30&quot;
                formdata.append(&quot;chunk&quot;, i + &apos;&apos;);//第几个分片，从0开始
                formdata.append(&quot;chunks&quot;, pieces + &apos;&apos;);//分片数
                formdata.append(&quot;name&quot;, name);//文件名
                post(formdata)//这里是伪代码，实现上传，开发者自己实现
    }
}
</code></pre><p>首先读取文件的基本信息，如路径，大小进行分块，然后将每块上传，我们上传循环上传整个文件的分片，就循环调用uploadpiece方法。那么我们怎么实现断点续传呢？上面的代码中我们计算每块的md5值，这里计算每个md5值就是为了断点续传使用。我们每次上传文件前，我们会先调用预上传接口，预上传接口中，前端传入fileId，后端会将改文件已经上传的分块的md5数组传给前端，前端将该文件的分块的md5值和后端返回的md5值进行逐个对比，跳过已经上传的分块。这样就实现了大文件的上传和断点续传的问题。</p>
<p>流程图方法:</p>
<p><a href="https://img2018.cnblogs.com/blog/1400402/201810/1400402-20181028135505363-1547565923.png" target="_blank" rel="noopener">https://img2018.cnblogs.com/blog/1400402/201810/1400402-20181028135505363-1547565923.png</a></p>
<h3 id="Electron实现文件的下载和断点续下载功能"><a href="#Electron实现文件的下载和断点续下载功能" class="headerlink" title="Electron实现文件的下载和断点续下载功能"></a>Electron实现文件的下载和断点续下载功能</h3><p>介绍在Electron中实现文件的下载和断点下载功能。这里下载的实现的方法较简单，采用流式下载的方案。<br>通过request库来实现下载。</p>
<pre><code>downloadFile(fileInfo, downloadPath){
    var received_bytes = 0;//已经接收到的集结
    var total_bytes = item.fileInfo;//总字节
    let path = this.downloadPath+&apos;/&apos;+fileInfo.name; //确定文件下载的本地位置
    try{
            let stats = fs.statSync(path);//如果文件已存在读取文件信息
            if(total_bytes == stats.size){//如果文件已经存在并且已经下载按成则跳过该文件
                return;
            }
            received_bytes = stats.size;
      }catch (err){

      }
      let params ={           
           &quot;method&quot;: &apos;GET&apos;,           
           &quot;url&quot;: &apos;&apos;
      }
      if(received_bytes&gt;0){

              params.headers[&apos;Range&apos;] = &apos;bytes=&apos;+received_bytes;
        }

      var req = request({
           &quot;method&quot;: &apos;GET&apos;,
           &quot;url&quot;: &apos;&apos;
      });
       var out = fs.createWriteStream(path);//创建文件写入
       req.pipe(out);
       req.on(&apos;response&apos;, ( data ) =&gt; { 
            startTime = new Date().getTime();
        });
       //接收到文件流事件
       req.on(&apos;data&apos;, (chunk) =&gt; {
            received_bytes += chunk.length;
       })
      //文件接收结束
       req.on(&apos;end&apos;, () =&gt; {
            console.log(`file ${item.name} download complete`)
            if(received_bytes &gt;= total_bytes){
                this.dataset.splice(index, 1);
            }
        });
}
</code></pre><p>这里在每次开始接受字节流时，首先判断该文件是否存在，若存在计算该文件接受的字节流大小，放在header中 Range：bytes=&lt;文件的断点位置&gt;-，这样会继续断点的位置继续下载。</p>

          
        
      
    </div>

    

    
    
    
    

    
    <div>
      
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="厚朴酚">
            
              <p class="site-author-name" itemprop="name">厚朴酚</p>
              <p class="site-description motion-element" itemprop="description">学习笔记</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">55</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">28</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">厚朴酚</span>

  

  
</div>



<!--
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.4.2</div>
 -->



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>

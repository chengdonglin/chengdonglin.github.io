import{_ as a,c as e,o as i,a3 as l}from"./chunks/framework.pgMqRpUO.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"column/redis/003_redis_analysis.md","filePath":"column/redis/003_redis_analysis.md"}'),t={name:"column/redis/003_redis_analysis.md"},o=l('<h2 id="缓存穿透、缓存失效、缓存雪崩场景分析" tabindex="-1">缓存穿透、缓存失效、缓存雪崩场景分析 <a class="header-anchor" href="#缓存穿透、缓存失效、缓存雪崩场景分析" aria-label="Permalink to &quot;缓存穿透、缓存失效、缓存雪崩场景分析&quot;">​</a></h2><h2 id="缓存穿透" tabindex="-1">缓存穿透 <a class="header-anchor" href="#缓存穿透" aria-label="Permalink to &quot;缓存穿透&quot;">​</a></h2><p>缓存穿透指查询一个根本不存在的数据，缓存层以及存储层度不会命中，通常我们从缓存查询不到数据的时候，一般不会写入缓存层</p><p>缓存穿透导致不存在的数据每次请求都需要到存储层去查询，失去了缓存保护接口的意义</p><ul><li>造成缓存穿透的原因一般有以下两个：</li></ul><ol><li>自身业务代码或者数据问题</li><li>一些恶意攻击、爬虫等造成大量空命中</li></ol><ul><li>解决方案</li></ul><ol><li>缓存空对象</li><li>布隆过滤器</li></ol><h2 id="缓存失效-击穿" tabindex="-1">缓存失效(击穿) <a class="header-anchor" href="#缓存失效-击穿" aria-label="Permalink to &quot;缓存失效(击穿)&quot;">​</a></h2><p>由于大批量缓存同一时间可能导致大量请求同时穿透缓存直接请求数据库，可能会造成数据库瞬间压力过大，对于这种情况我们在批量增加缓存时最好将这一批数据的缓存过期时间设置为同一个时间段的不同时间</p><p>由于 key 是热点数据,失效的时候刚好有大批请求同时到达， 发现缓存不存在数据， 则将把流量全部打到数据库上，对于这种情况我们在查询数据库的时候添加互斥锁来解决，此方法只允许一个线程重建缓存，其他线程进行等待一段时间，重新从缓存获取数据， 或者将热点数据的过期时间设为不过期</p><h2 id="缓存雪崩" tabindex="-1">缓存雪崩 <a class="header-anchor" href="#缓存雪崩" aria-label="Permalink to &quot;缓存雪崩&quot;">​</a></h2><p>缓存雪崩指的是缓存支撑不住宕机，流量全部达到存储层，比如缓存层由于超大并发过来，缓存层支持不住，或者缓存设计不好，有大量的 bigkey 访问， 导致缓存支撑的并发急剧下降， 于是大量请求达到存储层。</p><p>对于这种，我们可以设计以下方案来解决或者预防</p><ol><li>保证缓存服务的高可用，比如采用 Redis Sentinel 或者 Redis Cluster</li><li>依赖隔离组件作为后端限流熔断降级</li></ol>',15),r=[o];function s(n,_,d,c,h,p){return i(),e("div",null,r)}const f=a(t,[["render",s]]);export{m as __pageData,f as default};

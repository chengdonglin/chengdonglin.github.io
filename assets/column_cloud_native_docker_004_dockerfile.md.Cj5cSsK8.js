import{_ as s,c as i,o as a,a3 as t}from"./chunks/framework.pgMqRpUO.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"column/cloud_native/docker/004_dockerfile.md","filePath":"column/cloud_native/docker/004_dockerfile.md"}'),l={name:"column/cloud_native/docker/004_dockerfile.md"},n=t(`<h2 id="深入理解-dockerfile" tabindex="-1">深入理解 Dockerfile <a class="header-anchor" href="#深入理解-dockerfile" aria-label="Permalink to &quot;深入理解 Dockerfile&quot;">​</a></h2><p>Dockerfile 是每一行是一条命令语句，支持以#开头的注释 通常一个标准的 Dockerfile 包含 4 部分信息：基础镜像信息， 维护者信息，镜像操作指令， 启动执行指令</p><h3 id="常用指令详解" tabindex="-1">常用指令详解 <a class="header-anchor" href="#常用指令详解" aria-label="Permalink to &quot;常用指令详解&quot;">​</a></h3><table tabindex="0"><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>FROM</td><td>指定基础镜像</td></tr><tr><td>MAINTAINER</td><td>已过时，可以使用 LABEL maintainer=xxx 来替代</td></tr><tr><td>RUN</td><td>运行命令</td></tr><tr><td>CMD</td><td>指定启动容器时默认的命令</td></tr><tr><td>ENTRYPOINT</td><td>指定镜像的默认入口.运行命令</td></tr><tr><td>EXPOSE</td><td>声明镜像内服务监听的端口</td></tr><tr><td>ENV</td><td>指定环境变量，可以在 docker run 的时候使用-e 改变 v</td></tr><tr><td>ADD</td><td>复制指定的 src 路径下的内容到容器中的 dest 路径下，src 可以为 url 会自动下载，可以为 tar 文件，会自动解压</td></tr><tr><td>COPY</td><td>复制本地主机的 src 路径下的内容到镜像中的 dest 路径下，但不会自动解压等</td></tr><tr><td>LABEL</td><td>指定生成镜像的元数据标签信息</td></tr><tr><td>VOLUME</td><td>创建数据卷挂载点</td></tr><tr><td>USER</td><td>指定运行容器时的用户名或 UID</td></tr><tr><td>WORKDIR</td><td>配置工作目录，为后续的 RUN、CMD、ENTRYPOINT 指令配置工作目录</td></tr><tr><td>ARG</td><td>指定镜像内使用的参数（如版本号信息等），可以在 build 的时候，使用--buildargs 改变</td></tr></tbody></table><h4 id="from" tabindex="-1">FROM <a class="header-anchor" href="#from" aria-label="Permalink to &quot;FROM&quot;">​</a></h4><p>FROM 指定基础镜像于多阶段构建 Java 应用当然是 java 基础镜像（SpringBoot 应用）或者 Tomcat 基础镜像（War 应用） JS 模块化应用一般用 nodejs 基础镜像 其他各种语言用自己的服务器或者基础环境镜像，如 python、golang、java、php 等</p><h4 id="label" tabindex="-1">LABEL <a class="header-anchor" href="#label" aria-label="Permalink to &quot;LABEL&quot;">​</a></h4><p>标注镜像的一些说明信息</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">LABEL</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> multi.label1=&quot;value1&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> multi.label2=&quot;value2&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> other=&quot;value3&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">LABEL</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> multi.label1=&quot;value1&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">multi.label2=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;value2&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">other=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;value3</span></span></code></pre></div><h4 id="run" tabindex="-1">RUN <a class="header-anchor" href="#run" aria-label="Permalink to &quot;RUN&quot;">​</a></h4><p>RUN 指令在当前镜像层顶部的新层执行任何命令，并提交结果，生成新的镜像层 生成的提交映像将用于 Dockerfile 中的下一步。 分层运行 RUN 指令并生成提交符合 Docker 的核心概念，就像源代码控制一样。</p><div class="language-BASH vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">BASH</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RUN</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">comman</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">shell</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 形式,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /bin/sh</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -c</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 的方式运行，避免破坏shell字符串</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;executable&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;param1&quot;,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;param2&quot;]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">exec</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 形式</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h4 id="cmd-和-entrypoint" tabindex="-1">CMD 和 ENTRYPOINT <a class="header-anchor" href="#cmd-和-entrypoint" aria-label="Permalink to &quot;CMD 和 ENTRYPOINT&quot;">​</a></h4><p>CMD 的三种写法：</p><ol><li>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] ( exec 方式, 首选方式)</li><li>CMD [&quot;param1&quot;,&quot;param2&quot;] (为 ENTRYPOINT 提供默认参数)</li><li>CMD command param1 param2 ( shell 形式)</li></ol><p>ENTRYPOINT 的两种写法：</p><ol><li>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] ( exec 方式, 首选方式)</li><li>ENTRYPOINT command param1 param2 (shell 形式)</li></ol><p>Dockerfile 中只能有一条 CMD 指令。 如果您列出多个 CMD，则只有最后一个 CMD 才会生效。 CMD 的主要目的是为执行中的容器提供默认值。 这些默认值可以包含可执行文件，也可以省略可执行文件，在这种情况下，您还必须指定 ENTRYPOINT 指令。</p><h4 id="arg-和-env" tabindex="-1">ARG 和 ENV <a class="header-anchor" href="#arg-和-env" aria-label="Permalink to &quot;ARG 和 ENV&quot;">​</a></h4><ol><li>ARG</li></ol><p>ARG 指令定义了一个变量，用户可以在构建时使用--build-arg = 传递，docker build 命令会将其传递给构建器。 --build-arg 指定参数会覆盖 Dockerfile 中指定的同名参数 如果用户指定了 未在 Dockerfile 中定义的构建参数 ，则构建会输出 警告 。 ARG 只在构建期有效，运行期无效</p><ol start="2"><li>ENV</li></ol><p>在构建阶段中所有后续指令的环境中使用，并且在许多情况下也可以内联替换。 引号和反斜杠可用于在值中包含空格。 ENV 可以使用 key value 的写法，但是这种不建议使用了，后续版本可能会删除</p><h4 id="add-和-copy" tabindex="-1">ADD 和 COPY <a class="header-anchor" href="#add-和-copy" aria-label="Permalink to &quot;ADD 和 COPY&quot;">​</a></h4><p>COPY 的两种写法</p><ol><li><p>COPY 指令从 src 复制新文件或目录，并将它们添加到容器的文件系统中，路径为 dest 。</p></li><li><p>可以指定多个 src 资源，但是文件和目录的路径将被解释为相对于构建上下文的源。 每个 src 都可以包含通配符，并且匹配将使用 Go 的 filepath.Match 规则进行。</p></li></ol><h3 id="dockerfile-最佳实践-多阶段构建" tabindex="-1">Dockerfile 最佳实践，多阶段构建 <a class="header-anchor" href="#dockerfile-最佳实践-多阶段构建" aria-label="Permalink to &quot;Dockerfile 最佳实践，多阶段构建&quot;">​</a></h3><p>让镜像变小</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 第一阶段：环境构建;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FROM</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> maven:3.5.0-jdk-8-alpine</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> AS</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> builder</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WORKDIR</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /app</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ADD</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /app</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RUN</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mvn</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clean</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> package</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Dmaven.test.skip=true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 第二阶段，最小运行时环境，只需要jre</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FROM</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> openjdk:8-jre-alpine</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 修改时区</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RUN</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ln</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -sf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /usr/share/zoneinfo/Asia/Shanghai</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /etc/localtime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&#39;Asia/Shanghai&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/etc/timezone</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">LABEL</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> maintainer=&quot;534096094@qq.com&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 从上一个阶段复制内容</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">COPY</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --from=builder</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /app/target/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.jar</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /app.jar</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ENV</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> JAVA_OPTS=&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ENV</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> PARAMS=&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 运行jar包</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ENTRYPOINT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sh&quot;,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;-c&quot;,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;java  </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$JAVA_OPTS</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> -jar /app.jar </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$PARAMS</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ]</span></span></code></pre></div>`,29),h=[n];function e(p,k,r,d,o,F){return a(),i("div",null,h)}const g=s(l,[["render",e]]);export{E as __pageData,g as default};

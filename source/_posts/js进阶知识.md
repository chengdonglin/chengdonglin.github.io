---
title: js进阶知识
date: 2018-12-16 12:25:33
tags:
    - javasript
categories: javascript
---


## js进阶知识

### 值类型与引用类型

#### 值类型与引用类型在内存的存储情况

	  变量名 : 具体值
	  针对栈: 变量名 : 具体值
	  针对堆: 变量名 : 地址值
	

1. 栈内存: 值类型存放的位置

	简单类型比如string,number,boolean,null,undefined存放在栈空间

2. 堆内存: 引用内存存放的位置, 内存空间

	比如:function, object, Array

#### 值类型和引用类型与传递

1. 值类型的复制赋值和引用类型的赋值的区别

	引用类型的赋值操作:将引用类型堆上的内存地址进行赋值
2. 函数参数的引用传递和值传递

	- 如果实参的值类型,会复制一个值类型的副本给函数,不会影响原来的传递参数的值类型变量
	- 如果实参是引用类型,传递只是引用类型的一个地址值,在函数内部操作参数对应的引用对象会影响到传递的参数,也就是会改变原来传递参数的值
			
			var a = 9,b;
			var c = {age:9},d;
			//值类型
			b=a
			b=19
			console.log(a)   //9
			console.log(b)   //19
			//引用类型
			d =c;
			d.age = 22,
			console.log(c.age)  //22
			console.log(d.age)  //22


#### 函数的参数

1. arguments参数

	
		//实现max方法,可以接收任意多个参数,返回参数中最大的哪个值
			function myMax(){
			    if (arguments.length <0){
			        return NaN
			    }
			    var max = arguments[0];
			    for (var i=0; i< arguments.length;i++){
			        if (arguments[i]>max) {
			            max = arguments[i]
			        }
			    }
			    return max
			}
			
			const result = myMax(12,4,6,7,8)
			console.log(result)


2. 函数参数的封装

	如果参数多于4个,难于记忆,可以将参数封装成对象来接受,对象的属性无序的,方便开发任意使用

		var rect = {
		    x:19,
		    y:20,
		    width:256,
		    height:256,
		    bgColor:'#ccc'
		}
		function rect(rectObject){
		    console.log(rectObject + ''+ rectObject.y)
		}


### 函数高级

#### javascript事件循环机制(Event Loop)

- 为什么单线程? 

	Javascript执行线程和UI线程是互斥的

	javascript的任务分为同步任务和异步任务

	同步任务:一般赋值操作,循环,分支语句等

	异步任务:DOM事件,Ajax,BOM等api

- 事件循环机制:

	javascript的执行引擎的主线程从队列中获取任务执行,如果任务是异步任务,那么运行到异步任务的时候,异步任务就退出主线程,主线程进行下一个任务的获取处理. 如果异步任务完成,就插入到任务队列的末尾,等待主线程处理.		
#### 变量作用域
- javscript的解释和执行阶段
	- 解释阶段
		- 词法分析
		- 语法分析
		- 作用域规则确定
	- 执行阶段
		- 创建执行上下文
		- 执行函数代码
		- 垃圾回收

- 函数变量作用域
	1. 作用域:就是变量声明的区域,就是变量和函数的可访问范围,在全局声明的变量为全局可见访问的就是全局变量,如果在函数内部声明的变量只能在函数内部访问
	2. 函数的参数只能在函数内部访问,是局部变量
	3. javascript没有块级作用域,只有函数作用域和全局作用域,for循环内部定义的变量是函数级别的作用域,现在可以通过let解决
	4. 变量没有在函数内声明或者声明的时候没有带var就是全局变量,拥有全局作用域,特殊: var a = b = c = 0;b与c是全局变量.
	5. 全局作用域的变量可以在js中任何地方调用,函数作用域的变量只能在字节函数内部调用,包括字节定义的其他函数都可以直接调用
	6. 变量的作用域是以它声明时为准,因为变量的作用域在js代码的解释阶段已经完成规则的制订


			var t = 9 //全局作用域,全部都可以访问
			function f1() { //f1函数全局作用域
			    var t2 = 10 //t2是f1函数内部可访问
			    console.log(t)
			    function f2() {//函数f2是函数f1的作用域
			        var t3 = 200; //t3只能在f2函数内部调用
			        console.log(t2)
			        return t2*t2 //f2函数可以访问f1函数作用域的变量以及f2字节内部变量
			    }
			    return f2()
			}
			var m =f1()
			console.log(m)

函数的声明与变量同名的化,函数优先级较高,函数是一等公民
#### 变量提升与函数提升
- 变量提升
	1. 如果一个声明的变量在函数体内,那么它的作用域就是函数内部,如果是全局环境下声明的,那么它的作用域就是全局的,通过var声明的变量无法用delete删除的
	2. 函数内部的声明的变量会被提升到函数的头部,函数在解释执行的时候,先进行变量声明处理,然后再运行函数内部的代码
	3. 变量和赋值语句仪器书写,在js引擎解析时候,会将其拆成声明和赋值2部分,声明置顶,赋值保留在原来位置
	4. 变量重复声明不会出错,后面会覆盖前面的

			var a =10
			function f1(){
			    //函数的变量提升,因为在函数执行之前,先创建了函数的EC,
			    //在创建EC的时候以及把函数声明的变量以及初始化为undefined
			    console.log(a) //undefined
			    var a = 19
			    console.log(a) //19
			}
			f1()
			console.log(a) //  10

#### 作用域链
1. 作用域链是一个数组
2. 作用域链是控制变量作用域的有序访问js内部实现
3. 作用域链存储在函数的执行上下文,作用域链存放的是执行环境中的VO或者AO
4. 当前函数的作用域对象都是在最前端,而且全局的在最末端
5. 变量(标识符)的搜索都是从作用域链的最前端向后搜索,直到全局作用域,标识符的解析是沿着作用域链一级一级搜索的过程,从第一个对象开始,逐渐向后回溯,直到找到同名标识符为止,找到后不在继续遍历,找不到就报错
#### 函数的arguments
#### 函数执行上下文
- 执行上下文相关

1. 栈的数据结构:先进后出
2. EC:函数执行环境(或执行上下文)
3. ECS:执行环境栈
4. VO变量对象:js的执行上下文中都有个对象用来存放执行上下文中可被访问但是不能被delete的函数标识符,形参,变量声明等.他们会被挂载这个对象上,对象的属性对应他们的名字对象属性的值对应他们的值但这个对象是规范上或者说是引擎实现上的不可在js环境中访问到活动对象.
5. AO激活对象:有了变量对象存每个上下文的东西,但是它是声明时候被访问呢?就是每进入一个执行上下文时,这个执行上下文的变量对象被激活,也就是该上下文的函数标识符,形参/变量声明就可以被访问了

- 执行上下文的执行栈

1. javascript执行在单线程上,使用代码都是排队执行
2. 一开始浏览器执行全局的代码时,首先创建全局的执行上下文,压入执行栈的顶部.
3. 每当进入一个函数的执行就会创建函数的执行上下文,并且把它压入执行栈的顶部.当函数执行完成后,当前函数的执行上下文出栈,并等待垃圾回收.
4. 浏览器的Js执行引擎总是访问栈定的执行上下文
5. 全局上下文只有唯一的一个,在浏览器关闭的时候出栈.

		//(EQ)代码执行之前的时候,就会立即创建一个全局的执行上下文  global excution context
		//在这个例子当中就是这些函数
		//创建完全局的执行上下文之后,把全局的上下文压入执行栈
		function f1(){
		    console.log('f1')
		}
		function f2(){
		    console.log('f2')
		    f3()
		}
		function f3(){
		    console.log('f3')
		    f4()
		}
		function f4(){
		    console.log('f4')
		}
		
		f1() //代码进入f1函数,函数内的代码在执行之前,js执行引擎立即创建一个f1的
		    //执行环境 f1  Excution Context 立即把这个执行环境压入到执行环境栈中ecs
		    //f1() 函数执行完之后,从执行环境栈中弹出f1的执行上下文
		//f2()函数执行之前,创建f2的执行上下文,压栈到执行环境栈中ECS
		//因为f2调用了f3函数,f3函数执行之前也创建了一个f3的执行 上下文,并压栈到执行环境栈中
		//f3函数调用f4函数,创建f4的EC,并把f4的EC压入到ECS中
		//f4执行完成,f4的EC出栈
		//f3执行完成,f3的EC出栈
		//f2执行完成,f2的EC出栈
		f2()  //f2()-> f3()->f4()  //
##### 执行上下文的声明周期

- 总的生命周期: 创建->执行->出栈等待销毁
- 创建阶段:
	1. 创建作用域链
	2. 创建变量对象(AO):首先初始化函数的参数arguments,初始化函数声明,初始化变量(undefined),函数的优先级要高于变量,如果变量和函数重名,变量被忽略.
		- 创建arguments对象,检查上下文,初始化参数名称和值并创建引用的复制
		- 扫描上下文的函数声明(而非函数表达式):
			- 为发现的每一个函数,在变量对象创建一个属性--确切的说是函数的名字,其有一个指向函数在内存中的引用
			- 如果函数的名字已经存在,引用指针将被重写
		- 扫描上下文的变量声明:
			- 为发现的每个变量声明,在变量对象上创建一个属性-就是变量的名字,并且将变量的初始值为undefined
			- 如果变量的名字已经在变量对象里存在,将不会进行任何操作并继续扫描
		- 求出上下文的内部this的值
- 执行阶段:
	- 执行变量赋值,代码执行
- 回收阶段
	- 执行上下文出栈等待虚拟机回收执行上下文

			//变量声明
			var a1 = 19,
			    a2 = 20,
			    a3 = 'sss',
			    b1 = {name:'lcd'}
			//函数声明
			a1 = f1(a1,a2) 
			//函数声明
			function f1(a,b){
			    //f1函数的执行上下文
			    //第一步:扫描参数, a =19, b = 20
			    //第二步:扫描函数声明 f2 = function(){}
			    //第三步:扫描变量声明  t=undefined  m = undifined i = undefined   变量提升
			    var t =0,
			        m =10;
			    for (var i= 0;i< a;i++){
			        console.log(i)
			    }
			    function f2() {
			        console.log(f2)
			    }
			    return a + b;
			}

#### 构造函数内部执行过程
#### 函数的四种调用模式
#### 没有重载
#### 函数的属性和方法(.length,.prototype)









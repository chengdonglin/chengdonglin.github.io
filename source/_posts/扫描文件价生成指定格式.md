---
title: 扫描文件夹生成指定格式
date: 2018-12-07 17:10:50
tags:
	- 导航
    - javascript
categories: electron
---


### 扫描文件夹生成指定格式

最近在做本地系统,需要对本地文件夹进行扫描生成树的格式看到一个插件非常不错


github地址:https://github.com/Lemonreds/folder2some


	#### 源码
	
	/**
	 * 2018-4-3
	 */
	const fs = require('fs'),
	    path = require('path')
	
	
	const defaults = {
	    ignore: [],
	    generateFile: false
	}
	class Folder2some {
	
	    constructor(dir, options) {
	        this.dir = dir
	        this.options = Object.assign(defaults, options)
	        this.files = null
	    }
	
	    toTree() {
	
	        let tree = ''
	        let read = (dir, space = ' ') => {
	
	            let files = fs.readdirSync(dir),
	                len = files.length
	
	            files.sort((a, b) => {
	                let s = fs.statSync(path.resolve(dir, a))
	                if (s.isDirectory()) {
	                    return -1
	                }
	                return 1
	            })
	
	            files.forEach((file, idx) => {
	
	                if (this._isIgnore(file)) {
	                    return
	                }
	
	                let stat, sign
	                idx === len - 1 ? sign = '└─' : sign = '├─'
	
	                tree = tree + space.replace('|', '') + sign + file + '\n'
	
	
	                stat = fs.statSync(path.resolve(dir, file))
	
	                if (stat.isDirectory()) {
	                    read(path.resolve(dir, file), space + '│' + ' ')
	                }
	            })
	        }
	
	        read(this.dir)
	        this._makeFile(tree, '_tree.txt')
	        return tree
	    }
	
	    toJSON() {
	
	        let read = (dir, container) => {
	
	            let files = fs.readdirSync(dir),
	                stat
	
	            files.forEach(file => {
	
	                if (this._isIgnore(file)) {
	                    return
	                }
	
	                stat = fs.statSync(path.resolve(dir, file))
	
	                if (stat.isFile()) {
	                    container.push(file)
	                } else {
	
	                    let directory = {
	                        [file]: []
	                    }
	                    container.push(directory)
	                    read(path.resolve(dir, file), directory[file])
	                }
	            })
	        }
	
	        let ft = []
	        read(this.dir, ft)
	        this._makeFile(ft, '_json.txt', true)
	        return JSON.stringify(ft, null, 2)
	    }
	
	    toAnalysis() {
	
	        let datas = this._toData(this.dir),
	            totalSize = 0,
	            totalCount = 0,
	            extPercent = []
	
	        for (let i = 0; i < datas.length; i++) {
	            totalSize += datas[i].size
	            totalCount += datas[i].count
	        }
	
	        for (let j = 0; j < datas.length; j++) {
	
	            extPercent.push({
	                ext: datas[j].ext,
	                percent: ((datas[j].size / totalSize) * 100).toFixed(2),
	                count: datas[j].count
	            })
	        }
	
	        let analysis = JSON.stringify({
	            path: this.dir,
	            totalSize: (totalSize / 1024).toFixed(2) + 'KB', //B => KB
	            totalCount: totalCount,
	            extPercent: extPercent
	        }, null, 2);
	
	        this._makeFile(analysis, '_analysis.txt')
	        return analysis
	
	    }
	    _toData() {
	
	        let datas = []
	        let read = dir => {
	
	            let files = fs.readdirSync(dir),
	                stat
	
	            files.forEach(file => {
	
	                if (this._isIgnore(file)) {
	                    return
	                }
	
	                stat = fs.statSync(path.resolve(dir, file))
	                if (stat.isFile()) {
	
	                    let i = 0,
	                        isExist = false,
	                        ext = file.substring(file.lastIndexOf('.'), file.length),
	                        size = stat.size
	
	
	                    for (; i < datas.length; i++) {
	
	                        if (datas[i].ext === ext) {
	                            datas[i].size += size
	                            datas[i].count++
	                                isExist = true
	                            break
	                        }
	                    }
	
	                    if (!isExist) {
	                        datas.push({
	                            ext: ext,
	                            size: size,
	                            count: 1
	                        })
	                    }
	
	
	                } else {
	                    read(path.resolve(dir, file))
	                }
	            })
	        }
	        read(this.dir)
	        return datas
	    }
	
	    
	
	    _makeFile(data, filename, toJson = false) {
	
	        if (this.options.generateFile) {
	            fs.writeFileSync(filename,
	                toJson ? JSON.stringify(data, null, 2) : data)
	        }
	    }
	
	    _isIgnore(file) {
	        for (let ig of this.options.ignore) {
	            if (typeof file === 'string' && file.toLowerCase() === ig.toLowerCase()) {
	                return true
	            }
	        }
	        return false
	    }
	}
	
	
	module.exports = Folder2some



#### 使用方式:

	let FT = require('./index'),
	    dir = './';
	
	let ft = new FT(dir,{ 
	    ignore: ['node_modules','.git'],
	    generateFile: true
	})
	
	console.log(ft.toTree())
	console.log(ft.toJSON())
	console.log(ft.toAnalysis())

#### 另外一种

		var fs = require('fs')
		
		
		//遍历文件夹，获取所有文件夹里面的文件信息
		/*
		 * @param path 路径
		 *
		 */
		
		function geFileList(path)
		{
		   var filesList = [];
		   var targetObj = {};
		   readFile(path,filesList,targetObj);
		   return filesList;
		}
		
		//遍历读取文件
		function readFile(path,filesList,targetObj)
		{
		   files = fs.readdirSync(path);//需要用到同步读取
		   files.forEach(walk);
		   function walk(file)
		   {  
		        states = fs.statSync(path+'/'+file);         
		        if(states.isDirectory())
		        {
		            var item ;
		            if(targetObj["children"])
		            {
		                item = {name:file,children:[]};
		                targetObj["children"].push(item);
		            }
		            else
		            {
		               item = {name:file,children:[]};
		               filesList.push(item);
		            }
		
		            readFile(path+'/'+file,filesList,item);
		        }
		        else
		        {   
		            //创建一个对象保存信息
		            var obj = new Object();
		            obj.size = states.size;//文件大小，以字节为单位
		            obj.name = file;//文件名
		            obj.path = path+'/'+file; //文件绝对路径
		
		            if(targetObj["children"])
		            {
		               var item = {name:file,value:obj.path}
		               targetObj["children"].push(item);
		            }
		            else
		            {
		                var item = {name:file,value:obj.path};
		                filesList.push(item);
		            }
		        }     
		    }
		}
		
		//写入文件utf-8格式
		function writeFile(fileName,data)
		{  
		  fs.writeFile(fileName,data,'utf-8',complete);
		  function complete()
		  {
		     console.log("文件生成成功");
		  } 
		}
		
		
		var filesList = geFileList("D:/Program Files/Egret/EgretEngine/win/egret/src");
		var str = JSON.stringify(filesList);
		str = "var data ={name:'Egret',children:#1}".replace("#1",str);
		writeFile("tree.js",str);



原文：https://blog.csdn.net/hero82748274/article/